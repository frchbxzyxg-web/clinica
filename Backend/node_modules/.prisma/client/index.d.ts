
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model administrador
 * 
 */
export type administrador = $Result.DefaultSelection<Prisma.$administradorPayload>
/**
 * Model cita
 * 
 */
export type cita = $Result.DefaultSelection<Prisma.$citaPayload>
/**
 * Model consulta
 * 
 */
export type consulta = $Result.DefaultSelection<Prisma.$consultaPayload>
/**
 * Model detallepago
 * 
 */
export type detallepago = $Result.DefaultSelection<Prisma.$detallepagoPayload>
/**
 * Model diagnostico
 * 
 */
export type diagnostico = $Result.DefaultSelection<Prisma.$diagnosticoPayload>
/**
 * Model doctor
 * 
 */
export type doctor = $Result.DefaultSelection<Prisma.$doctorPayload>
/**
 * Model especialidad
 * 
 */
export type especialidad = $Result.DefaultSelection<Prisma.$especialidadPayload>
/**
 * Model especialidad_doctor
 * 
 */
export type especialidad_doctor = $Result.DefaultSelection<Prisma.$especialidad_doctorPayload>
/**
 * Model examen
 * 
 */
export type examen = $Result.DefaultSelection<Prisma.$examenPayload>
/**
 * Model medicamento
 * 
 */
export type medicamento = $Result.DefaultSelection<Prisma.$medicamentoPayload>
/**
 * Model paciente
 * 
 */
export type paciente = $Result.DefaultSelection<Prisma.$pacientePayload>
/**
 * Model pago
 * 
 */
export type pago = $Result.DefaultSelection<Prisma.$pagoPayload>
/**
 * Model prescripcion
 * 
 */
export type prescripcion = $Result.DefaultSelection<Prisma.$prescripcionPayload>
/**
 * Model proveedor
 * 
 */
export type proveedor = $Result.DefaultSelection<Prisma.$proveedorPayload>
/**
 * Model receta
 * 
 */
export type receta = $Result.DefaultSelection<Prisma.$recetaPayload>
/**
 * Model secretaria
 * 
 */
export type secretaria = $Result.DefaultSelection<Prisma.$secretariaPayload>
/**
 * Model telefono
 * 
 */
export type telefono = $Result.DefaultSelection<Prisma.$telefonoPayload>
/**
 * Model tratamiento
 * 
 */
export type tratamiento = $Result.DefaultSelection<Prisma.$tratamientoPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Administradors
 * const administradors = await prisma.administrador.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Administradors
   * const administradors = await prisma.administrador.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.administrador`: Exposes CRUD operations for the **administrador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administradors
    * const administradors = await prisma.administrador.findMany()
    * ```
    */
  get administrador(): Prisma.administradorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cita`: Exposes CRUD operations for the **cita** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Citas
    * const citas = await prisma.cita.findMany()
    * ```
    */
  get cita(): Prisma.citaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consulta`: Exposes CRUD operations for the **consulta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultas
    * const consultas = await prisma.consulta.findMany()
    * ```
    */
  get consulta(): Prisma.consultaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detallepago`: Exposes CRUD operations for the **detallepago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detallepagos
    * const detallepagos = await prisma.detallepago.findMany()
    * ```
    */
  get detallepago(): Prisma.detallepagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnostico`: Exposes CRUD operations for the **diagnostico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnosticos
    * const diagnosticos = await prisma.diagnostico.findMany()
    * ```
    */
  get diagnostico(): Prisma.diagnosticoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.doctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.especialidad`: Exposes CRUD operations for the **especialidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialidads
    * const especialidads = await prisma.especialidad.findMany()
    * ```
    */
  get especialidad(): Prisma.especialidadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.especialidad_doctor`: Exposes CRUD operations for the **especialidad_doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialidad_doctors
    * const especialidad_doctors = await prisma.especialidad_doctor.findMany()
    * ```
    */
  get especialidad_doctor(): Prisma.especialidad_doctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examen`: Exposes CRUD operations for the **examen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examen
    * const examen = await prisma.examen.findMany()
    * ```
    */
  get examen(): Prisma.examenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicamento`: Exposes CRUD operations for the **medicamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicamentos
    * const medicamentos = await prisma.medicamento.findMany()
    * ```
    */
  get medicamento(): Prisma.medicamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paciente`: Exposes CRUD operations for the **paciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacientes
    * const pacientes = await prisma.paciente.findMany()
    * ```
    */
  get paciente(): Prisma.pacienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.pagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescripcion`: Exposes CRUD operations for the **prescripcion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescripcions
    * const prescripcions = await prisma.prescripcion.findMany()
    * ```
    */
  get prescripcion(): Prisma.prescripcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proveedor`: Exposes CRUD operations for the **proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.proveedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receta`: Exposes CRUD operations for the **receta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recetas
    * const recetas = await prisma.receta.findMany()
    * ```
    */
  get receta(): Prisma.recetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.secretaria`: Exposes CRUD operations for the **secretaria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Secretarias
    * const secretarias = await prisma.secretaria.findMany()
    * ```
    */
  get secretaria(): Prisma.secretariaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telefono`: Exposes CRUD operations for the **telefono** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Telefonos
    * const telefonos = await prisma.telefono.findMany()
    * ```
    */
  get telefono(): Prisma.telefonoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tratamiento`: Exposes CRUD operations for the **tratamiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tratamientos
    * const tratamientos = await prisma.tratamiento.findMany()
    * ```
    */
  get tratamiento(): Prisma.tratamientoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    administrador: 'administrador',
    cita: 'cita',
    consulta: 'consulta',
    detallepago: 'detallepago',
    diagnostico: 'diagnostico',
    doctor: 'doctor',
    especialidad: 'especialidad',
    especialidad_doctor: 'especialidad_doctor',
    examen: 'examen',
    medicamento: 'medicamento',
    paciente: 'paciente',
    pago: 'pago',
    prescripcion: 'prescripcion',
    proveedor: 'proveedor',
    receta: 'receta',
    secretaria: 'secretaria',
    telefono: 'telefono',
    tratamiento: 'tratamiento',
    usuario: 'usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "administrador" | "cita" | "consulta" | "detallepago" | "diagnostico" | "doctor" | "especialidad" | "especialidad_doctor" | "examen" | "medicamento" | "paciente" | "pago" | "prescripcion" | "proveedor" | "receta" | "secretaria" | "telefono" | "tratamiento" | "usuario"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      administrador: {
        payload: Prisma.$administradorPayload<ExtArgs>
        fields: Prisma.administradorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.administradorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.administradorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          findFirst: {
            args: Prisma.administradorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.administradorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          findMany: {
            args: Prisma.administradorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          create: {
            args: Prisma.administradorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          createMany: {
            args: Prisma.administradorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.administradorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          delete: {
            args: Prisma.administradorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          update: {
            args: Prisma.administradorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          deleteMany: {
            args: Prisma.administradorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.administradorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.administradorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          upsert: {
            args: Prisma.administradorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          aggregate: {
            args: Prisma.AdministradorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrador>
          }
          groupBy: {
            args: Prisma.administradorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministradorGroupByOutputType>[]
          }
          count: {
            args: Prisma.administradorCountArgs<ExtArgs>
            result: $Utils.Optional<AdministradorCountAggregateOutputType> | number
          }
        }
      }
      cita: {
        payload: Prisma.$citaPayload<ExtArgs>
        fields: Prisma.citaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.citaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.citaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          findFirst: {
            args: Prisma.citaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.citaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          findMany: {
            args: Prisma.citaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>[]
          }
          create: {
            args: Prisma.citaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          createMany: {
            args: Prisma.citaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.citaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>[]
          }
          delete: {
            args: Prisma.citaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          update: {
            args: Prisma.citaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          deleteMany: {
            args: Prisma.citaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.citaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.citaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>[]
          }
          upsert: {
            args: Prisma.citaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citaPayload>
          }
          aggregate: {
            args: Prisma.CitaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCita>
          }
          groupBy: {
            args: Prisma.citaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitaGroupByOutputType>[]
          }
          count: {
            args: Prisma.citaCountArgs<ExtArgs>
            result: $Utils.Optional<CitaCountAggregateOutputType> | number
          }
        }
      }
      consulta: {
        payload: Prisma.$consultaPayload<ExtArgs>
        fields: Prisma.consultaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          findFirst: {
            args: Prisma.consultaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          findMany: {
            args: Prisma.consultaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>[]
          }
          create: {
            args: Prisma.consultaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          createMany: {
            args: Prisma.consultaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consultaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>[]
          }
          delete: {
            args: Prisma.consultaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          update: {
            args: Prisma.consultaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          deleteMany: {
            args: Prisma.consultaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consultaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>[]
          }
          upsert: {
            args: Prisma.consultaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultaPayload>
          }
          aggregate: {
            args: Prisma.ConsultaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsulta>
          }
          groupBy: {
            args: Prisma.consultaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultaGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultaCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultaCountAggregateOutputType> | number
          }
        }
      }
      detallepago: {
        payload: Prisma.$detallepagoPayload<ExtArgs>
        fields: Prisma.detallepagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detallepagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detallepagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          findFirst: {
            args: Prisma.detallepagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detallepagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          findMany: {
            args: Prisma.detallepagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>[]
          }
          create: {
            args: Prisma.detallepagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          createMany: {
            args: Prisma.detallepagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.detallepagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>[]
          }
          delete: {
            args: Prisma.detallepagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          update: {
            args: Prisma.detallepagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          deleteMany: {
            args: Prisma.detallepagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detallepagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.detallepagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>[]
          }
          upsert: {
            args: Prisma.detallepagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detallepagoPayload>
          }
          aggregate: {
            args: Prisma.DetallepagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetallepago>
          }
          groupBy: {
            args: Prisma.detallepagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetallepagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.detallepagoCountArgs<ExtArgs>
            result: $Utils.Optional<DetallepagoCountAggregateOutputType> | number
          }
        }
      }
      diagnostico: {
        payload: Prisma.$diagnosticoPayload<ExtArgs>
        fields: Prisma.diagnosticoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diagnosticoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diagnosticoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          findFirst: {
            args: Prisma.diagnosticoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diagnosticoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          findMany: {
            args: Prisma.diagnosticoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          create: {
            args: Prisma.diagnosticoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          createMany: {
            args: Prisma.diagnosticoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.diagnosticoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          delete: {
            args: Prisma.diagnosticoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          update: {
            args: Prisma.diagnosticoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          deleteMany: {
            args: Prisma.diagnosticoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.diagnosticoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.diagnosticoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          upsert: {
            args: Prisma.diagnosticoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          aggregate: {
            args: Prisma.DiagnosticoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnostico>
          }
          groupBy: {
            args: Prisma.diagnosticoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticoGroupByOutputType>[]
          }
          count: {
            args: Prisma.diagnosticoCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticoCountAggregateOutputType> | number
          }
        }
      }
      doctor: {
        payload: Prisma.$doctorPayload<ExtArgs>
        fields: Prisma.doctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.doctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.doctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          findFirst: {
            args: Prisma.doctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.doctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          findMany: {
            args: Prisma.doctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>[]
          }
          create: {
            args: Prisma.doctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          createMany: {
            args: Prisma.doctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.doctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>[]
          }
          delete: {
            args: Prisma.doctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          update: {
            args: Prisma.doctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          deleteMany: {
            args: Prisma.doctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.doctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.doctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>[]
          }
          upsert: {
            args: Prisma.doctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$doctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.doctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.doctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      especialidad: {
        payload: Prisma.$especialidadPayload<ExtArgs>
        fields: Prisma.especialidadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especialidadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especialidadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          findFirst: {
            args: Prisma.especialidadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especialidadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          findMany: {
            args: Prisma.especialidadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>[]
          }
          create: {
            args: Prisma.especialidadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          createMany: {
            args: Prisma.especialidadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.especialidadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>[]
          }
          delete: {
            args: Prisma.especialidadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          update: {
            args: Prisma.especialidadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          deleteMany: {
            args: Prisma.especialidadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.especialidadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.especialidadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>[]
          }
          upsert: {
            args: Prisma.especialidadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          aggregate: {
            args: Prisma.EspecialidadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecialidad>
          }
          groupBy: {
            args: Prisma.especialidadGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadGroupByOutputType>[]
          }
          count: {
            args: Prisma.especialidadCountArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadCountAggregateOutputType> | number
          }
        }
      }
      especialidad_doctor: {
        payload: Prisma.$especialidad_doctorPayload<ExtArgs>
        fields: Prisma.especialidad_doctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especialidad_doctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especialidad_doctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          findFirst: {
            args: Prisma.especialidad_doctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especialidad_doctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          findMany: {
            args: Prisma.especialidad_doctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>[]
          }
          create: {
            args: Prisma.especialidad_doctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          createMany: {
            args: Prisma.especialidad_doctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.especialidad_doctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>[]
          }
          delete: {
            args: Prisma.especialidad_doctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          update: {
            args: Prisma.especialidad_doctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          deleteMany: {
            args: Prisma.especialidad_doctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.especialidad_doctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.especialidad_doctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>[]
          }
          upsert: {
            args: Prisma.especialidad_doctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidad_doctorPayload>
          }
          aggregate: {
            args: Prisma.Especialidad_doctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecialidad_doctor>
          }
          groupBy: {
            args: Prisma.especialidad_doctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Especialidad_doctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.especialidad_doctorCountArgs<ExtArgs>
            result: $Utils.Optional<Especialidad_doctorCountAggregateOutputType> | number
          }
        }
      }
      examen: {
        payload: Prisma.$examenPayload<ExtArgs>
        fields: Prisma.examenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          findFirst: {
            args: Prisma.examenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          findMany: {
            args: Prisma.examenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>[]
          }
          create: {
            args: Prisma.examenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          createMany: {
            args: Prisma.examenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.examenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>[]
          }
          delete: {
            args: Prisma.examenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          update: {
            args: Prisma.examenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          deleteMany: {
            args: Prisma.examenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.examenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>[]
          }
          upsert: {
            args: Prisma.examenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenPayload>
          }
          aggregate: {
            args: Prisma.ExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamen>
          }
          groupBy: {
            args: Prisma.examenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.examenCountArgs<ExtArgs>
            result: $Utils.Optional<ExamenCountAggregateOutputType> | number
          }
        }
      }
      medicamento: {
        payload: Prisma.$medicamentoPayload<ExtArgs>
        fields: Prisma.medicamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          findFirst: {
            args: Prisma.medicamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          findMany: {
            args: Prisma.medicamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>[]
          }
          create: {
            args: Prisma.medicamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          createMany: {
            args: Prisma.medicamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medicamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>[]
          }
          delete: {
            args: Prisma.medicamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          update: {
            args: Prisma.medicamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          deleteMany: {
            args: Prisma.medicamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.medicamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>[]
          }
          upsert: {
            args: Prisma.medicamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicamentoPayload>
          }
          aggregate: {
            args: Prisma.MedicamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicamento>
          }
          groupBy: {
            args: Prisma.medicamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicamentoCountArgs<ExtArgs>
            result: $Utils.Optional<MedicamentoCountAggregateOutputType> | number
          }
        }
      }
      paciente: {
        payload: Prisma.$pacientePayload<ExtArgs>
        fields: Prisma.pacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          findFirst: {
            args: Prisma.pacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          findMany: {
            args: Prisma.pacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>[]
          }
          create: {
            args: Prisma.pacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          createMany: {
            args: Prisma.pacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>[]
          }
          delete: {
            args: Prisma.pacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          update: {
            args: Prisma.pacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          deleteMany: {
            args: Prisma.pacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pacienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>[]
          }
          upsert: {
            args: Prisma.pacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientePayload>
          }
          aggregate: {
            args: Prisma.PacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaciente>
          }
          groupBy: {
            args: Prisma.pacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.pacienteCountArgs<ExtArgs>
            result: $Utils.Optional<PacienteCountAggregateOutputType> | number
          }
        }
      }
      pago: {
        payload: Prisma.$pagoPayload<ExtArgs>
        fields: Prisma.pagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          findFirst: {
            args: Prisma.pagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          findMany: {
            args: Prisma.pagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>[]
          }
          create: {
            args: Prisma.pagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          createMany: {
            args: Prisma.pagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>[]
          }
          delete: {
            args: Prisma.pagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          update: {
            args: Prisma.pagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          deleteMany: {
            args: Prisma.pagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>[]
          }
          upsert: {
            args: Prisma.pagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.pagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagoCountArgs<ExtArgs>
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      prescripcion: {
        payload: Prisma.$prescripcionPayload<ExtArgs>
        fields: Prisma.prescripcionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prescripcionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prescripcionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          findFirst: {
            args: Prisma.prescripcionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prescripcionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          findMany: {
            args: Prisma.prescripcionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>[]
          }
          create: {
            args: Prisma.prescripcionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          createMany: {
            args: Prisma.prescripcionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prescripcionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>[]
          }
          delete: {
            args: Prisma.prescripcionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          update: {
            args: Prisma.prescripcionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          deleteMany: {
            args: Prisma.prescripcionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prescripcionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.prescripcionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>[]
          }
          upsert: {
            args: Prisma.prescripcionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescripcionPayload>
          }
          aggregate: {
            args: Prisma.PrescripcionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescripcion>
          }
          groupBy: {
            args: Prisma.prescripcionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescripcionGroupByOutputType>[]
          }
          count: {
            args: Prisma.prescripcionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescripcionCountAggregateOutputType> | number
          }
        }
      }
      proveedor: {
        payload: Prisma.$proveedorPayload<ExtArgs>
        fields: Prisma.proveedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proveedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proveedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findFirst: {
            args: Prisma.proveedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proveedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findMany: {
            args: Prisma.proveedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>[]
          }
          create: {
            args: Prisma.proveedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          createMany: {
            args: Prisma.proveedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proveedorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>[]
          }
          delete: {
            args: Prisma.proveedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          update: {
            args: Prisma.proveedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          deleteMany: {
            args: Prisma.proveedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proveedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.proveedorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>[]
          }
          upsert: {
            args: Prisma.proveedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          aggregate: {
            args: Prisma.ProveedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProveedor>
          }
          groupBy: {
            args: Prisma.proveedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProveedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.proveedorCountArgs<ExtArgs>
            result: $Utils.Optional<ProveedorCountAggregateOutputType> | number
          }
        }
      }
      receta: {
        payload: Prisma.$recetaPayload<ExtArgs>
        fields: Prisma.recetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          findFirst: {
            args: Prisma.recetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          findMany: {
            args: Prisma.recetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>[]
          }
          create: {
            args: Prisma.recetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          createMany: {
            args: Prisma.recetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>[]
          }
          delete: {
            args: Prisma.recetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          update: {
            args: Prisma.recetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          deleteMany: {
            args: Prisma.recetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>[]
          }
          upsert: {
            args: Prisma.recetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetaPayload>
          }
          aggregate: {
            args: Prisma.RecetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceta>
          }
          groupBy: {
            args: Prisma.recetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.recetaCountArgs<ExtArgs>
            result: $Utils.Optional<RecetaCountAggregateOutputType> | number
          }
        }
      }
      secretaria: {
        payload: Prisma.$secretariaPayload<ExtArgs>
        fields: Prisma.secretariaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.secretariaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.secretariaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          findFirst: {
            args: Prisma.secretariaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.secretariaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          findMany: {
            args: Prisma.secretariaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>[]
          }
          create: {
            args: Prisma.secretariaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          createMany: {
            args: Prisma.secretariaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.secretariaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>[]
          }
          delete: {
            args: Prisma.secretariaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          update: {
            args: Prisma.secretariaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          deleteMany: {
            args: Prisma.secretariaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.secretariaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.secretariaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>[]
          }
          upsert: {
            args: Prisma.secretariaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$secretariaPayload>
          }
          aggregate: {
            args: Prisma.SecretariaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecretaria>
          }
          groupBy: {
            args: Prisma.secretariaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecretariaGroupByOutputType>[]
          }
          count: {
            args: Prisma.secretariaCountArgs<ExtArgs>
            result: $Utils.Optional<SecretariaCountAggregateOutputType> | number
          }
        }
      }
      telefono: {
        payload: Prisma.$telefonoPayload<ExtArgs>
        fields: Prisma.telefonoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.telefonoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.telefonoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          findFirst: {
            args: Prisma.telefonoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.telefonoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          findMany: {
            args: Prisma.telefonoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>[]
          }
          create: {
            args: Prisma.telefonoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          createMany: {
            args: Prisma.telefonoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.telefonoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>[]
          }
          delete: {
            args: Prisma.telefonoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          update: {
            args: Prisma.telefonoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          deleteMany: {
            args: Prisma.telefonoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.telefonoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.telefonoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>[]
          }
          upsert: {
            args: Prisma.telefonoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          aggregate: {
            args: Prisma.TelefonoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelefono>
          }
          groupBy: {
            args: Prisma.telefonoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelefonoGroupByOutputType>[]
          }
          count: {
            args: Prisma.telefonoCountArgs<ExtArgs>
            result: $Utils.Optional<TelefonoCountAggregateOutputType> | number
          }
        }
      }
      tratamiento: {
        payload: Prisma.$tratamientoPayload<ExtArgs>
        fields: Prisma.tratamientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tratamientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tratamientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          findFirst: {
            args: Prisma.tratamientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tratamientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          findMany: {
            args: Prisma.tratamientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>[]
          }
          create: {
            args: Prisma.tratamientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          createMany: {
            args: Prisma.tratamientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tratamientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>[]
          }
          delete: {
            args: Prisma.tratamientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          update: {
            args: Prisma.tratamientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          deleteMany: {
            args: Prisma.tratamientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tratamientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tratamientoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>[]
          }
          upsert: {
            args: Prisma.tratamientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tratamientoPayload>
          }
          aggregate: {
            args: Prisma.TratamientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTratamiento>
          }
          groupBy: {
            args: Prisma.tratamientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TratamientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.tratamientoCountArgs<ExtArgs>
            result: $Utils.Optional<TratamientoCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    administrador?: administradorOmit
    cita?: citaOmit
    consulta?: consultaOmit
    detallepago?: detallepagoOmit
    diagnostico?: diagnosticoOmit
    doctor?: doctorOmit
    especialidad?: especialidadOmit
    especialidad_doctor?: especialidad_doctorOmit
    examen?: examenOmit
    medicamento?: medicamentoOmit
    paciente?: pacienteOmit
    pago?: pagoOmit
    prescripcion?: prescripcionOmit
    proveedor?: proveedorOmit
    receta?: recetaOmit
    secretaria?: secretariaOmit
    telefono?: telefonoOmit
    tratamiento?: tratamientoOmit
    usuario?: usuarioOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CitaCountOutputType
   */

  export type CitaCountOutputType = {
    consulta: number
  }

  export type CitaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consulta?: boolean | CitaCountOutputTypeCountConsultaArgs
  }

  // Custom InputTypes
  /**
   * CitaCountOutputType without action
   */
  export type CitaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitaCountOutputType
     */
    select?: CitaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CitaCountOutputType without action
   */
  export type CitaCountOutputTypeCountConsultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultaWhereInput
  }


  /**
   * Count Type ConsultaCountOutputType
   */

  export type ConsultaCountOutputType = {
    diagnostico: number
  }

  export type ConsultaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | ConsultaCountOutputTypeCountDiagnosticoArgs
  }

  // Custom InputTypes
  /**
   * ConsultaCountOutputType without action
   */
  export type ConsultaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultaCountOutputType
     */
    select?: ConsultaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultaCountOutputType without action
   */
  export type ConsultaCountOutputTypeCountDiagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosticoWhereInput
  }


  /**
   * Count Type DiagnosticoCountOutputType
   */

  export type DiagnosticoCountOutputType = {
    tratamiento: number
  }

  export type DiagnosticoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tratamiento?: boolean | DiagnosticoCountOutputTypeCountTratamientoArgs
  }

  // Custom InputTypes
  /**
   * DiagnosticoCountOutputType without action
   */
  export type DiagnosticoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticoCountOutputType
     */
    select?: DiagnosticoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosticoCountOutputType without action
   */
  export type DiagnosticoCountOutputTypeCountTratamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tratamientoWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    cita: number
    especialidad_doctor: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | DoctorCountOutputTypeCountCitaArgs
    especialidad_doctor?: boolean | DoctorCountOutputTypeCountEspecialidad_doctorArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citaWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountEspecialidad_doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidad_doctorWhereInput
  }


  /**
   * Count Type EspecialidadCountOutputType
   */

  export type EspecialidadCountOutputType = {
    doctor: number
    especialidad_doctor: number
  }

  export type EspecialidadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | EspecialidadCountOutputTypeCountDoctorArgs
    especialidad_doctor?: boolean | EspecialidadCountOutputTypeCountEspecialidad_doctorArgs
  }

  // Custom InputTypes
  /**
   * EspecialidadCountOutputType without action
   */
  export type EspecialidadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecialidadCountOutputType
     */
    select?: EspecialidadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EspecialidadCountOutputType without action
   */
  export type EspecialidadCountOutputTypeCountDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: doctorWhereInput
  }

  /**
   * EspecialidadCountOutputType without action
   */
  export type EspecialidadCountOutputTypeCountEspecialidad_doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidad_doctorWhereInput
  }


  /**
   * Count Type PacienteCountOutputType
   */

  export type PacienteCountOutputType = {
    cita: number
    examen: number
    pago: number
  }

  export type PacienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | PacienteCountOutputTypeCountCitaArgs
    examen?: boolean | PacienteCountOutputTypeCountExamenArgs
    pago?: boolean | PacienteCountOutputTypeCountPagoArgs
  }

  // Custom InputTypes
  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacienteCountOutputType
     */
    select?: PacienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citaWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountPagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagoWhereInput
  }


  /**
   * Count Type ProveedorCountOutputType
   */

  export type ProveedorCountOutputType = {
    medicamento: number
  }

  export type ProveedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicamento?: boolean | ProveedorCountOutputTypeCountMedicamentoArgs
  }

  // Custom InputTypes
  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountMedicamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicamentoWhereInput
  }


  /**
   * Count Type RecetaCountOutputType
   */

  export type RecetaCountOutputType = {
    prescripcion: number
  }

  export type RecetaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescripcion?: boolean | RecetaCountOutputTypeCountPrescripcionArgs
  }

  // Custom InputTypes
  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaCountOutputType
     */
    select?: RecetaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountPrescripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prescripcionWhereInput
  }


  /**
   * Count Type TratamientoCountOutputType
   */

  export type TratamientoCountOutputType = {
    receta: number
  }

  export type TratamientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receta?: boolean | TratamientoCountOutputTypeCountRecetaArgs
  }

  // Custom InputTypes
  /**
   * TratamientoCountOutputType without action
   */
  export type TratamientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TratamientoCountOutputType
     */
    select?: TratamientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TratamientoCountOutputType without action
   */
  export type TratamientoCountOutputTypeCountRecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetaWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    administrador: number
    doctor: number
    paciente: number
    proveedor: number
    secretaria: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrador?: boolean | UsuarioCountOutputTypeCountAdministradorArgs
    doctor?: boolean | UsuarioCountOutputTypeCountDoctorArgs
    paciente?: boolean | UsuarioCountOutputTypeCountPacienteArgs
    proveedor?: boolean | UsuarioCountOutputTypeCountProveedorArgs
    secretaria?: boolean | UsuarioCountOutputTypeCountSecretariaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAdministradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: administradorWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: doctorWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacienteWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedorWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSecretariaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: secretariaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model administrador
   */

  export type AggregateAdministrador = {
    _count: AdministradorCountAggregateOutputType | null
    _avg: AdministradorAvgAggregateOutputType | null
    _sum: AdministradorSumAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  export type AdministradorAvgAggregateOutputType = {
    id_admin: number | null
    id_usuario: number | null
  }

  export type AdministradorSumAggregateOutputType = {
    id_admin: number | null
    id_usuario: number | null
  }

  export type AdministradorMinAggregateOutputType = {
    id_admin: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_usuario: number | null
    fechaingreso: Date | null
  }

  export type AdministradorMaxAggregateOutputType = {
    id_admin: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_usuario: number | null
    fechaingreso: Date | null
  }

  export type AdministradorCountAggregateOutputType = {
    id_admin: number
    nombre: number
    segundonombre: number
    primerapellido: number
    segundoapellido: number
    nacimiento: number
    celular: number
    telefono: number
    id_usuario: number
    fechaingreso: number
    _all: number
  }


  export type AdministradorAvgAggregateInputType = {
    id_admin?: true
    id_usuario?: true
  }

  export type AdministradorSumAggregateInputType = {
    id_admin?: true
    id_usuario?: true
  }

  export type AdministradorMinAggregateInputType = {
    id_admin?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_usuario?: true
    fechaingreso?: true
  }

  export type AdministradorMaxAggregateInputType = {
    id_admin?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_usuario?: true
    fechaingreso?: true
  }

  export type AdministradorCountAggregateInputType = {
    id_admin?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_usuario?: true
    fechaingreso?: true
    _all?: true
  }

  export type AdministradorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrador to aggregate.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned administradors
    **/
    _count?: true | AdministradorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministradorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministradorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministradorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministradorMaxAggregateInputType
  }

  export type GetAdministradorAggregateType<T extends AdministradorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrador[P]>
      : GetScalarType<T[P], AggregateAdministrador[P]>
  }




  export type administradorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: administradorWhereInput
    orderBy?: administradorOrderByWithAggregationInput | administradorOrderByWithAggregationInput[]
    by: AdministradorScalarFieldEnum[] | AdministradorScalarFieldEnum
    having?: administradorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministradorCountAggregateInputType | true
    _avg?: AdministradorAvgAggregateInputType
    _sum?: AdministradorSumAggregateInputType
    _min?: AdministradorMinAggregateInputType
    _max?: AdministradorMaxAggregateInputType
  }

  export type AdministradorGroupByOutputType = {
    id_admin: number
    nombre: string
    segundonombre: string | null
    primerapellido: string
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_usuario: number | null
    fechaingreso: Date | null
    _count: AdministradorCountAggregateOutputType | null
    _avg: AdministradorAvgAggregateOutputType | null
    _sum: AdministradorSumAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  type GetAdministradorGroupByPayload<T extends administradorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministradorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministradorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
            : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
        }
      >
    >


  export type administradorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechaingreso?: boolean
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechaingreso?: boolean
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechaingreso?: boolean
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectScalar = {
    id_admin?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechaingreso?: boolean
  }

  export type administradorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_admin" | "nombre" | "segundonombre" | "primerapellido" | "segundoapellido" | "nacimiento" | "celular" | "telefono" | "id_usuario" | "fechaingreso", ExtArgs["result"]["administrador"]>
  export type administradorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }
  export type administradorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }
  export type administradorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | administrador$usuarioArgs<ExtArgs>
  }

  export type $administradorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "administrador"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_admin: number
      nombre: string
      segundonombre: string | null
      primerapellido: string
      segundoapellido: string | null
      nacimiento: Date | null
      celular: string | null
      telefono: string | null
      id_usuario: number | null
      fechaingreso: Date | null
    }, ExtArgs["result"]["administrador"]>
    composites: {}
  }

  type administradorGetPayload<S extends boolean | null | undefined | administradorDefaultArgs> = $Result.GetResult<Prisma.$administradorPayload, S>

  type administradorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<administradorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministradorCountAggregateInputType | true
    }

  export interface administradorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['administrador'], meta: { name: 'administrador' } }
    /**
     * Find zero or one Administrador that matches the filter.
     * @param {administradorFindUniqueArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends administradorFindUniqueArgs>(args: SelectSubset<T, administradorFindUniqueArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Administrador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {administradorFindUniqueOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends administradorFindUniqueOrThrowArgs>(args: SelectSubset<T, administradorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindFirstArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends administradorFindFirstArgs>(args?: SelectSubset<T, administradorFindFirstArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindFirstOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends administradorFindFirstOrThrowArgs>(args?: SelectSubset<T, administradorFindFirstOrThrowArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administradors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administradors
     * const administradors = await prisma.administrador.findMany()
     * 
     * // Get first 10 Administradors
     * const administradors = await prisma.administrador.findMany({ take: 10 })
     * 
     * // Only select the `id_admin`
     * const administradorWithId_adminOnly = await prisma.administrador.findMany({ select: { id_admin: true } })
     * 
     */
    findMany<T extends administradorFindManyArgs>(args?: SelectSubset<T, administradorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Administrador.
     * @param {administradorCreateArgs} args - Arguments to create a Administrador.
     * @example
     * // Create one Administrador
     * const Administrador = await prisma.administrador.create({
     *   data: {
     *     // ... data to create a Administrador
     *   }
     * })
     * 
     */
    create<T extends administradorCreateArgs>(args: SelectSubset<T, administradorCreateArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Administradors.
     * @param {administradorCreateManyArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends administradorCreateManyArgs>(args?: SelectSubset<T, administradorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Administradors and returns the data saved in the database.
     * @param {administradorCreateManyAndReturnArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Administradors and only return the `id_admin`
     * const administradorWithId_adminOnly = await prisma.administrador.createManyAndReturn({
     *   select: { id_admin: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends administradorCreateManyAndReturnArgs>(args?: SelectSubset<T, administradorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Administrador.
     * @param {administradorDeleteArgs} args - Arguments to delete one Administrador.
     * @example
     * // Delete one Administrador
     * const Administrador = await prisma.administrador.delete({
     *   where: {
     *     // ... filter to delete one Administrador
     *   }
     * })
     * 
     */
    delete<T extends administradorDeleteArgs>(args: SelectSubset<T, administradorDeleteArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Administrador.
     * @param {administradorUpdateArgs} args - Arguments to update one Administrador.
     * @example
     * // Update one Administrador
     * const administrador = await prisma.administrador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends administradorUpdateArgs>(args: SelectSubset<T, administradorUpdateArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Administradors.
     * @param {administradorDeleteManyArgs} args - Arguments to filter Administradors to delete.
     * @example
     * // Delete a few Administradors
     * const { count } = await prisma.administrador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends administradorDeleteManyArgs>(args?: SelectSubset<T, administradorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends administradorUpdateManyArgs>(args: SelectSubset<T, administradorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors and returns the data updated in the database.
     * @param {administradorUpdateManyAndReturnArgs} args - Arguments to update many Administradors.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Administradors and only return the `id_admin`
     * const administradorWithId_adminOnly = await prisma.administrador.updateManyAndReturn({
     *   select: { id_admin: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends administradorUpdateManyAndReturnArgs>(args: SelectSubset<T, administradorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Administrador.
     * @param {administradorUpsertArgs} args - Arguments to update or create a Administrador.
     * @example
     * // Update or create a Administrador
     * const administrador = await prisma.administrador.upsert({
     *   create: {
     *     // ... data to create a Administrador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrador we want to update
     *   }
     * })
     */
    upsert<T extends administradorUpsertArgs>(args: SelectSubset<T, administradorUpsertArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorCountArgs} args - Arguments to filter Administradors to count.
     * @example
     * // Count the number of Administradors
     * const count = await prisma.administrador.count({
     *   where: {
     *     // ... the filter for the Administradors we want to count
     *   }
     * })
    **/
    count<T extends administradorCountArgs>(
      args?: Subset<T, administradorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministradorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministradorAggregateArgs>(args: Subset<T, AdministradorAggregateArgs>): Prisma.PrismaPromise<GetAdministradorAggregateType<T>>

    /**
     * Group by Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends administradorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: administradorGroupByArgs['orderBy'] }
        : { orderBy?: administradorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, administradorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministradorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the administrador model
   */
  readonly fields: administradorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for administrador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__administradorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends administrador$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, administrador$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the administrador model
   */
  interface administradorFieldRefs {
    readonly id_admin: FieldRef<"administrador", 'Int'>
    readonly nombre: FieldRef<"administrador", 'String'>
    readonly segundonombre: FieldRef<"administrador", 'String'>
    readonly primerapellido: FieldRef<"administrador", 'String'>
    readonly segundoapellido: FieldRef<"administrador", 'String'>
    readonly nacimiento: FieldRef<"administrador", 'DateTime'>
    readonly celular: FieldRef<"administrador", 'String'>
    readonly telefono: FieldRef<"administrador", 'String'>
    readonly id_usuario: FieldRef<"administrador", 'Int'>
    readonly fechaingreso: FieldRef<"administrador", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * administrador findUnique
   */
  export type administradorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador findUniqueOrThrow
   */
  export type administradorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador findFirst
   */
  export type administradorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador findFirstOrThrow
   */
  export type administradorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador findMany
   */
  export type administradorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administradors to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador create
   */
  export type administradorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The data needed to create a administrador.
     */
    data: XOR<administradorCreateInput, administradorUncheckedCreateInput>
  }

  /**
   * administrador createMany
   */
  export type administradorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many administradors.
     */
    data: administradorCreateManyInput | administradorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * administrador createManyAndReturn
   */
  export type administradorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * The data used to create many administradors.
     */
    data: administradorCreateManyInput | administradorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * administrador update
   */
  export type administradorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The data needed to update a administrador.
     */
    data: XOR<administradorUpdateInput, administradorUncheckedUpdateInput>
    /**
     * Choose, which administrador to update.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador updateMany
   */
  export type administradorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update administradors.
     */
    data: XOR<administradorUpdateManyMutationInput, administradorUncheckedUpdateManyInput>
    /**
     * Filter which administradors to update
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to update.
     */
    limit?: number
  }

  /**
   * administrador updateManyAndReturn
   */
  export type administradorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * The data used to update administradors.
     */
    data: XOR<administradorUpdateManyMutationInput, administradorUncheckedUpdateManyInput>
    /**
     * Filter which administradors to update
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * administrador upsert
   */
  export type administradorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The filter to search for the administrador to update in case it exists.
     */
    where: administradorWhereUniqueInput
    /**
     * In case the administrador found by the `where` argument doesn't exist, create a new administrador with this data.
     */
    create: XOR<administradorCreateInput, administradorUncheckedCreateInput>
    /**
     * In case the administrador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<administradorUpdateInput, administradorUncheckedUpdateInput>
  }

  /**
   * administrador delete
   */
  export type administradorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter which administrador to delete.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador deleteMany
   */
  export type administradorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administradors to delete
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to delete.
     */
    limit?: number
  }

  /**
   * administrador.usuario
   */
  export type administrador$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * administrador without action
   */
  export type administradorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
  }


  /**
   * Model cita
   */

  export type AggregateCita = {
    _count: CitaCountAggregateOutputType | null
    _avg: CitaAvgAggregateOutputType | null
    _sum: CitaSumAggregateOutputType | null
    _min: CitaMinAggregateOutputType | null
    _max: CitaMaxAggregateOutputType | null
  }

  export type CitaAvgAggregateOutputType = {
    id_cita: number | null
    id_doctor: number | null
    id_paciente: number | null
  }

  export type CitaSumAggregateOutputType = {
    id_cita: number | null
    id_doctor: number | null
    id_paciente: number | null
  }

  export type CitaMinAggregateOutputType = {
    id_cita: number | null
    fecha: Date | null
    horainicio: Date | null
    horafin: Date | null
    estado: string | null
    motivo: string | null
    id_doctor: number | null
    id_paciente: number | null
    hora_llegada: Date | null
  }

  export type CitaMaxAggregateOutputType = {
    id_cita: number | null
    fecha: Date | null
    horainicio: Date | null
    horafin: Date | null
    estado: string | null
    motivo: string | null
    id_doctor: number | null
    id_paciente: number | null
    hora_llegada: Date | null
  }

  export type CitaCountAggregateOutputType = {
    id_cita: number
    fecha: number
    horainicio: number
    horafin: number
    estado: number
    motivo: number
    id_doctor: number
    id_paciente: number
    hora_llegada: number
    _all: number
  }


  export type CitaAvgAggregateInputType = {
    id_cita?: true
    id_doctor?: true
    id_paciente?: true
  }

  export type CitaSumAggregateInputType = {
    id_cita?: true
    id_doctor?: true
    id_paciente?: true
  }

  export type CitaMinAggregateInputType = {
    id_cita?: true
    fecha?: true
    horainicio?: true
    horafin?: true
    estado?: true
    motivo?: true
    id_doctor?: true
    id_paciente?: true
    hora_llegada?: true
  }

  export type CitaMaxAggregateInputType = {
    id_cita?: true
    fecha?: true
    horainicio?: true
    horafin?: true
    estado?: true
    motivo?: true
    id_doctor?: true
    id_paciente?: true
    hora_llegada?: true
  }

  export type CitaCountAggregateInputType = {
    id_cita?: true
    fecha?: true
    horainicio?: true
    horafin?: true
    estado?: true
    motivo?: true
    id_doctor?: true
    id_paciente?: true
    hora_llegada?: true
    _all?: true
  }

  export type CitaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cita to aggregate.
     */
    where?: citaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: citaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned citas
    **/
    _count?: true | CitaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitaMaxAggregateInputType
  }

  export type GetCitaAggregateType<T extends CitaAggregateArgs> = {
        [P in keyof T & keyof AggregateCita]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCita[P]>
      : GetScalarType<T[P], AggregateCita[P]>
  }




  export type citaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citaWhereInput
    orderBy?: citaOrderByWithAggregationInput | citaOrderByWithAggregationInput[]
    by: CitaScalarFieldEnum[] | CitaScalarFieldEnum
    having?: citaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitaCountAggregateInputType | true
    _avg?: CitaAvgAggregateInputType
    _sum?: CitaSumAggregateInputType
    _min?: CitaMinAggregateInputType
    _max?: CitaMaxAggregateInputType
  }

  export type CitaGroupByOutputType = {
    id_cita: number
    fecha: Date
    horainicio: Date | null
    horafin: Date | null
    estado: string | null
    motivo: string | null
    id_doctor: number | null
    id_paciente: number | null
    hora_llegada: Date | null
    _count: CitaCountAggregateOutputType | null
    _avg: CitaAvgAggregateOutputType | null
    _sum: CitaSumAggregateOutputType | null
    _min: CitaMinAggregateOutputType | null
    _max: CitaMaxAggregateOutputType | null
  }

  type GetCitaGroupByPayload<T extends citaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitaGroupByOutputType[P]>
            : GetScalarType<T[P], CitaGroupByOutputType[P]>
        }
      >
    >


  export type citaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    fecha?: boolean
    horainicio?: boolean
    horafin?: boolean
    estado?: boolean
    motivo?: boolean
    id_doctor?: boolean
    id_paciente?: boolean
    hora_llegada?: boolean
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
    consulta?: boolean | cita$consultaArgs<ExtArgs>
    _count?: boolean | CitaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type citaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    fecha?: boolean
    horainicio?: boolean
    horafin?: boolean
    estado?: boolean
    motivo?: boolean
    id_doctor?: boolean
    id_paciente?: boolean
    hora_llegada?: boolean
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type citaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    fecha?: boolean
    horainicio?: boolean
    horafin?: boolean
    estado?: boolean
    motivo?: boolean
    id_doctor?: boolean
    id_paciente?: boolean
    hora_llegada?: boolean
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type citaSelectScalar = {
    id_cita?: boolean
    fecha?: boolean
    horainicio?: boolean
    horafin?: boolean
    estado?: boolean
    motivo?: boolean
    id_doctor?: boolean
    id_paciente?: boolean
    hora_llegada?: boolean
  }

  export type citaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_cita" | "fecha" | "horainicio" | "horafin" | "estado" | "motivo" | "id_doctor" | "id_paciente" | "hora_llegada", ExtArgs["result"]["cita"]>
  export type citaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
    consulta?: boolean | cita$consultaArgs<ExtArgs>
    _count?: boolean | CitaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type citaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
  }
  export type citaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | cita$doctorArgs<ExtArgs>
    paciente?: boolean | cita$pacienteArgs<ExtArgs>
  }

  export type $citaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cita"
    objects: {
      doctor: Prisma.$doctorPayload<ExtArgs> | null
      paciente: Prisma.$pacientePayload<ExtArgs> | null
      consulta: Prisma.$consultaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_cita: number
      fecha: Date
      horainicio: Date | null
      horafin: Date | null
      estado: string | null
      motivo: string | null
      id_doctor: number | null
      id_paciente: number | null
      hora_llegada: Date | null
    }, ExtArgs["result"]["cita"]>
    composites: {}
  }

  type citaGetPayload<S extends boolean | null | undefined | citaDefaultArgs> = $Result.GetResult<Prisma.$citaPayload, S>

  type citaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<citaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitaCountAggregateInputType | true
    }

  export interface citaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cita'], meta: { name: 'cita' } }
    /**
     * Find zero or one Cita that matches the filter.
     * @param {citaFindUniqueArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends citaFindUniqueArgs>(args: SelectSubset<T, citaFindUniqueArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cita that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {citaFindUniqueOrThrowArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends citaFindUniqueOrThrowArgs>(args: SelectSubset<T, citaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cita that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaFindFirstArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends citaFindFirstArgs>(args?: SelectSubset<T, citaFindFirstArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cita that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaFindFirstOrThrowArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends citaFindFirstOrThrowArgs>(args?: SelectSubset<T, citaFindFirstOrThrowArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Citas
     * const citas = await prisma.cita.findMany()
     * 
     * // Get first 10 Citas
     * const citas = await prisma.cita.findMany({ take: 10 })
     * 
     * // Only select the `id_cita`
     * const citaWithId_citaOnly = await prisma.cita.findMany({ select: { id_cita: true } })
     * 
     */
    findMany<T extends citaFindManyArgs>(args?: SelectSubset<T, citaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cita.
     * @param {citaCreateArgs} args - Arguments to create a Cita.
     * @example
     * // Create one Cita
     * const Cita = await prisma.cita.create({
     *   data: {
     *     // ... data to create a Cita
     *   }
     * })
     * 
     */
    create<T extends citaCreateArgs>(args: SelectSubset<T, citaCreateArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Citas.
     * @param {citaCreateManyArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const cita = await prisma.cita.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends citaCreateManyArgs>(args?: SelectSubset<T, citaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Citas and returns the data saved in the database.
     * @param {citaCreateManyAndReturnArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const cita = await prisma.cita.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Citas and only return the `id_cita`
     * const citaWithId_citaOnly = await prisma.cita.createManyAndReturn({
     *   select: { id_cita: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends citaCreateManyAndReturnArgs>(args?: SelectSubset<T, citaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cita.
     * @param {citaDeleteArgs} args - Arguments to delete one Cita.
     * @example
     * // Delete one Cita
     * const Cita = await prisma.cita.delete({
     *   where: {
     *     // ... filter to delete one Cita
     *   }
     * })
     * 
     */
    delete<T extends citaDeleteArgs>(args: SelectSubset<T, citaDeleteArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cita.
     * @param {citaUpdateArgs} args - Arguments to update one Cita.
     * @example
     * // Update one Cita
     * const cita = await prisma.cita.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends citaUpdateArgs>(args: SelectSubset<T, citaUpdateArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Citas.
     * @param {citaDeleteManyArgs} args - Arguments to filter Citas to delete.
     * @example
     * // Delete a few Citas
     * const { count } = await prisma.cita.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends citaDeleteManyArgs>(args?: SelectSubset<T, citaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Citas
     * const cita = await prisma.cita.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends citaUpdateManyArgs>(args: SelectSubset<T, citaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas and returns the data updated in the database.
     * @param {citaUpdateManyAndReturnArgs} args - Arguments to update many Citas.
     * @example
     * // Update many Citas
     * const cita = await prisma.cita.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Citas and only return the `id_cita`
     * const citaWithId_citaOnly = await prisma.cita.updateManyAndReturn({
     *   select: { id_cita: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends citaUpdateManyAndReturnArgs>(args: SelectSubset<T, citaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cita.
     * @param {citaUpsertArgs} args - Arguments to update or create a Cita.
     * @example
     * // Update or create a Cita
     * const cita = await prisma.cita.upsert({
     *   create: {
     *     // ... data to create a Cita
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cita we want to update
     *   }
     * })
     */
    upsert<T extends citaUpsertArgs>(args: SelectSubset<T, citaUpsertArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaCountArgs} args - Arguments to filter Citas to count.
     * @example
     * // Count the number of Citas
     * const count = await prisma.cita.count({
     *   where: {
     *     // ... the filter for the Citas we want to count
     *   }
     * })
    **/
    count<T extends citaCountArgs>(
      args?: Subset<T, citaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitaAggregateArgs>(args: Subset<T, CitaAggregateArgs>): Prisma.PrismaPromise<GetCitaAggregateType<T>>

    /**
     * Group by Cita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends citaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: citaGroupByArgs['orderBy'] }
        : { orderBy?: citaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, citaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cita model
   */
  readonly fields: citaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cita.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__citaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends cita$doctorArgs<ExtArgs> = {}>(args?: Subset<T, cita$doctorArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paciente<T extends cita$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, cita$pacienteArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    consulta<T extends cita$consultaArgs<ExtArgs> = {}>(args?: Subset<T, cita$consultaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cita model
   */
  interface citaFieldRefs {
    readonly id_cita: FieldRef<"cita", 'Int'>
    readonly fecha: FieldRef<"cita", 'DateTime'>
    readonly horainicio: FieldRef<"cita", 'DateTime'>
    readonly horafin: FieldRef<"cita", 'DateTime'>
    readonly estado: FieldRef<"cita", 'String'>
    readonly motivo: FieldRef<"cita", 'String'>
    readonly id_doctor: FieldRef<"cita", 'Int'>
    readonly id_paciente: FieldRef<"cita", 'Int'>
    readonly hora_llegada: FieldRef<"cita", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cita findUnique
   */
  export type citaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter, which cita to fetch.
     */
    where: citaWhereUniqueInput
  }

  /**
   * cita findUniqueOrThrow
   */
  export type citaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter, which cita to fetch.
     */
    where: citaWhereUniqueInput
  }

  /**
   * cita findFirst
   */
  export type citaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter, which cita to fetch.
     */
    where?: citaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for citas.
     */
    cursor?: citaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of citas.
     */
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * cita findFirstOrThrow
   */
  export type citaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter, which cita to fetch.
     */
    where?: citaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for citas.
     */
    cursor?: citaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of citas.
     */
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * cita findMany
   */
  export type citaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where?: citaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing citas.
     */
    cursor?: citaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * cita create
   */
  export type citaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * The data needed to create a cita.
     */
    data: XOR<citaCreateInput, citaUncheckedCreateInput>
  }

  /**
   * cita createMany
   */
  export type citaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many citas.
     */
    data: citaCreateManyInput | citaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cita createManyAndReturn
   */
  export type citaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * The data used to create many citas.
     */
    data: citaCreateManyInput | citaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cita update
   */
  export type citaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * The data needed to update a cita.
     */
    data: XOR<citaUpdateInput, citaUncheckedUpdateInput>
    /**
     * Choose, which cita to update.
     */
    where: citaWhereUniqueInput
  }

  /**
   * cita updateMany
   */
  export type citaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update citas.
     */
    data: XOR<citaUpdateManyMutationInput, citaUncheckedUpdateManyInput>
    /**
     * Filter which citas to update
     */
    where?: citaWhereInput
    /**
     * Limit how many citas to update.
     */
    limit?: number
  }

  /**
   * cita updateManyAndReturn
   */
  export type citaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * The data used to update citas.
     */
    data: XOR<citaUpdateManyMutationInput, citaUncheckedUpdateManyInput>
    /**
     * Filter which citas to update
     */
    where?: citaWhereInput
    /**
     * Limit how many citas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cita upsert
   */
  export type citaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * The filter to search for the cita to update in case it exists.
     */
    where: citaWhereUniqueInput
    /**
     * In case the cita found by the `where` argument doesn't exist, create a new cita with this data.
     */
    create: XOR<citaCreateInput, citaUncheckedCreateInput>
    /**
     * In case the cita was found with the provided `where` argument, update it with this data.
     */
    update: XOR<citaUpdateInput, citaUncheckedUpdateInput>
  }

  /**
   * cita delete
   */
  export type citaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    /**
     * Filter which cita to delete.
     */
    where: citaWhereUniqueInput
  }

  /**
   * cita deleteMany
   */
  export type citaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which citas to delete
     */
    where?: citaWhereInput
    /**
     * Limit how many citas to delete.
     */
    limit?: number
  }

  /**
   * cita.doctor
   */
  export type cita$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    where?: doctorWhereInput
  }

  /**
   * cita.paciente
   */
  export type cita$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    where?: pacienteWhereInput
  }

  /**
   * cita.consulta
   */
  export type cita$consultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    where?: consultaWhereInput
    orderBy?: consultaOrderByWithRelationInput | consultaOrderByWithRelationInput[]
    cursor?: consultaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultaScalarFieldEnum | ConsultaScalarFieldEnum[]
  }

  /**
   * cita without action
   */
  export type citaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
  }


  /**
   * Model consulta
   */

  export type AggregateConsulta = {
    _count: ConsultaCountAggregateOutputType | null
    _avg: ConsultaAvgAggregateOutputType | null
    _sum: ConsultaSumAggregateOutputType | null
    _min: ConsultaMinAggregateOutputType | null
    _max: ConsultaMaxAggregateOutputType | null
  }

  export type ConsultaAvgAggregateOutputType = {
    id_consulta: number | null
    id_cita: number | null
  }

  export type ConsultaSumAggregateOutputType = {
    id_consulta: number | null
    id_cita: number | null
  }

  export type ConsultaMinAggregateOutputType = {
    id_consulta: number | null
    fecha: Date | null
    motivo: string | null
    id_cita: number | null
  }

  export type ConsultaMaxAggregateOutputType = {
    id_consulta: number | null
    fecha: Date | null
    motivo: string | null
    id_cita: number | null
  }

  export type ConsultaCountAggregateOutputType = {
    id_consulta: number
    fecha: number
    motivo: number
    id_cita: number
    _all: number
  }


  export type ConsultaAvgAggregateInputType = {
    id_consulta?: true
    id_cita?: true
  }

  export type ConsultaSumAggregateInputType = {
    id_consulta?: true
    id_cita?: true
  }

  export type ConsultaMinAggregateInputType = {
    id_consulta?: true
    fecha?: true
    motivo?: true
    id_cita?: true
  }

  export type ConsultaMaxAggregateInputType = {
    id_consulta?: true
    fecha?: true
    motivo?: true
    id_cita?: true
  }

  export type ConsultaCountAggregateInputType = {
    id_consulta?: true
    fecha?: true
    motivo?: true
    id_cita?: true
    _all?: true
  }

  export type ConsultaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta to aggregate.
     */
    where?: consultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultaOrderByWithRelationInput | consultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultas
    **/
    _count?: true | ConsultaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultaMaxAggregateInputType
  }

  export type GetConsultaAggregateType<T extends ConsultaAggregateArgs> = {
        [P in keyof T & keyof AggregateConsulta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsulta[P]>
      : GetScalarType<T[P], AggregateConsulta[P]>
  }




  export type consultaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultaWhereInput
    orderBy?: consultaOrderByWithAggregationInput | consultaOrderByWithAggregationInput[]
    by: ConsultaScalarFieldEnum[] | ConsultaScalarFieldEnum
    having?: consultaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultaCountAggregateInputType | true
    _avg?: ConsultaAvgAggregateInputType
    _sum?: ConsultaSumAggregateInputType
    _min?: ConsultaMinAggregateInputType
    _max?: ConsultaMaxAggregateInputType
  }

  export type ConsultaGroupByOutputType = {
    id_consulta: number
    fecha: Date | null
    motivo: string | null
    id_cita: number | null
    _count: ConsultaCountAggregateOutputType | null
    _avg: ConsultaAvgAggregateOutputType | null
    _sum: ConsultaSumAggregateOutputType | null
    _min: ConsultaMinAggregateOutputType | null
    _max: ConsultaMaxAggregateOutputType | null
  }

  type GetConsultaGroupByPayload<T extends consultaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultaGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultaGroupByOutputType[P]>
        }
      >
    >


  export type consultaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta?: boolean
    fecha?: boolean
    motivo?: boolean
    id_cita?: boolean
    cita?: boolean | consulta$citaArgs<ExtArgs>
    diagnostico?: boolean | consulta$diagnosticoArgs<ExtArgs>
    _count?: boolean | ConsultaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consulta"]>

  export type consultaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta?: boolean
    fecha?: boolean
    motivo?: boolean
    id_cita?: boolean
    cita?: boolean | consulta$citaArgs<ExtArgs>
  }, ExtArgs["result"]["consulta"]>

  export type consultaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta?: boolean
    fecha?: boolean
    motivo?: boolean
    id_cita?: boolean
    cita?: boolean | consulta$citaArgs<ExtArgs>
  }, ExtArgs["result"]["consulta"]>

  export type consultaSelectScalar = {
    id_consulta?: boolean
    fecha?: boolean
    motivo?: boolean
    id_cita?: boolean
  }

  export type consultaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_consulta" | "fecha" | "motivo" | "id_cita", ExtArgs["result"]["consulta"]>
  export type consultaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | consulta$citaArgs<ExtArgs>
    diagnostico?: boolean | consulta$diagnosticoArgs<ExtArgs>
    _count?: boolean | ConsultaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type consultaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | consulta$citaArgs<ExtArgs>
  }
  export type consultaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | consulta$citaArgs<ExtArgs>
  }

  export type $consultaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consulta"
    objects: {
      cita: Prisma.$citaPayload<ExtArgs> | null
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_consulta: number
      fecha: Date | null
      motivo: string | null
      id_cita: number | null
    }, ExtArgs["result"]["consulta"]>
    composites: {}
  }

  type consultaGetPayload<S extends boolean | null | undefined | consultaDefaultArgs> = $Result.GetResult<Prisma.$consultaPayload, S>

  type consultaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consultaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultaCountAggregateInputType | true
    }

  export interface consultaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consulta'], meta: { name: 'consulta' } }
    /**
     * Find zero or one Consulta that matches the filter.
     * @param {consultaFindUniqueArgs} args - Arguments to find a Consulta
     * @example
     * // Get one Consulta
     * const consulta = await prisma.consulta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultaFindUniqueArgs>(args: SelectSubset<T, consultaFindUniqueArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consulta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consultaFindUniqueOrThrowArgs} args - Arguments to find a Consulta
     * @example
     * // Get one Consulta
     * const consulta = await prisma.consulta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultaFindUniqueOrThrowArgs>(args: SelectSubset<T, consultaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaFindFirstArgs} args - Arguments to find a Consulta
     * @example
     * // Get one Consulta
     * const consulta = await prisma.consulta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultaFindFirstArgs>(args?: SelectSubset<T, consultaFindFirstArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaFindFirstOrThrowArgs} args - Arguments to find a Consulta
     * @example
     * // Get one Consulta
     * const consulta = await prisma.consulta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultaFindFirstOrThrowArgs>(args?: SelectSubset<T, consultaFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultas
     * const consultas = await prisma.consulta.findMany()
     * 
     * // Get first 10 Consultas
     * const consultas = await prisma.consulta.findMany({ take: 10 })
     * 
     * // Only select the `id_consulta`
     * const consultaWithId_consultaOnly = await prisma.consulta.findMany({ select: { id_consulta: true } })
     * 
     */
    findMany<T extends consultaFindManyArgs>(args?: SelectSubset<T, consultaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consulta.
     * @param {consultaCreateArgs} args - Arguments to create a Consulta.
     * @example
     * // Create one Consulta
     * const Consulta = await prisma.consulta.create({
     *   data: {
     *     // ... data to create a Consulta
     *   }
     * })
     * 
     */
    create<T extends consultaCreateArgs>(args: SelectSubset<T, consultaCreateArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultas.
     * @param {consultaCreateManyArgs} args - Arguments to create many Consultas.
     * @example
     * // Create many Consultas
     * const consulta = await prisma.consulta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultaCreateManyArgs>(args?: SelectSubset<T, consultaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultas and returns the data saved in the database.
     * @param {consultaCreateManyAndReturnArgs} args - Arguments to create many Consultas.
     * @example
     * // Create many Consultas
     * const consulta = await prisma.consulta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultas and only return the `id_consulta`
     * const consultaWithId_consultaOnly = await prisma.consulta.createManyAndReturn({
     *   select: { id_consulta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consultaCreateManyAndReturnArgs>(args?: SelectSubset<T, consultaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consulta.
     * @param {consultaDeleteArgs} args - Arguments to delete one Consulta.
     * @example
     * // Delete one Consulta
     * const Consulta = await prisma.consulta.delete({
     *   where: {
     *     // ... filter to delete one Consulta
     *   }
     * })
     * 
     */
    delete<T extends consultaDeleteArgs>(args: SelectSubset<T, consultaDeleteArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consulta.
     * @param {consultaUpdateArgs} args - Arguments to update one Consulta.
     * @example
     * // Update one Consulta
     * const consulta = await prisma.consulta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultaUpdateArgs>(args: SelectSubset<T, consultaUpdateArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultas.
     * @param {consultaDeleteManyArgs} args - Arguments to filter Consultas to delete.
     * @example
     * // Delete a few Consultas
     * const { count } = await prisma.consulta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultaDeleteManyArgs>(args?: SelectSubset<T, consultaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultas
     * const consulta = await prisma.consulta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultaUpdateManyArgs>(args: SelectSubset<T, consultaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultas and returns the data updated in the database.
     * @param {consultaUpdateManyAndReturnArgs} args - Arguments to update many Consultas.
     * @example
     * // Update many Consultas
     * const consulta = await prisma.consulta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consultas and only return the `id_consulta`
     * const consultaWithId_consultaOnly = await prisma.consulta.updateManyAndReturn({
     *   select: { id_consulta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consultaUpdateManyAndReturnArgs>(args: SelectSubset<T, consultaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consulta.
     * @param {consultaUpsertArgs} args - Arguments to update or create a Consulta.
     * @example
     * // Update or create a Consulta
     * const consulta = await prisma.consulta.upsert({
     *   create: {
     *     // ... data to create a Consulta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consulta we want to update
     *   }
     * })
     */
    upsert<T extends consultaUpsertArgs>(args: SelectSubset<T, consultaUpsertArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaCountArgs} args - Arguments to filter Consultas to count.
     * @example
     * // Count the number of Consultas
     * const count = await prisma.consulta.count({
     *   where: {
     *     // ... the filter for the Consultas we want to count
     *   }
     * })
    **/
    count<T extends consultaCountArgs>(
      args?: Subset<T, consultaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consulta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultaAggregateArgs>(args: Subset<T, ConsultaAggregateArgs>): Prisma.PrismaPromise<GetConsultaAggregateType<T>>

    /**
     * Group by Consulta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultaGroupByArgs['orderBy'] }
        : { orderBy?: consultaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consulta model
   */
  readonly fields: consultaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consulta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cita<T extends consulta$citaArgs<ExtArgs> = {}>(args?: Subset<T, consulta$citaArgs<ExtArgs>>): Prisma__citaClient<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    diagnostico<T extends consulta$diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, consulta$diagnosticoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consulta model
   */
  interface consultaFieldRefs {
    readonly id_consulta: FieldRef<"consulta", 'Int'>
    readonly fecha: FieldRef<"consulta", 'DateTime'>
    readonly motivo: FieldRef<"consulta", 'String'>
    readonly id_cita: FieldRef<"consulta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * consulta findUnique
   */
  export type consultaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter, which consulta to fetch.
     */
    where: consultaWhereUniqueInput
  }

  /**
   * consulta findUniqueOrThrow
   */
  export type consultaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter, which consulta to fetch.
     */
    where: consultaWhereUniqueInput
  }

  /**
   * consulta findFirst
   */
  export type consultaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter, which consulta to fetch.
     */
    where?: consultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultaOrderByWithRelationInput | consultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultaScalarFieldEnum | ConsultaScalarFieldEnum[]
  }

  /**
   * consulta findFirstOrThrow
   */
  export type consultaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter, which consulta to fetch.
     */
    where?: consultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultaOrderByWithRelationInput | consultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultaScalarFieldEnum | ConsultaScalarFieldEnum[]
  }

  /**
   * consulta findMany
   */
  export type consultaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultaOrderByWithRelationInput | consultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultas.
     */
    cursor?: consultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    distinct?: ConsultaScalarFieldEnum | ConsultaScalarFieldEnum[]
  }

  /**
   * consulta create
   */
  export type consultaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * The data needed to create a consulta.
     */
    data?: XOR<consultaCreateInput, consultaUncheckedCreateInput>
  }

  /**
   * consulta createMany
   */
  export type consultaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultas.
     */
    data: consultaCreateManyInput | consultaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta createManyAndReturn
   */
  export type consultaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * The data used to create many consultas.
     */
    data: consultaCreateManyInput | consultaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * consulta update
   */
  export type consultaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * The data needed to update a consulta.
     */
    data: XOR<consultaUpdateInput, consultaUncheckedUpdateInput>
    /**
     * Choose, which consulta to update.
     */
    where: consultaWhereUniqueInput
  }

  /**
   * consulta updateMany
   */
  export type consultaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultas.
     */
    data: XOR<consultaUpdateManyMutationInput, consultaUncheckedUpdateManyInput>
    /**
     * Filter which consultas to update
     */
    where?: consultaWhereInput
    /**
     * Limit how many consultas to update.
     */
    limit?: number
  }

  /**
   * consulta updateManyAndReturn
   */
  export type consultaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * The data used to update consultas.
     */
    data: XOR<consultaUpdateManyMutationInput, consultaUncheckedUpdateManyInput>
    /**
     * Filter which consultas to update
     */
    where?: consultaWhereInput
    /**
     * Limit how many consultas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * consulta upsert
   */
  export type consultaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * The filter to search for the consulta to update in case it exists.
     */
    where: consultaWhereUniqueInput
    /**
     * In case the consulta found by the `where` argument doesn't exist, create a new consulta with this data.
     */
    create: XOR<consultaCreateInput, consultaUncheckedCreateInput>
    /**
     * In case the consulta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultaUpdateInput, consultaUncheckedUpdateInput>
  }

  /**
   * consulta delete
   */
  export type consultaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    /**
     * Filter which consulta to delete.
     */
    where: consultaWhereUniqueInput
  }

  /**
   * consulta deleteMany
   */
  export type consultaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultas to delete
     */
    where?: consultaWhereInput
    /**
     * Limit how many consultas to delete.
     */
    limit?: number
  }

  /**
   * consulta.cita
   */
  export type consulta$citaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    where?: citaWhereInput
  }

  /**
   * consulta.diagnostico
   */
  export type consulta$diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    where?: diagnosticoWhereInput
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    cursor?: diagnosticoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * consulta without action
   */
  export type consultaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
  }


  /**
   * Model detallepago
   */

  export type AggregateDetallepago = {
    _count: DetallepagoCountAggregateOutputType | null
    _avg: DetallepagoAvgAggregateOutputType | null
    _sum: DetallepagoSumAggregateOutputType | null
    _min: DetallepagoMinAggregateOutputType | null
    _max: DetallepagoMaxAggregateOutputType | null
  }

  export type DetallepagoAvgAggregateOutputType = {
    id_detalle_pago: number | null
    id_transaccionpp: number | null
  }

  export type DetallepagoSumAggregateOutputType = {
    id_detalle_pago: number | null
    id_transaccionpp: number | null
  }

  export type DetallepagoMinAggregateOutputType = {
    id_detalle_pago: number | null
    fechapago: Date | null
    id_transaccionpp: number | null
  }

  export type DetallepagoMaxAggregateOutputType = {
    id_detalle_pago: number | null
    fechapago: Date | null
    id_transaccionpp: number | null
  }

  export type DetallepagoCountAggregateOutputType = {
    id_detalle_pago: number
    fechapago: number
    id_transaccionpp: number
    _all: number
  }


  export type DetallepagoAvgAggregateInputType = {
    id_detalle_pago?: true
    id_transaccionpp?: true
  }

  export type DetallepagoSumAggregateInputType = {
    id_detalle_pago?: true
    id_transaccionpp?: true
  }

  export type DetallepagoMinAggregateInputType = {
    id_detalle_pago?: true
    fechapago?: true
    id_transaccionpp?: true
  }

  export type DetallepagoMaxAggregateInputType = {
    id_detalle_pago?: true
    fechapago?: true
    id_transaccionpp?: true
  }

  export type DetallepagoCountAggregateInputType = {
    id_detalle_pago?: true
    fechapago?: true
    id_transaccionpp?: true
    _all?: true
  }

  export type DetallepagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detallepago to aggregate.
     */
    where?: detallepagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detallepagos to fetch.
     */
    orderBy?: detallepagoOrderByWithRelationInput | detallepagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detallepagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detallepagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detallepagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detallepagos
    **/
    _count?: true | DetallepagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetallepagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetallepagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetallepagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetallepagoMaxAggregateInputType
  }

  export type GetDetallepagoAggregateType<T extends DetallepagoAggregateArgs> = {
        [P in keyof T & keyof AggregateDetallepago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetallepago[P]>
      : GetScalarType<T[P], AggregateDetallepago[P]>
  }




  export type detallepagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detallepagoWhereInput
    orderBy?: detallepagoOrderByWithAggregationInput | detallepagoOrderByWithAggregationInput[]
    by: DetallepagoScalarFieldEnum[] | DetallepagoScalarFieldEnum
    having?: detallepagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetallepagoCountAggregateInputType | true
    _avg?: DetallepagoAvgAggregateInputType
    _sum?: DetallepagoSumAggregateInputType
    _min?: DetallepagoMinAggregateInputType
    _max?: DetallepagoMaxAggregateInputType
  }

  export type DetallepagoGroupByOutputType = {
    id_detalle_pago: number
    fechapago: Date | null
    id_transaccionpp: number | null
    _count: DetallepagoCountAggregateOutputType | null
    _avg: DetallepagoAvgAggregateOutputType | null
    _sum: DetallepagoSumAggregateOutputType | null
    _min: DetallepagoMinAggregateOutputType | null
    _max: DetallepagoMaxAggregateOutputType | null
  }

  type GetDetallepagoGroupByPayload<T extends detallepagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetallepagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetallepagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetallepagoGroupByOutputType[P]>
            : GetScalarType<T[P], DetallepagoGroupByOutputType[P]>
        }
      >
    >


  export type detallepagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle_pago?: boolean
    fechapago?: boolean
    id_transaccionpp?: boolean
  }, ExtArgs["result"]["detallepago"]>

  export type detallepagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle_pago?: boolean
    fechapago?: boolean
    id_transaccionpp?: boolean
  }, ExtArgs["result"]["detallepago"]>

  export type detallepagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle_pago?: boolean
    fechapago?: boolean
    id_transaccionpp?: boolean
  }, ExtArgs["result"]["detallepago"]>

  export type detallepagoSelectScalar = {
    id_detalle_pago?: boolean
    fechapago?: boolean
    id_transaccionpp?: boolean
  }

  export type detallepagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_detalle_pago" | "fechapago" | "id_transaccionpp", ExtArgs["result"]["detallepago"]>

  export type $detallepagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detallepago"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_detalle_pago: number
      fechapago: Date | null
      id_transaccionpp: number | null
    }, ExtArgs["result"]["detallepago"]>
    composites: {}
  }

  type detallepagoGetPayload<S extends boolean | null | undefined | detallepagoDefaultArgs> = $Result.GetResult<Prisma.$detallepagoPayload, S>

  type detallepagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<detallepagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetallepagoCountAggregateInputType | true
    }

  export interface detallepagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detallepago'], meta: { name: 'detallepago' } }
    /**
     * Find zero or one Detallepago that matches the filter.
     * @param {detallepagoFindUniqueArgs} args - Arguments to find a Detallepago
     * @example
     * // Get one Detallepago
     * const detallepago = await prisma.detallepago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detallepagoFindUniqueArgs>(args: SelectSubset<T, detallepagoFindUniqueArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Detallepago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {detallepagoFindUniqueOrThrowArgs} args - Arguments to find a Detallepago
     * @example
     * // Get one Detallepago
     * const detallepago = await prisma.detallepago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detallepagoFindUniqueOrThrowArgs>(args: SelectSubset<T, detallepagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detallepago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoFindFirstArgs} args - Arguments to find a Detallepago
     * @example
     * // Get one Detallepago
     * const detallepago = await prisma.detallepago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detallepagoFindFirstArgs>(args?: SelectSubset<T, detallepagoFindFirstArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detallepago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoFindFirstOrThrowArgs} args - Arguments to find a Detallepago
     * @example
     * // Get one Detallepago
     * const detallepago = await prisma.detallepago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detallepagoFindFirstOrThrowArgs>(args?: SelectSubset<T, detallepagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Detallepagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detallepagos
     * const detallepagos = await prisma.detallepago.findMany()
     * 
     * // Get first 10 Detallepagos
     * const detallepagos = await prisma.detallepago.findMany({ take: 10 })
     * 
     * // Only select the `id_detalle_pago`
     * const detallepagoWithId_detalle_pagoOnly = await prisma.detallepago.findMany({ select: { id_detalle_pago: true } })
     * 
     */
    findMany<T extends detallepagoFindManyArgs>(args?: SelectSubset<T, detallepagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Detallepago.
     * @param {detallepagoCreateArgs} args - Arguments to create a Detallepago.
     * @example
     * // Create one Detallepago
     * const Detallepago = await prisma.detallepago.create({
     *   data: {
     *     // ... data to create a Detallepago
     *   }
     * })
     * 
     */
    create<T extends detallepagoCreateArgs>(args: SelectSubset<T, detallepagoCreateArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Detallepagos.
     * @param {detallepagoCreateManyArgs} args - Arguments to create many Detallepagos.
     * @example
     * // Create many Detallepagos
     * const detallepago = await prisma.detallepago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detallepagoCreateManyArgs>(args?: SelectSubset<T, detallepagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detallepagos and returns the data saved in the database.
     * @param {detallepagoCreateManyAndReturnArgs} args - Arguments to create many Detallepagos.
     * @example
     * // Create many Detallepagos
     * const detallepago = await prisma.detallepago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detallepagos and only return the `id_detalle_pago`
     * const detallepagoWithId_detalle_pagoOnly = await prisma.detallepago.createManyAndReturn({
     *   select: { id_detalle_pago: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends detallepagoCreateManyAndReturnArgs>(args?: SelectSubset<T, detallepagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Detallepago.
     * @param {detallepagoDeleteArgs} args - Arguments to delete one Detallepago.
     * @example
     * // Delete one Detallepago
     * const Detallepago = await prisma.detallepago.delete({
     *   where: {
     *     // ... filter to delete one Detallepago
     *   }
     * })
     * 
     */
    delete<T extends detallepagoDeleteArgs>(args: SelectSubset<T, detallepagoDeleteArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Detallepago.
     * @param {detallepagoUpdateArgs} args - Arguments to update one Detallepago.
     * @example
     * // Update one Detallepago
     * const detallepago = await prisma.detallepago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detallepagoUpdateArgs>(args: SelectSubset<T, detallepagoUpdateArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Detallepagos.
     * @param {detallepagoDeleteManyArgs} args - Arguments to filter Detallepagos to delete.
     * @example
     * // Delete a few Detallepagos
     * const { count } = await prisma.detallepago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detallepagoDeleteManyArgs>(args?: SelectSubset<T, detallepagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detallepagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detallepagos
     * const detallepago = await prisma.detallepago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detallepagoUpdateManyArgs>(args: SelectSubset<T, detallepagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detallepagos and returns the data updated in the database.
     * @param {detallepagoUpdateManyAndReturnArgs} args - Arguments to update many Detallepagos.
     * @example
     * // Update many Detallepagos
     * const detallepago = await prisma.detallepago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Detallepagos and only return the `id_detalle_pago`
     * const detallepagoWithId_detalle_pagoOnly = await prisma.detallepago.updateManyAndReturn({
     *   select: { id_detalle_pago: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends detallepagoUpdateManyAndReturnArgs>(args: SelectSubset<T, detallepagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Detallepago.
     * @param {detallepagoUpsertArgs} args - Arguments to update or create a Detallepago.
     * @example
     * // Update or create a Detallepago
     * const detallepago = await prisma.detallepago.upsert({
     *   create: {
     *     // ... data to create a Detallepago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detallepago we want to update
     *   }
     * })
     */
    upsert<T extends detallepagoUpsertArgs>(args: SelectSubset<T, detallepagoUpsertArgs<ExtArgs>>): Prisma__detallepagoClient<$Result.GetResult<Prisma.$detallepagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Detallepagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoCountArgs} args - Arguments to filter Detallepagos to count.
     * @example
     * // Count the number of Detallepagos
     * const count = await prisma.detallepago.count({
     *   where: {
     *     // ... the filter for the Detallepagos we want to count
     *   }
     * })
    **/
    count<T extends detallepagoCountArgs>(
      args?: Subset<T, detallepagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetallepagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detallepago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallepagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetallepagoAggregateArgs>(args: Subset<T, DetallepagoAggregateArgs>): Prisma.PrismaPromise<GetDetallepagoAggregateType<T>>

    /**
     * Group by Detallepago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detallepagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detallepagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detallepagoGroupByArgs['orderBy'] }
        : { orderBy?: detallepagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detallepagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetallepagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detallepago model
   */
  readonly fields: detallepagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detallepago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detallepagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detallepago model
   */
  interface detallepagoFieldRefs {
    readonly id_detalle_pago: FieldRef<"detallepago", 'Int'>
    readonly fechapago: FieldRef<"detallepago", 'DateTime'>
    readonly id_transaccionpp: FieldRef<"detallepago", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * detallepago findUnique
   */
  export type detallepagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter, which detallepago to fetch.
     */
    where: detallepagoWhereUniqueInput
  }

  /**
   * detallepago findUniqueOrThrow
   */
  export type detallepagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter, which detallepago to fetch.
     */
    where: detallepagoWhereUniqueInput
  }

  /**
   * detallepago findFirst
   */
  export type detallepagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter, which detallepago to fetch.
     */
    where?: detallepagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detallepagos to fetch.
     */
    orderBy?: detallepagoOrderByWithRelationInput | detallepagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detallepagos.
     */
    cursor?: detallepagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detallepagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detallepagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detallepagos.
     */
    distinct?: DetallepagoScalarFieldEnum | DetallepagoScalarFieldEnum[]
  }

  /**
   * detallepago findFirstOrThrow
   */
  export type detallepagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter, which detallepago to fetch.
     */
    where?: detallepagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detallepagos to fetch.
     */
    orderBy?: detallepagoOrderByWithRelationInput | detallepagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detallepagos.
     */
    cursor?: detallepagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detallepagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detallepagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detallepagos.
     */
    distinct?: DetallepagoScalarFieldEnum | DetallepagoScalarFieldEnum[]
  }

  /**
   * detallepago findMany
   */
  export type detallepagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter, which detallepagos to fetch.
     */
    where?: detallepagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detallepagos to fetch.
     */
    orderBy?: detallepagoOrderByWithRelationInput | detallepagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detallepagos.
     */
    cursor?: detallepagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detallepagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detallepagos.
     */
    skip?: number
    distinct?: DetallepagoScalarFieldEnum | DetallepagoScalarFieldEnum[]
  }

  /**
   * detallepago create
   */
  export type detallepagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * The data needed to create a detallepago.
     */
    data?: XOR<detallepagoCreateInput, detallepagoUncheckedCreateInput>
  }

  /**
   * detallepago createMany
   */
  export type detallepagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detallepagos.
     */
    data: detallepagoCreateManyInput | detallepagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detallepago createManyAndReturn
   */
  export type detallepagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * The data used to create many detallepagos.
     */
    data: detallepagoCreateManyInput | detallepagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detallepago update
   */
  export type detallepagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * The data needed to update a detallepago.
     */
    data: XOR<detallepagoUpdateInput, detallepagoUncheckedUpdateInput>
    /**
     * Choose, which detallepago to update.
     */
    where: detallepagoWhereUniqueInput
  }

  /**
   * detallepago updateMany
   */
  export type detallepagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detallepagos.
     */
    data: XOR<detallepagoUpdateManyMutationInput, detallepagoUncheckedUpdateManyInput>
    /**
     * Filter which detallepagos to update
     */
    where?: detallepagoWhereInput
    /**
     * Limit how many detallepagos to update.
     */
    limit?: number
  }

  /**
   * detallepago updateManyAndReturn
   */
  export type detallepagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * The data used to update detallepagos.
     */
    data: XOR<detallepagoUpdateManyMutationInput, detallepagoUncheckedUpdateManyInput>
    /**
     * Filter which detallepagos to update
     */
    where?: detallepagoWhereInput
    /**
     * Limit how many detallepagos to update.
     */
    limit?: number
  }

  /**
   * detallepago upsert
   */
  export type detallepagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * The filter to search for the detallepago to update in case it exists.
     */
    where: detallepagoWhereUniqueInput
    /**
     * In case the detallepago found by the `where` argument doesn't exist, create a new detallepago with this data.
     */
    create: XOR<detallepagoCreateInput, detallepagoUncheckedCreateInput>
    /**
     * In case the detallepago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detallepagoUpdateInput, detallepagoUncheckedUpdateInput>
  }

  /**
   * detallepago delete
   */
  export type detallepagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
    /**
     * Filter which detallepago to delete.
     */
    where: detallepagoWhereUniqueInput
  }

  /**
   * detallepago deleteMany
   */
  export type detallepagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detallepagos to delete
     */
    where?: detallepagoWhereInput
    /**
     * Limit how many detallepagos to delete.
     */
    limit?: number
  }

  /**
   * detallepago without action
   */
  export type detallepagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detallepago
     */
    select?: detallepagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detallepago
     */
    omit?: detallepagoOmit<ExtArgs> | null
  }


  /**
   * Model diagnostico
   */

  export type AggregateDiagnostico = {
    _count: DiagnosticoCountAggregateOutputType | null
    _avg: DiagnosticoAvgAggregateOutputType | null
    _sum: DiagnosticoSumAggregateOutputType | null
    _min: DiagnosticoMinAggregateOutputType | null
    _max: DiagnosticoMaxAggregateOutputType | null
  }

  export type DiagnosticoAvgAggregateOutputType = {
    id_diagnostico: number | null
    id_consulta: number | null
  }

  export type DiagnosticoSumAggregateOutputType = {
    id_diagnostico: number | null
    id_consulta: number | null
  }

  export type DiagnosticoMinAggregateOutputType = {
    id_diagnostico: number | null
    nombrediagnostico: string | null
    descripcion: string | null
    id_consulta: number | null
  }

  export type DiagnosticoMaxAggregateOutputType = {
    id_diagnostico: number | null
    nombrediagnostico: string | null
    descripcion: string | null
    id_consulta: number | null
  }

  export type DiagnosticoCountAggregateOutputType = {
    id_diagnostico: number
    nombrediagnostico: number
    descripcion: number
    id_consulta: number
    _all: number
  }


  export type DiagnosticoAvgAggregateInputType = {
    id_diagnostico?: true
    id_consulta?: true
  }

  export type DiagnosticoSumAggregateInputType = {
    id_diagnostico?: true
    id_consulta?: true
  }

  export type DiagnosticoMinAggregateInputType = {
    id_diagnostico?: true
    nombrediagnostico?: true
    descripcion?: true
    id_consulta?: true
  }

  export type DiagnosticoMaxAggregateInputType = {
    id_diagnostico?: true
    nombrediagnostico?: true
    descripcion?: true
    id_consulta?: true
  }

  export type DiagnosticoCountAggregateInputType = {
    id_diagnostico?: true
    nombrediagnostico?: true
    descripcion?: true
    id_consulta?: true
    _all?: true
  }

  export type DiagnosticoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnostico to aggregate.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diagnosticos
    **/
    _count?: true | DiagnosticoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosticoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosticoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosticoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosticoMaxAggregateInputType
  }

  export type GetDiagnosticoAggregateType<T extends DiagnosticoAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnostico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnostico[P]>
      : GetScalarType<T[P], AggregateDiagnostico[P]>
  }




  export type diagnosticoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosticoWhereInput
    orderBy?: diagnosticoOrderByWithAggregationInput | diagnosticoOrderByWithAggregationInput[]
    by: DiagnosticoScalarFieldEnum[] | DiagnosticoScalarFieldEnum
    having?: diagnosticoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosticoCountAggregateInputType | true
    _avg?: DiagnosticoAvgAggregateInputType
    _sum?: DiagnosticoSumAggregateInputType
    _min?: DiagnosticoMinAggregateInputType
    _max?: DiagnosticoMaxAggregateInputType
  }

  export type DiagnosticoGroupByOutputType = {
    id_diagnostico: number
    nombrediagnostico: string | null
    descripcion: string | null
    id_consulta: number | null
    _count: DiagnosticoCountAggregateOutputType | null
    _avg: DiagnosticoAvgAggregateOutputType | null
    _sum: DiagnosticoSumAggregateOutputType | null
    _min: DiagnosticoMinAggregateOutputType | null
    _max: DiagnosticoMaxAggregateOutputType | null
  }

  type GetDiagnosticoGroupByPayload<T extends diagnosticoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosticoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosticoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosticoGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosticoGroupByOutputType[P]>
        }
      >
    >


  export type diagnosticoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_diagnostico?: boolean
    nombrediagnostico?: boolean
    descripcion?: boolean
    id_consulta?: boolean
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
    tratamiento?: boolean | diagnostico$tratamientoArgs<ExtArgs>
    _count?: boolean | DiagnosticoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_diagnostico?: boolean
    nombrediagnostico?: boolean
    descripcion?: boolean
    id_consulta?: boolean
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_diagnostico?: boolean
    nombrediagnostico?: boolean
    descripcion?: boolean
    id_consulta?: boolean
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectScalar = {
    id_diagnostico?: boolean
    nombrediagnostico?: boolean
    descripcion?: boolean
    id_consulta?: boolean
  }

  export type diagnosticoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_diagnostico" | "nombrediagnostico" | "descripcion" | "id_consulta", ExtArgs["result"]["diagnostico"]>
  export type diagnosticoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
    tratamiento?: boolean | diagnostico$tratamientoArgs<ExtArgs>
    _count?: boolean | DiagnosticoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type diagnosticoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
  }
  export type diagnosticoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consulta?: boolean | diagnostico$consultaArgs<ExtArgs>
  }

  export type $diagnosticoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diagnostico"
    objects: {
      consulta: Prisma.$consultaPayload<ExtArgs> | null
      tratamiento: Prisma.$tratamientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_diagnostico: number
      nombrediagnostico: string | null
      descripcion: string | null
      id_consulta: number | null
    }, ExtArgs["result"]["diagnostico"]>
    composites: {}
  }

  type diagnosticoGetPayload<S extends boolean | null | undefined | diagnosticoDefaultArgs> = $Result.GetResult<Prisma.$diagnosticoPayload, S>

  type diagnosticoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<diagnosticoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiagnosticoCountAggregateInputType | true
    }

  export interface diagnosticoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diagnostico'], meta: { name: 'diagnostico' } }
    /**
     * Find zero or one Diagnostico that matches the filter.
     * @param {diagnosticoFindUniqueArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends diagnosticoFindUniqueArgs>(args: SelectSubset<T, diagnosticoFindUniqueArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diagnostico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {diagnosticoFindUniqueOrThrowArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends diagnosticoFindUniqueOrThrowArgs>(args: SelectSubset<T, diagnosticoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindFirstArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends diagnosticoFindFirstArgs>(args?: SelectSubset<T, diagnosticoFindFirstArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindFirstOrThrowArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends diagnosticoFindFirstOrThrowArgs>(args?: SelectSubset<T, diagnosticoFindFirstOrThrowArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diagnosticos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnosticos
     * const diagnosticos = await prisma.diagnostico.findMany()
     * 
     * // Get first 10 Diagnosticos
     * const diagnosticos = await prisma.diagnostico.findMany({ take: 10 })
     * 
     * // Only select the `id_diagnostico`
     * const diagnosticoWithId_diagnosticoOnly = await prisma.diagnostico.findMany({ select: { id_diagnostico: true } })
     * 
     */
    findMany<T extends diagnosticoFindManyArgs>(args?: SelectSubset<T, diagnosticoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diagnostico.
     * @param {diagnosticoCreateArgs} args - Arguments to create a Diagnostico.
     * @example
     * // Create one Diagnostico
     * const Diagnostico = await prisma.diagnostico.create({
     *   data: {
     *     // ... data to create a Diagnostico
     *   }
     * })
     * 
     */
    create<T extends diagnosticoCreateArgs>(args: SelectSubset<T, diagnosticoCreateArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diagnosticos.
     * @param {diagnosticoCreateManyArgs} args - Arguments to create many Diagnosticos.
     * @example
     * // Create many Diagnosticos
     * const diagnostico = await prisma.diagnostico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends diagnosticoCreateManyArgs>(args?: SelectSubset<T, diagnosticoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnosticos and returns the data saved in the database.
     * @param {diagnosticoCreateManyAndReturnArgs} args - Arguments to create many Diagnosticos.
     * @example
     * // Create many Diagnosticos
     * const diagnostico = await prisma.diagnostico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnosticos and only return the `id_diagnostico`
     * const diagnosticoWithId_diagnosticoOnly = await prisma.diagnostico.createManyAndReturn({
     *   select: { id_diagnostico: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends diagnosticoCreateManyAndReturnArgs>(args?: SelectSubset<T, diagnosticoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diagnostico.
     * @param {diagnosticoDeleteArgs} args - Arguments to delete one Diagnostico.
     * @example
     * // Delete one Diagnostico
     * const Diagnostico = await prisma.diagnostico.delete({
     *   where: {
     *     // ... filter to delete one Diagnostico
     *   }
     * })
     * 
     */
    delete<T extends diagnosticoDeleteArgs>(args: SelectSubset<T, diagnosticoDeleteArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diagnostico.
     * @param {diagnosticoUpdateArgs} args - Arguments to update one Diagnostico.
     * @example
     * // Update one Diagnostico
     * const diagnostico = await prisma.diagnostico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends diagnosticoUpdateArgs>(args: SelectSubset<T, diagnosticoUpdateArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diagnosticos.
     * @param {diagnosticoDeleteManyArgs} args - Arguments to filter Diagnosticos to delete.
     * @example
     * // Delete a few Diagnosticos
     * const { count } = await prisma.diagnostico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends diagnosticoDeleteManyArgs>(args?: SelectSubset<T, diagnosticoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnosticos
     * const diagnostico = await prisma.diagnostico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends diagnosticoUpdateManyArgs>(args: SelectSubset<T, diagnosticoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnosticos and returns the data updated in the database.
     * @param {diagnosticoUpdateManyAndReturnArgs} args - Arguments to update many Diagnosticos.
     * @example
     * // Update many Diagnosticos
     * const diagnostico = await prisma.diagnostico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diagnosticos and only return the `id_diagnostico`
     * const diagnosticoWithId_diagnosticoOnly = await prisma.diagnostico.updateManyAndReturn({
     *   select: { id_diagnostico: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends diagnosticoUpdateManyAndReturnArgs>(args: SelectSubset<T, diagnosticoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diagnostico.
     * @param {diagnosticoUpsertArgs} args - Arguments to update or create a Diagnostico.
     * @example
     * // Update or create a Diagnostico
     * const diagnostico = await prisma.diagnostico.upsert({
     *   create: {
     *     // ... data to create a Diagnostico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnostico we want to update
     *   }
     * })
     */
    upsert<T extends diagnosticoUpsertArgs>(args: SelectSubset<T, diagnosticoUpsertArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoCountArgs} args - Arguments to filter Diagnosticos to count.
     * @example
     * // Count the number of Diagnosticos
     * const count = await prisma.diagnostico.count({
     *   where: {
     *     // ... the filter for the Diagnosticos we want to count
     *   }
     * })
    **/
    count<T extends diagnosticoCountArgs>(
      args?: Subset<T, diagnosticoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosticoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosticoAggregateArgs>(args: Subset<T, DiagnosticoAggregateArgs>): Prisma.PrismaPromise<GetDiagnosticoAggregateType<T>>

    /**
     * Group by Diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diagnosticoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diagnosticoGroupByArgs['orderBy'] }
        : { orderBy?: diagnosticoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diagnosticoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosticoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diagnostico model
   */
  readonly fields: diagnosticoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnostico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diagnosticoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consulta<T extends diagnostico$consultaArgs<ExtArgs> = {}>(args?: Subset<T, diagnostico$consultaArgs<ExtArgs>>): Prisma__consultaClient<$Result.GetResult<Prisma.$consultaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tratamiento<T extends diagnostico$tratamientoArgs<ExtArgs> = {}>(args?: Subset<T, diagnostico$tratamientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diagnostico model
   */
  interface diagnosticoFieldRefs {
    readonly id_diagnostico: FieldRef<"diagnostico", 'Int'>
    readonly nombrediagnostico: FieldRef<"diagnostico", 'String'>
    readonly descripcion: FieldRef<"diagnostico", 'String'>
    readonly id_consulta: FieldRef<"diagnostico", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * diagnostico findUnique
   */
  export type diagnosticoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico findUniqueOrThrow
   */
  export type diagnosticoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico findFirst
   */
  export type diagnosticoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosticos.
     */
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico findFirstOrThrow
   */
  export type diagnosticoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosticos.
     */
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico findMany
   */
  export type diagnosticoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnosticos to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico create
   */
  export type diagnosticoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to create a diagnostico.
     */
    data?: XOR<diagnosticoCreateInput, diagnosticoUncheckedCreateInput>
  }

  /**
   * diagnostico createMany
   */
  export type diagnosticoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diagnosticos.
     */
    data: diagnosticoCreateManyInput | diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diagnostico createManyAndReturn
   */
  export type diagnosticoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to create many diagnosticos.
     */
    data: diagnosticoCreateManyInput | diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostico update
   */
  export type diagnosticoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to update a diagnostico.
     */
    data: XOR<diagnosticoUpdateInput, diagnosticoUncheckedUpdateInput>
    /**
     * Choose, which diagnostico to update.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico updateMany
   */
  export type diagnosticoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diagnosticos.
     */
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which diagnosticos to update
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to update.
     */
    limit?: number
  }

  /**
   * diagnostico updateManyAndReturn
   */
  export type diagnosticoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to update diagnosticos.
     */
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which diagnosticos to update
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostico upsert
   */
  export type diagnosticoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The filter to search for the diagnostico to update in case it exists.
     */
    where: diagnosticoWhereUniqueInput
    /**
     * In case the diagnostico found by the `where` argument doesn't exist, create a new diagnostico with this data.
     */
    create: XOR<diagnosticoCreateInput, diagnosticoUncheckedCreateInput>
    /**
     * In case the diagnostico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diagnosticoUpdateInput, diagnosticoUncheckedUpdateInput>
  }

  /**
   * diagnostico delete
   */
  export type diagnosticoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter which diagnostico to delete.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico deleteMany
   */
  export type diagnosticoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnosticos to delete
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to delete.
     */
    limit?: number
  }

  /**
   * diagnostico.consulta
   */
  export type diagnostico$consultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta
     */
    select?: consultaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta
     */
    omit?: consultaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultaInclude<ExtArgs> | null
    where?: consultaWhereInput
  }

  /**
   * diagnostico.tratamiento
   */
  export type diagnostico$tratamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    where?: tratamientoWhereInput
    orderBy?: tratamientoOrderByWithRelationInput | tratamientoOrderByWithRelationInput[]
    cursor?: tratamientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TratamientoScalarFieldEnum | TratamientoScalarFieldEnum[]
  }

  /**
   * diagnostico without action
   */
  export type diagnosticoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
  }


  /**
   * Model doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    id_doctor: number | null
    id_usuario: number | null
    salario: number | null
    id_especialidad: number | null
  }

  export type DoctorSumAggregateOutputType = {
    id_doctor: number | null
    id_usuario: number | null
    salario: number | null
    id_especialidad: number | null
  }

  export type DoctorMinAggregateOutputType = {
    id_doctor: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    telefono: string | null
    correo: string | null
    id_especialidad: number | null
  }

  export type DoctorMaxAggregateOutputType = {
    id_doctor: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    telefono: string | null
    correo: string | null
    id_especialidad: number | null
  }

  export type DoctorCountAggregateOutputType = {
    id_doctor: number
    nombre: number
    segundonombre: number
    primerapellido: number
    segundoapellido: number
    nacimiento: number
    id_usuario: number
    fechacontratacion: number
    salario: number
    telefono: number
    correo: number
    id_especialidad: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    id_doctor?: true
    id_usuario?: true
    salario?: true
    id_especialidad?: true
  }

  export type DoctorSumAggregateInputType = {
    id_doctor?: true
    id_usuario?: true
    salario?: true
    id_especialidad?: true
  }

  export type DoctorMinAggregateInputType = {
    id_doctor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    telefono?: true
    correo?: true
    id_especialidad?: true
  }

  export type DoctorMaxAggregateInputType = {
    id_doctor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    telefono?: true
    correo?: true
    id_especialidad?: true
  }

  export type DoctorCountAggregateInputType = {
    id_doctor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    telefono?: true
    correo?: true
    id_especialidad?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctor to aggregate.
     */
    where?: doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctors to fetch.
     */
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type doctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: doctorWhereInput
    orderBy?: doctorOrderByWithAggregationInput | doctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: doctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id_doctor: number
    nombre: string
    segundonombre: string | null
    primerapellido: string
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    telefono: string | null
    correo: string | null
    id_especialidad: number | null
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends doctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type doctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_doctor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    telefono?: boolean
    correo?: boolean
    id_especialidad?: boolean
    cita?: boolean | doctor$citaArgs<ExtArgs>
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
    especialidad_doctor?: boolean | doctor$especialidad_doctorArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type doctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_doctor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    telefono?: boolean
    correo?: boolean
    id_especialidad?: boolean
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type doctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_doctor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    telefono?: boolean
    correo?: boolean
    id_especialidad?: boolean
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type doctorSelectScalar = {
    id_doctor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    telefono?: boolean
    correo?: boolean
    id_especialidad?: boolean
  }

  export type doctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_doctor" | "nombre" | "segundonombre" | "primerapellido" | "segundoapellido" | "nacimiento" | "id_usuario" | "fechacontratacion" | "salario" | "telefono" | "correo" | "id_especialidad", ExtArgs["result"]["doctor"]>
  export type doctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | doctor$citaArgs<ExtArgs>
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
    especialidad_doctor?: boolean | doctor$especialidad_doctorArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type doctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
  }
  export type doctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialidad?: boolean | doctor$especialidadArgs<ExtArgs>
    usuario?: boolean | doctor$usuarioArgs<ExtArgs>
  }

  export type $doctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "doctor"
    objects: {
      cita: Prisma.$citaPayload<ExtArgs>[]
      especialidad: Prisma.$especialidadPayload<ExtArgs> | null
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
      especialidad_doctor: Prisma.$especialidad_doctorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_doctor: number
      nombre: string
      segundonombre: string | null
      primerapellido: string
      segundoapellido: string | null
      nacimiento: Date | null
      id_usuario: number | null
      fechacontratacion: Date | null
      salario: number | null
      telefono: string | null
      correo: string | null
      id_especialidad: number | null
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type doctorGetPayload<S extends boolean | null | undefined | doctorDefaultArgs> = $Result.GetResult<Prisma.$doctorPayload, S>

  type doctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<doctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface doctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['doctor'], meta: { name: 'doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {doctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends doctorFindUniqueArgs>(args: SelectSubset<T, doctorFindUniqueArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {doctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends doctorFindUniqueOrThrowArgs>(args: SelectSubset<T, doctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends doctorFindFirstArgs>(args?: SelectSubset<T, doctorFindFirstArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends doctorFindFirstOrThrowArgs>(args?: SelectSubset<T, doctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id_doctor`
     * const doctorWithId_doctorOnly = await prisma.doctor.findMany({ select: { id_doctor: true } })
     * 
     */
    findMany<T extends doctorFindManyArgs>(args?: SelectSubset<T, doctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {doctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends doctorCreateArgs>(args: SelectSubset<T, doctorCreateArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {doctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends doctorCreateManyArgs>(args?: SelectSubset<T, doctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {doctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id_doctor`
     * const doctorWithId_doctorOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id_doctor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends doctorCreateManyAndReturnArgs>(args?: SelectSubset<T, doctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {doctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends doctorDeleteArgs>(args: SelectSubset<T, doctorDeleteArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {doctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends doctorUpdateArgs>(args: SelectSubset<T, doctorUpdateArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {doctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends doctorDeleteManyArgs>(args?: SelectSubset<T, doctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends doctorUpdateManyArgs>(args: SelectSubset<T, doctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {doctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id_doctor`
     * const doctorWithId_doctorOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id_doctor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends doctorUpdateManyAndReturnArgs>(args: SelectSubset<T, doctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {doctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends doctorUpsertArgs>(args: SelectSubset<T, doctorUpsertArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends doctorCountArgs>(
      args?: Subset<T, doctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends doctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: doctorGroupByArgs['orderBy'] }
        : { orderBy?: doctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, doctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the doctor model
   */
  readonly fields: doctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__doctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cita<T extends doctor$citaArgs<ExtArgs> = {}>(args?: Subset<T, doctor$citaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    especialidad<T extends doctor$especialidadArgs<ExtArgs> = {}>(args?: Subset<T, doctor$especialidadArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usuario<T extends doctor$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, doctor$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    especialidad_doctor<T extends doctor$especialidad_doctorArgs<ExtArgs> = {}>(args?: Subset<T, doctor$especialidad_doctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the doctor model
   */
  interface doctorFieldRefs {
    readonly id_doctor: FieldRef<"doctor", 'Int'>
    readonly nombre: FieldRef<"doctor", 'String'>
    readonly segundonombre: FieldRef<"doctor", 'String'>
    readonly primerapellido: FieldRef<"doctor", 'String'>
    readonly segundoapellido: FieldRef<"doctor", 'String'>
    readonly nacimiento: FieldRef<"doctor", 'DateTime'>
    readonly id_usuario: FieldRef<"doctor", 'Int'>
    readonly fechacontratacion: FieldRef<"doctor", 'DateTime'>
    readonly salario: FieldRef<"doctor", 'Float'>
    readonly telefono: FieldRef<"doctor", 'String'>
    readonly correo: FieldRef<"doctor", 'String'>
    readonly id_especialidad: FieldRef<"doctor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * doctor findUnique
   */
  export type doctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter, which doctor to fetch.
     */
    where: doctorWhereUniqueInput
  }

  /**
   * doctor findUniqueOrThrow
   */
  export type doctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter, which doctor to fetch.
     */
    where: doctorWhereUniqueInput
  }

  /**
   * doctor findFirst
   */
  export type doctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter, which doctor to fetch.
     */
    where?: doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctors to fetch.
     */
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctors.
     */
    cursor?: doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * doctor findFirstOrThrow
   */
  export type doctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter, which doctor to fetch.
     */
    where?: doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctors to fetch.
     */
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctors.
     */
    cursor?: doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * doctor findMany
   */
  export type doctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter, which doctors to fetch.
     */
    where?: doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctors to fetch.
     */
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing doctors.
     */
    cursor?: doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * doctor create
   */
  export type doctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * The data needed to create a doctor.
     */
    data: XOR<doctorCreateInput, doctorUncheckedCreateInput>
  }

  /**
   * doctor createMany
   */
  export type doctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many doctors.
     */
    data: doctorCreateManyInput | doctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * doctor createManyAndReturn
   */
  export type doctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * The data used to create many doctors.
     */
    data: doctorCreateManyInput | doctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * doctor update
   */
  export type doctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * The data needed to update a doctor.
     */
    data: XOR<doctorUpdateInput, doctorUncheckedUpdateInput>
    /**
     * Choose, which doctor to update.
     */
    where: doctorWhereUniqueInput
  }

  /**
   * doctor updateMany
   */
  export type doctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update doctors.
     */
    data: XOR<doctorUpdateManyMutationInput, doctorUncheckedUpdateManyInput>
    /**
     * Filter which doctors to update
     */
    where?: doctorWhereInput
    /**
     * Limit how many doctors to update.
     */
    limit?: number
  }

  /**
   * doctor updateManyAndReturn
   */
  export type doctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * The data used to update doctors.
     */
    data: XOR<doctorUpdateManyMutationInput, doctorUncheckedUpdateManyInput>
    /**
     * Filter which doctors to update
     */
    where?: doctorWhereInput
    /**
     * Limit how many doctors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * doctor upsert
   */
  export type doctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * The filter to search for the doctor to update in case it exists.
     */
    where: doctorWhereUniqueInput
    /**
     * In case the doctor found by the `where` argument doesn't exist, create a new doctor with this data.
     */
    create: XOR<doctorCreateInput, doctorUncheckedCreateInput>
    /**
     * In case the doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<doctorUpdateInput, doctorUncheckedUpdateInput>
  }

  /**
   * doctor delete
   */
  export type doctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    /**
     * Filter which doctor to delete.
     */
    where: doctorWhereUniqueInput
  }

  /**
   * doctor deleteMany
   */
  export type doctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctors to delete
     */
    where?: doctorWhereInput
    /**
     * Limit how many doctors to delete.
     */
    limit?: number
  }

  /**
   * doctor.cita
   */
  export type doctor$citaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    where?: citaWhereInput
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    cursor?: citaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * doctor.especialidad
   */
  export type doctor$especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    where?: especialidadWhereInput
  }

  /**
   * doctor.usuario
   */
  export type doctor$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * doctor.especialidad_doctor
   */
  export type doctor$especialidad_doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    where?: especialidad_doctorWhereInput
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    cursor?: especialidad_doctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Especialidad_doctorScalarFieldEnum | Especialidad_doctorScalarFieldEnum[]
  }

  /**
   * doctor without action
   */
  export type doctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
  }


  /**
   * Model especialidad
   */

  export type AggregateEspecialidad = {
    _count: EspecialidadCountAggregateOutputType | null
    _avg: EspecialidadAvgAggregateOutputType | null
    _sum: EspecialidadSumAggregateOutputType | null
    _min: EspecialidadMinAggregateOutputType | null
    _max: EspecialidadMaxAggregateOutputType | null
  }

  export type EspecialidadAvgAggregateOutputType = {
    id_especialidad: number | null
  }

  export type EspecialidadSumAggregateOutputType = {
    id_especialidad: number | null
  }

  export type EspecialidadMinAggregateOutputType = {
    id_especialidad: number | null
    nombreespecialidad: string | null
    descripcion: string | null
  }

  export type EspecialidadMaxAggregateOutputType = {
    id_especialidad: number | null
    nombreespecialidad: string | null
    descripcion: string | null
  }

  export type EspecialidadCountAggregateOutputType = {
    id_especialidad: number
    nombreespecialidad: number
    descripcion: number
    _all: number
  }


  export type EspecialidadAvgAggregateInputType = {
    id_especialidad?: true
  }

  export type EspecialidadSumAggregateInputType = {
    id_especialidad?: true
  }

  export type EspecialidadMinAggregateInputType = {
    id_especialidad?: true
    nombreespecialidad?: true
    descripcion?: true
  }

  export type EspecialidadMaxAggregateInputType = {
    id_especialidad?: true
    nombreespecialidad?: true
    descripcion?: true
  }

  export type EspecialidadCountAggregateInputType = {
    id_especialidad?: true
    nombreespecialidad?: true
    descripcion?: true
    _all?: true
  }

  export type EspecialidadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidad to aggregate.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especialidads
    **/
    _count?: true | EspecialidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecialidadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecialidadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecialidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecialidadMaxAggregateInputType
  }

  export type GetEspecialidadAggregateType<T extends EspecialidadAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialidad[P]>
      : GetScalarType<T[P], AggregateEspecialidad[P]>
  }




  export type especialidadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidadWhereInput
    orderBy?: especialidadOrderByWithAggregationInput | especialidadOrderByWithAggregationInput[]
    by: EspecialidadScalarFieldEnum[] | EspecialidadScalarFieldEnum
    having?: especialidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecialidadCountAggregateInputType | true
    _avg?: EspecialidadAvgAggregateInputType
    _sum?: EspecialidadSumAggregateInputType
    _min?: EspecialidadMinAggregateInputType
    _max?: EspecialidadMaxAggregateInputType
  }

  export type EspecialidadGroupByOutputType = {
    id_especialidad: number
    nombreespecialidad: string | null
    descripcion: string | null
    _count: EspecialidadCountAggregateOutputType | null
    _avg: EspecialidadAvgAggregateOutputType | null
    _sum: EspecialidadSumAggregateOutputType | null
    _min: EspecialidadMinAggregateOutputType | null
    _max: EspecialidadMaxAggregateOutputType | null
  }

  type GetEspecialidadGroupByPayload<T extends especialidadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecialidadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecialidadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecialidadGroupByOutputType[P]>
            : GetScalarType<T[P], EspecialidadGroupByOutputType[P]>
        }
      >
    >


  export type especialidadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombreespecialidad?: boolean
    descripcion?: boolean
    doctor?: boolean | especialidad$doctorArgs<ExtArgs>
    especialidad_doctor?: boolean | especialidad$especialidad_doctorArgs<ExtArgs>
    _count?: boolean | EspecialidadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especialidad"]>

  export type especialidadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombreespecialidad?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["especialidad"]>

  export type especialidadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombreespecialidad?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["especialidad"]>

  export type especialidadSelectScalar = {
    id_especialidad?: boolean
    nombreespecialidad?: boolean
    descripcion?: boolean
  }

  export type especialidadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_especialidad" | "nombreespecialidad" | "descripcion", ExtArgs["result"]["especialidad"]>
  export type especialidadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | especialidad$doctorArgs<ExtArgs>
    especialidad_doctor?: boolean | especialidad$especialidad_doctorArgs<ExtArgs>
    _count?: boolean | EspecialidadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type especialidadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type especialidadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $especialidadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especialidad"
    objects: {
      doctor: Prisma.$doctorPayload<ExtArgs>[]
      especialidad_doctor: Prisma.$especialidad_doctorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especialidad: number
      nombreespecialidad: string | null
      descripcion: string | null
    }, ExtArgs["result"]["especialidad"]>
    composites: {}
  }

  type especialidadGetPayload<S extends boolean | null | undefined | especialidadDefaultArgs> = $Result.GetResult<Prisma.$especialidadPayload, S>

  type especialidadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<especialidadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EspecialidadCountAggregateInputType | true
    }

  export interface especialidadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especialidad'], meta: { name: 'especialidad' } }
    /**
     * Find zero or one Especialidad that matches the filter.
     * @param {especialidadFindUniqueArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends especialidadFindUniqueArgs>(args: SelectSubset<T, especialidadFindUniqueArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Especialidad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {especialidadFindUniqueOrThrowArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends especialidadFindUniqueOrThrowArgs>(args: SelectSubset<T, especialidadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindFirstArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends especialidadFindFirstArgs>(args?: SelectSubset<T, especialidadFindFirstArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindFirstOrThrowArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends especialidadFindFirstOrThrowArgs>(args?: SelectSubset<T, especialidadFindFirstOrThrowArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Especialidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialidads
     * const especialidads = await prisma.especialidad.findMany()
     * 
     * // Get first 10 Especialidads
     * const especialidads = await prisma.especialidad.findMany({ take: 10 })
     * 
     * // Only select the `id_especialidad`
     * const especialidadWithId_especialidadOnly = await prisma.especialidad.findMany({ select: { id_especialidad: true } })
     * 
     */
    findMany<T extends especialidadFindManyArgs>(args?: SelectSubset<T, especialidadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Especialidad.
     * @param {especialidadCreateArgs} args - Arguments to create a Especialidad.
     * @example
     * // Create one Especialidad
     * const Especialidad = await prisma.especialidad.create({
     *   data: {
     *     // ... data to create a Especialidad
     *   }
     * })
     * 
     */
    create<T extends especialidadCreateArgs>(args: SelectSubset<T, especialidadCreateArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Especialidads.
     * @param {especialidadCreateManyArgs} args - Arguments to create many Especialidads.
     * @example
     * // Create many Especialidads
     * const especialidad = await prisma.especialidad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends especialidadCreateManyArgs>(args?: SelectSubset<T, especialidadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Especialidads and returns the data saved in the database.
     * @param {especialidadCreateManyAndReturnArgs} args - Arguments to create many Especialidads.
     * @example
     * // Create many Especialidads
     * const especialidad = await prisma.especialidad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Especialidads and only return the `id_especialidad`
     * const especialidadWithId_especialidadOnly = await prisma.especialidad.createManyAndReturn({
     *   select: { id_especialidad: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends especialidadCreateManyAndReturnArgs>(args?: SelectSubset<T, especialidadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Especialidad.
     * @param {especialidadDeleteArgs} args - Arguments to delete one Especialidad.
     * @example
     * // Delete one Especialidad
     * const Especialidad = await prisma.especialidad.delete({
     *   where: {
     *     // ... filter to delete one Especialidad
     *   }
     * })
     * 
     */
    delete<T extends especialidadDeleteArgs>(args: SelectSubset<T, especialidadDeleteArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Especialidad.
     * @param {especialidadUpdateArgs} args - Arguments to update one Especialidad.
     * @example
     * // Update one Especialidad
     * const especialidad = await prisma.especialidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends especialidadUpdateArgs>(args: SelectSubset<T, especialidadUpdateArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Especialidads.
     * @param {especialidadDeleteManyArgs} args - Arguments to filter Especialidads to delete.
     * @example
     * // Delete a few Especialidads
     * const { count } = await prisma.especialidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends especialidadDeleteManyArgs>(args?: SelectSubset<T, especialidadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialidads
     * const especialidad = await prisma.especialidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends especialidadUpdateManyArgs>(args: SelectSubset<T, especialidadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidads and returns the data updated in the database.
     * @param {especialidadUpdateManyAndReturnArgs} args - Arguments to update many Especialidads.
     * @example
     * // Update many Especialidads
     * const especialidad = await prisma.especialidad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Especialidads and only return the `id_especialidad`
     * const especialidadWithId_especialidadOnly = await prisma.especialidad.updateManyAndReturn({
     *   select: { id_especialidad: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends especialidadUpdateManyAndReturnArgs>(args: SelectSubset<T, especialidadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Especialidad.
     * @param {especialidadUpsertArgs} args - Arguments to update or create a Especialidad.
     * @example
     * // Update or create a Especialidad
     * const especialidad = await prisma.especialidad.upsert({
     *   create: {
     *     // ... data to create a Especialidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialidad we want to update
     *   }
     * })
     */
    upsert<T extends especialidadUpsertArgs>(args: SelectSubset<T, especialidadUpsertArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadCountArgs} args - Arguments to filter Especialidads to count.
     * @example
     * // Count the number of Especialidads
     * const count = await prisma.especialidad.count({
     *   where: {
     *     // ... the filter for the Especialidads we want to count
     *   }
     * })
    **/
    count<T extends especialidadCountArgs>(
      args?: Subset<T, especialidadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecialidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecialidadAggregateArgs>(args: Subset<T, EspecialidadAggregateArgs>): Prisma.PrismaPromise<GetEspecialidadAggregateType<T>>

    /**
     * Group by Especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especialidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especialidadGroupByArgs['orderBy'] }
        : { orderBy?: especialidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especialidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialidadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especialidad model
   */
  readonly fields: especialidadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especialidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especialidadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends especialidad$doctorArgs<ExtArgs> = {}>(args?: Subset<T, especialidad$doctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    especialidad_doctor<T extends especialidad$especialidad_doctorArgs<ExtArgs> = {}>(args?: Subset<T, especialidad$especialidad_doctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the especialidad model
   */
  interface especialidadFieldRefs {
    readonly id_especialidad: FieldRef<"especialidad", 'Int'>
    readonly nombreespecialidad: FieldRef<"especialidad", 'String'>
    readonly descripcion: FieldRef<"especialidad", 'String'>
  }
    

  // Custom InputTypes
  /**
   * especialidad findUnique
   */
  export type especialidadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where: especialidadWhereUniqueInput
  }

  /**
   * especialidad findUniqueOrThrow
   */
  export type especialidadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where: especialidadWhereUniqueInput
  }

  /**
   * especialidad findFirst
   */
  export type especialidadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidads.
     */
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }

  /**
   * especialidad findFirstOrThrow
   */
  export type especialidadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidads.
     */
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }

  /**
   * especialidad findMany
   */
  export type especialidadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidads to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }

  /**
   * especialidad create
   */
  export type especialidadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The data needed to create a especialidad.
     */
    data?: XOR<especialidadCreateInput, especialidadUncheckedCreateInput>
  }

  /**
   * especialidad createMany
   */
  export type especialidadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especialidads.
     */
    data: especialidadCreateManyInput | especialidadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidad createManyAndReturn
   */
  export type especialidadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * The data used to create many especialidads.
     */
    data: especialidadCreateManyInput | especialidadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidad update
   */
  export type especialidadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The data needed to update a especialidad.
     */
    data: XOR<especialidadUpdateInput, especialidadUncheckedUpdateInput>
    /**
     * Choose, which especialidad to update.
     */
    where: especialidadWhereUniqueInput
  }

  /**
   * especialidad updateMany
   */
  export type especialidadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especialidads.
     */
    data: XOR<especialidadUpdateManyMutationInput, especialidadUncheckedUpdateManyInput>
    /**
     * Filter which especialidads to update
     */
    where?: especialidadWhereInput
    /**
     * Limit how many especialidads to update.
     */
    limit?: number
  }

  /**
   * especialidad updateManyAndReturn
   */
  export type especialidadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * The data used to update especialidads.
     */
    data: XOR<especialidadUpdateManyMutationInput, especialidadUncheckedUpdateManyInput>
    /**
     * Filter which especialidads to update
     */
    where?: especialidadWhereInput
    /**
     * Limit how many especialidads to update.
     */
    limit?: number
  }

  /**
   * especialidad upsert
   */
  export type especialidadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The filter to search for the especialidad to update in case it exists.
     */
    where: especialidadWhereUniqueInput
    /**
     * In case the especialidad found by the `where` argument doesn't exist, create a new especialidad with this data.
     */
    create: XOR<especialidadCreateInput, especialidadUncheckedCreateInput>
    /**
     * In case the especialidad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especialidadUpdateInput, especialidadUncheckedUpdateInput>
  }

  /**
   * especialidad delete
   */
  export type especialidadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter which especialidad to delete.
     */
    where: especialidadWhereUniqueInput
  }

  /**
   * especialidad deleteMany
   */
  export type especialidadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidads to delete
     */
    where?: especialidadWhereInput
    /**
     * Limit how many especialidads to delete.
     */
    limit?: number
  }

  /**
   * especialidad.doctor
   */
  export type especialidad$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    where?: doctorWhereInput
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    cursor?: doctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * especialidad.especialidad_doctor
   */
  export type especialidad$especialidad_doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    where?: especialidad_doctorWhereInput
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    cursor?: especialidad_doctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Especialidad_doctorScalarFieldEnum | Especialidad_doctorScalarFieldEnum[]
  }

  /**
   * especialidad without action
   */
  export type especialidadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
  }


  /**
   * Model especialidad_doctor
   */

  export type AggregateEspecialidad_doctor = {
    _count: Especialidad_doctorCountAggregateOutputType | null
    _avg: Especialidad_doctorAvgAggregateOutputType | null
    _sum: Especialidad_doctorSumAggregateOutputType | null
    _min: Especialidad_doctorMinAggregateOutputType | null
    _max: Especialidad_doctorMaxAggregateOutputType | null
  }

  export type Especialidad_doctorAvgAggregateOutputType = {
    id_especialidad_doctor: number | null
    id_doctor: number | null
    id_especialidad: number | null
  }

  export type Especialidad_doctorSumAggregateOutputType = {
    id_especialidad_doctor: number | null
    id_doctor: number | null
    id_especialidad: number | null
  }

  export type Especialidad_doctorMinAggregateOutputType = {
    id_especialidad_doctor: number | null
    id_doctor: number | null
    id_especialidad: number | null
  }

  export type Especialidad_doctorMaxAggregateOutputType = {
    id_especialidad_doctor: number | null
    id_doctor: number | null
    id_especialidad: number | null
  }

  export type Especialidad_doctorCountAggregateOutputType = {
    id_especialidad_doctor: number
    id_doctor: number
    id_especialidad: number
    _all: number
  }


  export type Especialidad_doctorAvgAggregateInputType = {
    id_especialidad_doctor?: true
    id_doctor?: true
    id_especialidad?: true
  }

  export type Especialidad_doctorSumAggregateInputType = {
    id_especialidad_doctor?: true
    id_doctor?: true
    id_especialidad?: true
  }

  export type Especialidad_doctorMinAggregateInputType = {
    id_especialidad_doctor?: true
    id_doctor?: true
    id_especialidad?: true
  }

  export type Especialidad_doctorMaxAggregateInputType = {
    id_especialidad_doctor?: true
    id_doctor?: true
    id_especialidad?: true
  }

  export type Especialidad_doctorCountAggregateInputType = {
    id_especialidad_doctor?: true
    id_doctor?: true
    id_especialidad?: true
    _all?: true
  }

  export type Especialidad_doctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidad_doctor to aggregate.
     */
    where?: especialidad_doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidad_doctors to fetch.
     */
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especialidad_doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidad_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidad_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especialidad_doctors
    **/
    _count?: true | Especialidad_doctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Especialidad_doctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Especialidad_doctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Especialidad_doctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Especialidad_doctorMaxAggregateInputType
  }

  export type GetEspecialidad_doctorAggregateType<T extends Especialidad_doctorAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialidad_doctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialidad_doctor[P]>
      : GetScalarType<T[P], AggregateEspecialidad_doctor[P]>
  }




  export type especialidad_doctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidad_doctorWhereInput
    orderBy?: especialidad_doctorOrderByWithAggregationInput | especialidad_doctorOrderByWithAggregationInput[]
    by: Especialidad_doctorScalarFieldEnum[] | Especialidad_doctorScalarFieldEnum
    having?: especialidad_doctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Especialidad_doctorCountAggregateInputType | true
    _avg?: Especialidad_doctorAvgAggregateInputType
    _sum?: Especialidad_doctorSumAggregateInputType
    _min?: Especialidad_doctorMinAggregateInputType
    _max?: Especialidad_doctorMaxAggregateInputType
  }

  export type Especialidad_doctorGroupByOutputType = {
    id_especialidad_doctor: number
    id_doctor: number | null
    id_especialidad: number | null
    _count: Especialidad_doctorCountAggregateOutputType | null
    _avg: Especialidad_doctorAvgAggregateOutputType | null
    _sum: Especialidad_doctorSumAggregateOutputType | null
    _min: Especialidad_doctorMinAggregateOutputType | null
    _max: Especialidad_doctorMaxAggregateOutputType | null
  }

  type GetEspecialidad_doctorGroupByPayload<T extends especialidad_doctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Especialidad_doctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Especialidad_doctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Especialidad_doctorGroupByOutputType[P]>
            : GetScalarType<T[P], Especialidad_doctorGroupByOutputType[P]>
        }
      >
    >


  export type especialidad_doctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad_doctor?: boolean
    id_doctor?: boolean
    id_especialidad?: boolean
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }, ExtArgs["result"]["especialidad_doctor"]>

  export type especialidad_doctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad_doctor?: boolean
    id_doctor?: boolean
    id_especialidad?: boolean
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }, ExtArgs["result"]["especialidad_doctor"]>

  export type especialidad_doctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad_doctor?: boolean
    id_doctor?: boolean
    id_especialidad?: boolean
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }, ExtArgs["result"]["especialidad_doctor"]>

  export type especialidad_doctorSelectScalar = {
    id_especialidad_doctor?: boolean
    id_doctor?: boolean
    id_especialidad?: boolean
  }

  export type especialidad_doctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_especialidad_doctor" | "id_doctor" | "id_especialidad", ExtArgs["result"]["especialidad_doctor"]>
  export type especialidad_doctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }
  export type especialidad_doctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }
  export type especialidad_doctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | especialidad_doctor$doctorArgs<ExtArgs>
    especialidad?: boolean | especialidad_doctor$especialidadArgs<ExtArgs>
  }

  export type $especialidad_doctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especialidad_doctor"
    objects: {
      doctor: Prisma.$doctorPayload<ExtArgs> | null
      especialidad: Prisma.$especialidadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especialidad_doctor: number
      id_doctor: number | null
      id_especialidad: number | null
    }, ExtArgs["result"]["especialidad_doctor"]>
    composites: {}
  }

  type especialidad_doctorGetPayload<S extends boolean | null | undefined | especialidad_doctorDefaultArgs> = $Result.GetResult<Prisma.$especialidad_doctorPayload, S>

  type especialidad_doctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<especialidad_doctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Especialidad_doctorCountAggregateInputType | true
    }

  export interface especialidad_doctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especialidad_doctor'], meta: { name: 'especialidad_doctor' } }
    /**
     * Find zero or one Especialidad_doctor that matches the filter.
     * @param {especialidad_doctorFindUniqueArgs} args - Arguments to find a Especialidad_doctor
     * @example
     * // Get one Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends especialidad_doctorFindUniqueArgs>(args: SelectSubset<T, especialidad_doctorFindUniqueArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Especialidad_doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {especialidad_doctorFindUniqueOrThrowArgs} args - Arguments to find a Especialidad_doctor
     * @example
     * // Get one Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends especialidad_doctorFindUniqueOrThrowArgs>(args: SelectSubset<T, especialidad_doctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidad_doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorFindFirstArgs} args - Arguments to find a Especialidad_doctor
     * @example
     * // Get one Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends especialidad_doctorFindFirstArgs>(args?: SelectSubset<T, especialidad_doctorFindFirstArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidad_doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorFindFirstOrThrowArgs} args - Arguments to find a Especialidad_doctor
     * @example
     * // Get one Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends especialidad_doctorFindFirstOrThrowArgs>(args?: SelectSubset<T, especialidad_doctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Especialidad_doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialidad_doctors
     * const especialidad_doctors = await prisma.especialidad_doctor.findMany()
     * 
     * // Get first 10 Especialidad_doctors
     * const especialidad_doctors = await prisma.especialidad_doctor.findMany({ take: 10 })
     * 
     * // Only select the `id_especialidad_doctor`
     * const especialidad_doctorWithId_especialidad_doctorOnly = await prisma.especialidad_doctor.findMany({ select: { id_especialidad_doctor: true } })
     * 
     */
    findMany<T extends especialidad_doctorFindManyArgs>(args?: SelectSubset<T, especialidad_doctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Especialidad_doctor.
     * @param {especialidad_doctorCreateArgs} args - Arguments to create a Especialidad_doctor.
     * @example
     * // Create one Especialidad_doctor
     * const Especialidad_doctor = await prisma.especialidad_doctor.create({
     *   data: {
     *     // ... data to create a Especialidad_doctor
     *   }
     * })
     * 
     */
    create<T extends especialidad_doctorCreateArgs>(args: SelectSubset<T, especialidad_doctorCreateArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Especialidad_doctors.
     * @param {especialidad_doctorCreateManyArgs} args - Arguments to create many Especialidad_doctors.
     * @example
     * // Create many Especialidad_doctors
     * const especialidad_doctor = await prisma.especialidad_doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends especialidad_doctorCreateManyArgs>(args?: SelectSubset<T, especialidad_doctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Especialidad_doctors and returns the data saved in the database.
     * @param {especialidad_doctorCreateManyAndReturnArgs} args - Arguments to create many Especialidad_doctors.
     * @example
     * // Create many Especialidad_doctors
     * const especialidad_doctor = await prisma.especialidad_doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Especialidad_doctors and only return the `id_especialidad_doctor`
     * const especialidad_doctorWithId_especialidad_doctorOnly = await prisma.especialidad_doctor.createManyAndReturn({
     *   select: { id_especialidad_doctor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends especialidad_doctorCreateManyAndReturnArgs>(args?: SelectSubset<T, especialidad_doctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Especialidad_doctor.
     * @param {especialidad_doctorDeleteArgs} args - Arguments to delete one Especialidad_doctor.
     * @example
     * // Delete one Especialidad_doctor
     * const Especialidad_doctor = await prisma.especialidad_doctor.delete({
     *   where: {
     *     // ... filter to delete one Especialidad_doctor
     *   }
     * })
     * 
     */
    delete<T extends especialidad_doctorDeleteArgs>(args: SelectSubset<T, especialidad_doctorDeleteArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Especialidad_doctor.
     * @param {especialidad_doctorUpdateArgs} args - Arguments to update one Especialidad_doctor.
     * @example
     * // Update one Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends especialidad_doctorUpdateArgs>(args: SelectSubset<T, especialidad_doctorUpdateArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Especialidad_doctors.
     * @param {especialidad_doctorDeleteManyArgs} args - Arguments to filter Especialidad_doctors to delete.
     * @example
     * // Delete a few Especialidad_doctors
     * const { count } = await prisma.especialidad_doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends especialidad_doctorDeleteManyArgs>(args?: SelectSubset<T, especialidad_doctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidad_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialidad_doctors
     * const especialidad_doctor = await prisma.especialidad_doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends especialidad_doctorUpdateManyArgs>(args: SelectSubset<T, especialidad_doctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidad_doctors and returns the data updated in the database.
     * @param {especialidad_doctorUpdateManyAndReturnArgs} args - Arguments to update many Especialidad_doctors.
     * @example
     * // Update many Especialidad_doctors
     * const especialidad_doctor = await prisma.especialidad_doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Especialidad_doctors and only return the `id_especialidad_doctor`
     * const especialidad_doctorWithId_especialidad_doctorOnly = await prisma.especialidad_doctor.updateManyAndReturn({
     *   select: { id_especialidad_doctor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends especialidad_doctorUpdateManyAndReturnArgs>(args: SelectSubset<T, especialidad_doctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Especialidad_doctor.
     * @param {especialidad_doctorUpsertArgs} args - Arguments to update or create a Especialidad_doctor.
     * @example
     * // Update or create a Especialidad_doctor
     * const especialidad_doctor = await prisma.especialidad_doctor.upsert({
     *   create: {
     *     // ... data to create a Especialidad_doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialidad_doctor we want to update
     *   }
     * })
     */
    upsert<T extends especialidad_doctorUpsertArgs>(args: SelectSubset<T, especialidad_doctorUpsertArgs<ExtArgs>>): Prisma__especialidad_doctorClient<$Result.GetResult<Prisma.$especialidad_doctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Especialidad_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorCountArgs} args - Arguments to filter Especialidad_doctors to count.
     * @example
     * // Count the number of Especialidad_doctors
     * const count = await prisma.especialidad_doctor.count({
     *   where: {
     *     // ... the filter for the Especialidad_doctors we want to count
     *   }
     * })
    **/
    count<T extends especialidad_doctorCountArgs>(
      args?: Subset<T, especialidad_doctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Especialidad_doctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialidad_doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Especialidad_doctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Especialidad_doctorAggregateArgs>(args: Subset<T, Especialidad_doctorAggregateArgs>): Prisma.PrismaPromise<GetEspecialidad_doctorAggregateType<T>>

    /**
     * Group by Especialidad_doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidad_doctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especialidad_doctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especialidad_doctorGroupByArgs['orderBy'] }
        : { orderBy?: especialidad_doctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especialidad_doctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialidad_doctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especialidad_doctor model
   */
  readonly fields: especialidad_doctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especialidad_doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especialidad_doctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends especialidad_doctor$doctorArgs<ExtArgs> = {}>(args?: Subset<T, especialidad_doctor$doctorArgs<ExtArgs>>): Prisma__doctorClient<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    especialidad<T extends especialidad_doctor$especialidadArgs<ExtArgs> = {}>(args?: Subset<T, especialidad_doctor$especialidadArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the especialidad_doctor model
   */
  interface especialidad_doctorFieldRefs {
    readonly id_especialidad_doctor: FieldRef<"especialidad_doctor", 'Int'>
    readonly id_doctor: FieldRef<"especialidad_doctor", 'Int'>
    readonly id_especialidad: FieldRef<"especialidad_doctor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * especialidad_doctor findUnique
   */
  export type especialidad_doctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter, which especialidad_doctor to fetch.
     */
    where: especialidad_doctorWhereUniqueInput
  }

  /**
   * especialidad_doctor findUniqueOrThrow
   */
  export type especialidad_doctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter, which especialidad_doctor to fetch.
     */
    where: especialidad_doctorWhereUniqueInput
  }

  /**
   * especialidad_doctor findFirst
   */
  export type especialidad_doctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter, which especialidad_doctor to fetch.
     */
    where?: especialidad_doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidad_doctors to fetch.
     */
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidad_doctors.
     */
    cursor?: especialidad_doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidad_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidad_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidad_doctors.
     */
    distinct?: Especialidad_doctorScalarFieldEnum | Especialidad_doctorScalarFieldEnum[]
  }

  /**
   * especialidad_doctor findFirstOrThrow
   */
  export type especialidad_doctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter, which especialidad_doctor to fetch.
     */
    where?: especialidad_doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidad_doctors to fetch.
     */
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidad_doctors.
     */
    cursor?: especialidad_doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidad_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidad_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidad_doctors.
     */
    distinct?: Especialidad_doctorScalarFieldEnum | Especialidad_doctorScalarFieldEnum[]
  }

  /**
   * especialidad_doctor findMany
   */
  export type especialidad_doctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter, which especialidad_doctors to fetch.
     */
    where?: especialidad_doctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidad_doctors to fetch.
     */
    orderBy?: especialidad_doctorOrderByWithRelationInput | especialidad_doctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especialidad_doctors.
     */
    cursor?: especialidad_doctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidad_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidad_doctors.
     */
    skip?: number
    distinct?: Especialidad_doctorScalarFieldEnum | Especialidad_doctorScalarFieldEnum[]
  }

  /**
   * especialidad_doctor create
   */
  export type especialidad_doctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * The data needed to create a especialidad_doctor.
     */
    data?: XOR<especialidad_doctorCreateInput, especialidad_doctorUncheckedCreateInput>
  }

  /**
   * especialidad_doctor createMany
   */
  export type especialidad_doctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especialidad_doctors.
     */
    data: especialidad_doctorCreateManyInput | especialidad_doctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidad_doctor createManyAndReturn
   */
  export type especialidad_doctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * The data used to create many especialidad_doctors.
     */
    data: especialidad_doctorCreateManyInput | especialidad_doctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * especialidad_doctor update
   */
  export type especialidad_doctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * The data needed to update a especialidad_doctor.
     */
    data: XOR<especialidad_doctorUpdateInput, especialidad_doctorUncheckedUpdateInput>
    /**
     * Choose, which especialidad_doctor to update.
     */
    where: especialidad_doctorWhereUniqueInput
  }

  /**
   * especialidad_doctor updateMany
   */
  export type especialidad_doctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especialidad_doctors.
     */
    data: XOR<especialidad_doctorUpdateManyMutationInput, especialidad_doctorUncheckedUpdateManyInput>
    /**
     * Filter which especialidad_doctors to update
     */
    where?: especialidad_doctorWhereInput
    /**
     * Limit how many especialidad_doctors to update.
     */
    limit?: number
  }

  /**
   * especialidad_doctor updateManyAndReturn
   */
  export type especialidad_doctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * The data used to update especialidad_doctors.
     */
    data: XOR<especialidad_doctorUpdateManyMutationInput, especialidad_doctorUncheckedUpdateManyInput>
    /**
     * Filter which especialidad_doctors to update
     */
    where?: especialidad_doctorWhereInput
    /**
     * Limit how many especialidad_doctors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * especialidad_doctor upsert
   */
  export type especialidad_doctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * The filter to search for the especialidad_doctor to update in case it exists.
     */
    where: especialidad_doctorWhereUniqueInput
    /**
     * In case the especialidad_doctor found by the `where` argument doesn't exist, create a new especialidad_doctor with this data.
     */
    create: XOR<especialidad_doctorCreateInput, especialidad_doctorUncheckedCreateInput>
    /**
     * In case the especialidad_doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especialidad_doctorUpdateInput, especialidad_doctorUncheckedUpdateInput>
  }

  /**
   * especialidad_doctor delete
   */
  export type especialidad_doctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
    /**
     * Filter which especialidad_doctor to delete.
     */
    where: especialidad_doctorWhereUniqueInput
  }

  /**
   * especialidad_doctor deleteMany
   */
  export type especialidad_doctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidad_doctors to delete
     */
    where?: especialidad_doctorWhereInput
    /**
     * Limit how many especialidad_doctors to delete.
     */
    limit?: number
  }

  /**
   * especialidad_doctor.doctor
   */
  export type especialidad_doctor$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    where?: doctorWhereInput
  }

  /**
   * especialidad_doctor.especialidad
   */
  export type especialidad_doctor$especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad
     */
    omit?: especialidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadInclude<ExtArgs> | null
    where?: especialidadWhereInput
  }

  /**
   * especialidad_doctor without action
   */
  export type especialidad_doctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad_doctor
     */
    select?: especialidad_doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidad_doctor
     */
    omit?: especialidad_doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidad_doctorInclude<ExtArgs> | null
  }


  /**
   * Model examen
   */

  export type AggregateExamen = {
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  export type ExamenAvgAggregateOutputType = {
    id_examen: number | null
    id_paciente: number | null
  }

  export type ExamenSumAggregateOutputType = {
    id_examen: number | null
    id_paciente: number | null
  }

  export type ExamenMinAggregateOutputType = {
    id_examen: number | null
    tipoexamen: string | null
    rutaExamen: string | null
    id_paciente: number | null
  }

  export type ExamenMaxAggregateOutputType = {
    id_examen: number | null
    tipoexamen: string | null
    rutaExamen: string | null
    id_paciente: number | null
  }

  export type ExamenCountAggregateOutputType = {
    id_examen: number
    tipoexamen: number
    rutaExamen: number
    id_paciente: number
    _all: number
  }


  export type ExamenAvgAggregateInputType = {
    id_examen?: true
    id_paciente?: true
  }

  export type ExamenSumAggregateInputType = {
    id_examen?: true
    id_paciente?: true
  }

  export type ExamenMinAggregateInputType = {
    id_examen?: true
    tipoexamen?: true
    rutaExamen?: true
    id_paciente?: true
  }

  export type ExamenMaxAggregateInputType = {
    id_examen?: true
    tipoexamen?: true
    rutaExamen?: true
    id_paciente?: true
  }

  export type ExamenCountAggregateInputType = {
    id_examen?: true
    tipoexamen?: true
    rutaExamen?: true
    id_paciente?: true
    _all?: true
  }

  export type ExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examen to aggregate.
     */
    where?: examenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examen to fetch.
     */
    orderBy?: examenOrderByWithRelationInput | examenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examen
    **/
    _count?: true | ExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenMaxAggregateInputType
  }

  export type GetExamenAggregateType<T extends ExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateExamen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamen[P]>
      : GetScalarType<T[P], AggregateExamen[P]>
  }




  export type examenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenWhereInput
    orderBy?: examenOrderByWithAggregationInput | examenOrderByWithAggregationInput[]
    by: ExamenScalarFieldEnum[] | ExamenScalarFieldEnum
    having?: examenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenCountAggregateInputType | true
    _avg?: ExamenAvgAggregateInputType
    _sum?: ExamenSumAggregateInputType
    _min?: ExamenMinAggregateInputType
    _max?: ExamenMaxAggregateInputType
  }

  export type ExamenGroupByOutputType = {
    id_examen: number
    tipoexamen: string | null
    rutaExamen: string | null
    id_paciente: number | null
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  type GetExamenGroupByPayload<T extends examenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenGroupByOutputType[P]>
        }
      >
    >


  export type examenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examen?: boolean
    tipoexamen?: boolean
    rutaExamen?: boolean
    id_paciente?: boolean
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }, ExtArgs["result"]["examen"]>

  export type examenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examen?: boolean
    tipoexamen?: boolean
    rutaExamen?: boolean
    id_paciente?: boolean
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }, ExtArgs["result"]["examen"]>

  export type examenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examen?: boolean
    tipoexamen?: boolean
    rutaExamen?: boolean
    id_paciente?: boolean
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }, ExtArgs["result"]["examen"]>

  export type examenSelectScalar = {
    id_examen?: boolean
    tipoexamen?: boolean
    rutaExamen?: boolean
    id_paciente?: boolean
  }

  export type examenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_examen" | "tipoexamen" | "rutaExamen" | "id_paciente", ExtArgs["result"]["examen"]>
  export type examenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }
  export type examenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }
  export type examenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | examen$pacienteArgs<ExtArgs>
  }

  export type $examenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "examen"
    objects: {
      paciente: Prisma.$pacientePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_examen: number
      tipoexamen: string | null
      rutaExamen: string | null
      id_paciente: number | null
    }, ExtArgs["result"]["examen"]>
    composites: {}
  }

  type examenGetPayload<S extends boolean | null | undefined | examenDefaultArgs> = $Result.GetResult<Prisma.$examenPayload, S>

  type examenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamenCountAggregateInputType | true
    }

  export interface examenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['examen'], meta: { name: 'examen' } }
    /**
     * Find zero or one Examen that matches the filter.
     * @param {examenFindUniqueArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examenFindUniqueArgs>(args: SelectSubset<T, examenFindUniqueArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Examen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examenFindUniqueOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examenFindUniqueOrThrowArgs>(args: SelectSubset<T, examenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenFindFirstArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examenFindFirstArgs>(args?: SelectSubset<T, examenFindFirstArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenFindFirstOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examenFindFirstOrThrowArgs>(args?: SelectSubset<T, examenFindFirstOrThrowArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examen
     * const examen = await prisma.examen.findMany()
     * 
     * // Get first 10 Examen
     * const examen = await prisma.examen.findMany({ take: 10 })
     * 
     * // Only select the `id_examen`
     * const examenWithId_examenOnly = await prisma.examen.findMany({ select: { id_examen: true } })
     * 
     */
    findMany<T extends examenFindManyArgs>(args?: SelectSubset<T, examenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Examen.
     * @param {examenCreateArgs} args - Arguments to create a Examen.
     * @example
     * // Create one Examen
     * const Examen = await prisma.examen.create({
     *   data: {
     *     // ... data to create a Examen
     *   }
     * })
     * 
     */
    create<T extends examenCreateArgs>(args: SelectSubset<T, examenCreateArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Examen.
     * @param {examenCreateManyArgs} args - Arguments to create many Examen.
     * @example
     * // Create many Examen
     * const examen = await prisma.examen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examenCreateManyArgs>(args?: SelectSubset<T, examenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Examen and returns the data saved in the database.
     * @param {examenCreateManyAndReturnArgs} args - Arguments to create many Examen.
     * @example
     * // Create many Examen
     * const examen = await prisma.examen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Examen and only return the `id_examen`
     * const examenWithId_examenOnly = await prisma.examen.createManyAndReturn({
     *   select: { id_examen: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends examenCreateManyAndReturnArgs>(args?: SelectSubset<T, examenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Examen.
     * @param {examenDeleteArgs} args - Arguments to delete one Examen.
     * @example
     * // Delete one Examen
     * const Examen = await prisma.examen.delete({
     *   where: {
     *     // ... filter to delete one Examen
     *   }
     * })
     * 
     */
    delete<T extends examenDeleteArgs>(args: SelectSubset<T, examenDeleteArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Examen.
     * @param {examenUpdateArgs} args - Arguments to update one Examen.
     * @example
     * // Update one Examen
     * const examen = await prisma.examen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examenUpdateArgs>(args: SelectSubset<T, examenUpdateArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Examen.
     * @param {examenDeleteManyArgs} args - Arguments to filter Examen to delete.
     * @example
     * // Delete a few Examen
     * const { count } = await prisma.examen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examenDeleteManyArgs>(args?: SelectSubset<T, examenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examen
     * const examen = await prisma.examen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examenUpdateManyArgs>(args: SelectSubset<T, examenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examen and returns the data updated in the database.
     * @param {examenUpdateManyAndReturnArgs} args - Arguments to update many Examen.
     * @example
     * // Update many Examen
     * const examen = await prisma.examen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Examen and only return the `id_examen`
     * const examenWithId_examenOnly = await prisma.examen.updateManyAndReturn({
     *   select: { id_examen: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends examenUpdateManyAndReturnArgs>(args: SelectSubset<T, examenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Examen.
     * @param {examenUpsertArgs} args - Arguments to update or create a Examen.
     * @example
     * // Update or create a Examen
     * const examen = await prisma.examen.upsert({
     *   create: {
     *     // ... data to create a Examen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examen we want to update
     *   }
     * })
     */
    upsert<T extends examenUpsertArgs>(args: SelectSubset<T, examenUpsertArgs<ExtArgs>>): Prisma__examenClient<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenCountArgs} args - Arguments to filter Examen to count.
     * @example
     * // Count the number of Examen
     * const count = await prisma.examen.count({
     *   where: {
     *     // ... the filter for the Examen we want to count
     *   }
     * })
    **/
    count<T extends examenCountArgs>(
      args?: Subset<T, examenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenAggregateArgs>(args: Subset<T, ExamenAggregateArgs>): Prisma.PrismaPromise<GetExamenAggregateType<T>>

    /**
     * Group by Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examenGroupByArgs['orderBy'] }
        : { orderBy?: examenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the examen model
   */
  readonly fields: examenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for examen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paciente<T extends examen$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, examen$pacienteArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the examen model
   */
  interface examenFieldRefs {
    readonly id_examen: FieldRef<"examen", 'Int'>
    readonly tipoexamen: FieldRef<"examen", 'String'>
    readonly rutaExamen: FieldRef<"examen", 'String'>
    readonly id_paciente: FieldRef<"examen", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * examen findUnique
   */
  export type examenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter, which examen to fetch.
     */
    where: examenWhereUniqueInput
  }

  /**
   * examen findUniqueOrThrow
   */
  export type examenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter, which examen to fetch.
     */
    where: examenWhereUniqueInput
  }

  /**
   * examen findFirst
   */
  export type examenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter, which examen to fetch.
     */
    where?: examenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examen to fetch.
     */
    orderBy?: examenOrderByWithRelationInput | examenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examen.
     */
    cursor?: examenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * examen findFirstOrThrow
   */
  export type examenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter, which examen to fetch.
     */
    where?: examenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examen to fetch.
     */
    orderBy?: examenOrderByWithRelationInput | examenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examen.
     */
    cursor?: examenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * examen findMany
   */
  export type examenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter, which examen to fetch.
     */
    where?: examenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examen to fetch.
     */
    orderBy?: examenOrderByWithRelationInput | examenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examen.
     */
    cursor?: examenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examen.
     */
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * examen create
   */
  export type examenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * The data needed to create a examen.
     */
    data?: XOR<examenCreateInput, examenUncheckedCreateInput>
  }

  /**
   * examen createMany
   */
  export type examenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many examen.
     */
    data: examenCreateManyInput | examenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * examen createManyAndReturn
   */
  export type examenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * The data used to create many examen.
     */
    data: examenCreateManyInput | examenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * examen update
   */
  export type examenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * The data needed to update a examen.
     */
    data: XOR<examenUpdateInput, examenUncheckedUpdateInput>
    /**
     * Choose, which examen to update.
     */
    where: examenWhereUniqueInput
  }

  /**
   * examen updateMany
   */
  export type examenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update examen.
     */
    data: XOR<examenUpdateManyMutationInput, examenUncheckedUpdateManyInput>
    /**
     * Filter which examen to update
     */
    where?: examenWhereInput
    /**
     * Limit how many examen to update.
     */
    limit?: number
  }

  /**
   * examen updateManyAndReturn
   */
  export type examenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * The data used to update examen.
     */
    data: XOR<examenUpdateManyMutationInput, examenUncheckedUpdateManyInput>
    /**
     * Filter which examen to update
     */
    where?: examenWhereInput
    /**
     * Limit how many examen to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * examen upsert
   */
  export type examenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * The filter to search for the examen to update in case it exists.
     */
    where: examenWhereUniqueInput
    /**
     * In case the examen found by the `where` argument doesn't exist, create a new examen with this data.
     */
    create: XOR<examenCreateInput, examenUncheckedCreateInput>
    /**
     * In case the examen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examenUpdateInput, examenUncheckedUpdateInput>
  }

  /**
   * examen delete
   */
  export type examenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    /**
     * Filter which examen to delete.
     */
    where: examenWhereUniqueInput
  }

  /**
   * examen deleteMany
   */
  export type examenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examen to delete
     */
    where?: examenWhereInput
    /**
     * Limit how many examen to delete.
     */
    limit?: number
  }

  /**
   * examen.paciente
   */
  export type examen$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    where?: pacienteWhereInput
  }

  /**
   * examen without action
   */
  export type examenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
  }


  /**
   * Model medicamento
   */

  export type AggregateMedicamento = {
    _count: MedicamentoCountAggregateOutputType | null
    _avg: MedicamentoAvgAggregateOutputType | null
    _sum: MedicamentoSumAggregateOutputType | null
    _min: MedicamentoMinAggregateOutputType | null
    _max: MedicamentoMaxAggregateOutputType | null
  }

  export type MedicamentoAvgAggregateOutputType = {
    id_medicamento: number | null
    id_proveedor: number | null
  }

  export type MedicamentoSumAggregateOutputType = {
    id_medicamento: number | null
    id_proveedor: number | null
  }

  export type MedicamentoMinAggregateOutputType = {
    id_medicamento: number | null
    nombre: string | null
    tipo: string | null
    descripcion: string | null
    id_proveedor: number | null
  }

  export type MedicamentoMaxAggregateOutputType = {
    id_medicamento: number | null
    nombre: string | null
    tipo: string | null
    descripcion: string | null
    id_proveedor: number | null
  }

  export type MedicamentoCountAggregateOutputType = {
    id_medicamento: number
    nombre: number
    tipo: number
    descripcion: number
    id_proveedor: number
    _all: number
  }


  export type MedicamentoAvgAggregateInputType = {
    id_medicamento?: true
    id_proveedor?: true
  }

  export type MedicamentoSumAggregateInputType = {
    id_medicamento?: true
    id_proveedor?: true
  }

  export type MedicamentoMinAggregateInputType = {
    id_medicamento?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    id_proveedor?: true
  }

  export type MedicamentoMaxAggregateInputType = {
    id_medicamento?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    id_proveedor?: true
  }

  export type MedicamentoCountAggregateInputType = {
    id_medicamento?: true
    nombre?: true
    tipo?: true
    descripcion?: true
    id_proveedor?: true
    _all?: true
  }

  export type MedicamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicamento to aggregate.
     */
    where?: medicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicamentos to fetch.
     */
    orderBy?: medicamentoOrderByWithRelationInput | medicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicamentos
    **/
    _count?: true | MedicamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicamentoMaxAggregateInputType
  }

  export type GetMedicamentoAggregateType<T extends MedicamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicamento[P]>
      : GetScalarType<T[P], AggregateMedicamento[P]>
  }




  export type medicamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicamentoWhereInput
    orderBy?: medicamentoOrderByWithAggregationInput | medicamentoOrderByWithAggregationInput[]
    by: MedicamentoScalarFieldEnum[] | MedicamentoScalarFieldEnum
    having?: medicamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicamentoCountAggregateInputType | true
    _avg?: MedicamentoAvgAggregateInputType
    _sum?: MedicamentoSumAggregateInputType
    _min?: MedicamentoMinAggregateInputType
    _max?: MedicamentoMaxAggregateInputType
  }

  export type MedicamentoGroupByOutputType = {
    id_medicamento: number
    nombre: string | null
    tipo: string | null
    descripcion: string | null
    id_proveedor: number | null
    _count: MedicamentoCountAggregateOutputType | null
    _avg: MedicamentoAvgAggregateOutputType | null
    _sum: MedicamentoSumAggregateOutputType | null
    _min: MedicamentoMinAggregateOutputType | null
    _max: MedicamentoMaxAggregateOutputType | null
  }

  type GetMedicamentoGroupByPayload<T extends medicamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicamentoGroupByOutputType[P]>
            : GetScalarType<T[P], MedicamentoGroupByOutputType[P]>
        }
      >
    >


  export type medicamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medicamento?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    id_proveedor?: boolean
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["medicamento"]>

  export type medicamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medicamento?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    id_proveedor?: boolean
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["medicamento"]>

  export type medicamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medicamento?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    id_proveedor?: boolean
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["medicamento"]>

  export type medicamentoSelectScalar = {
    id_medicamento?: boolean
    nombre?: boolean
    tipo?: boolean
    descripcion?: boolean
    id_proveedor?: boolean
  }

  export type medicamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_medicamento" | "nombre" | "tipo" | "descripcion" | "id_proveedor", ExtArgs["result"]["medicamento"]>
  export type medicamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }
  export type medicamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }
  export type medicamentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | medicamento$proveedorArgs<ExtArgs>
  }

  export type $medicamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicamento"
    objects: {
      proveedor: Prisma.$proveedorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_medicamento: number
      nombre: string | null
      tipo: string | null
      descripcion: string | null
      id_proveedor: number | null
    }, ExtArgs["result"]["medicamento"]>
    composites: {}
  }

  type medicamentoGetPayload<S extends boolean | null | undefined | medicamentoDefaultArgs> = $Result.GetResult<Prisma.$medicamentoPayload, S>

  type medicamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medicamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicamentoCountAggregateInputType | true
    }

  export interface medicamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicamento'], meta: { name: 'medicamento' } }
    /**
     * Find zero or one Medicamento that matches the filter.
     * @param {medicamentoFindUniqueArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicamentoFindUniqueArgs>(args: SelectSubset<T, medicamentoFindUniqueArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medicamentoFindUniqueOrThrowArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, medicamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoFindFirstArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicamentoFindFirstArgs>(args?: SelectSubset<T, medicamentoFindFirstArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoFindFirstOrThrowArgs} args - Arguments to find a Medicamento
     * @example
     * // Get one Medicamento
     * const medicamento = await prisma.medicamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, medicamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicamentos
     * const medicamentos = await prisma.medicamento.findMany()
     * 
     * // Get first 10 Medicamentos
     * const medicamentos = await prisma.medicamento.findMany({ take: 10 })
     * 
     * // Only select the `id_medicamento`
     * const medicamentoWithId_medicamentoOnly = await prisma.medicamento.findMany({ select: { id_medicamento: true } })
     * 
     */
    findMany<T extends medicamentoFindManyArgs>(args?: SelectSubset<T, medicamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicamento.
     * @param {medicamentoCreateArgs} args - Arguments to create a Medicamento.
     * @example
     * // Create one Medicamento
     * const Medicamento = await prisma.medicamento.create({
     *   data: {
     *     // ... data to create a Medicamento
     *   }
     * })
     * 
     */
    create<T extends medicamentoCreateArgs>(args: SelectSubset<T, medicamentoCreateArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicamentos.
     * @param {medicamentoCreateManyArgs} args - Arguments to create many Medicamentos.
     * @example
     * // Create many Medicamentos
     * const medicamento = await prisma.medicamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicamentoCreateManyArgs>(args?: SelectSubset<T, medicamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicamentos and returns the data saved in the database.
     * @param {medicamentoCreateManyAndReturnArgs} args - Arguments to create many Medicamentos.
     * @example
     * // Create many Medicamentos
     * const medicamento = await prisma.medicamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicamentos and only return the `id_medicamento`
     * const medicamentoWithId_medicamentoOnly = await prisma.medicamento.createManyAndReturn({
     *   select: { id_medicamento: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medicamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, medicamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medicamento.
     * @param {medicamentoDeleteArgs} args - Arguments to delete one Medicamento.
     * @example
     * // Delete one Medicamento
     * const Medicamento = await prisma.medicamento.delete({
     *   where: {
     *     // ... filter to delete one Medicamento
     *   }
     * })
     * 
     */
    delete<T extends medicamentoDeleteArgs>(args: SelectSubset<T, medicamentoDeleteArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicamento.
     * @param {medicamentoUpdateArgs} args - Arguments to update one Medicamento.
     * @example
     * // Update one Medicamento
     * const medicamento = await prisma.medicamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicamentoUpdateArgs>(args: SelectSubset<T, medicamentoUpdateArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicamentos.
     * @param {medicamentoDeleteManyArgs} args - Arguments to filter Medicamentos to delete.
     * @example
     * // Delete a few Medicamentos
     * const { count } = await prisma.medicamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicamentoDeleteManyArgs>(args?: SelectSubset<T, medicamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicamentos
     * const medicamento = await prisma.medicamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicamentoUpdateManyArgs>(args: SelectSubset<T, medicamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicamentos and returns the data updated in the database.
     * @param {medicamentoUpdateManyAndReturnArgs} args - Arguments to update many Medicamentos.
     * @example
     * // Update many Medicamentos
     * const medicamento = await prisma.medicamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicamentos and only return the `id_medicamento`
     * const medicamentoWithId_medicamentoOnly = await prisma.medicamento.updateManyAndReturn({
     *   select: { id_medicamento: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends medicamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, medicamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medicamento.
     * @param {medicamentoUpsertArgs} args - Arguments to update or create a Medicamento.
     * @example
     * // Update or create a Medicamento
     * const medicamento = await prisma.medicamento.upsert({
     *   create: {
     *     // ... data to create a Medicamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicamento we want to update
     *   }
     * })
     */
    upsert<T extends medicamentoUpsertArgs>(args: SelectSubset<T, medicamentoUpsertArgs<ExtArgs>>): Prisma__medicamentoClient<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoCountArgs} args - Arguments to filter Medicamentos to count.
     * @example
     * // Count the number of Medicamentos
     * const count = await prisma.medicamento.count({
     *   where: {
     *     // ... the filter for the Medicamentos we want to count
     *   }
     * })
    **/
    count<T extends medicamentoCountArgs>(
      args?: Subset<T, medicamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicamentoAggregateArgs>(args: Subset<T, MedicamentoAggregateArgs>): Prisma.PrismaPromise<GetMedicamentoAggregateType<T>>

    /**
     * Group by Medicamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicamentoGroupByArgs['orderBy'] }
        : { orderBy?: medicamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicamento model
   */
  readonly fields: medicamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proveedor<T extends medicamento$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, medicamento$proveedorArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicamento model
   */
  interface medicamentoFieldRefs {
    readonly id_medicamento: FieldRef<"medicamento", 'Int'>
    readonly nombre: FieldRef<"medicamento", 'String'>
    readonly tipo: FieldRef<"medicamento", 'String'>
    readonly descripcion: FieldRef<"medicamento", 'String'>
    readonly id_proveedor: FieldRef<"medicamento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * medicamento findUnique
   */
  export type medicamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter, which medicamento to fetch.
     */
    where: medicamentoWhereUniqueInput
  }

  /**
   * medicamento findUniqueOrThrow
   */
  export type medicamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter, which medicamento to fetch.
     */
    where: medicamentoWhereUniqueInput
  }

  /**
   * medicamento findFirst
   */
  export type medicamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter, which medicamento to fetch.
     */
    where?: medicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicamentos to fetch.
     */
    orderBy?: medicamentoOrderByWithRelationInput | medicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicamentos.
     */
    cursor?: medicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicamentos.
     */
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * medicamento findFirstOrThrow
   */
  export type medicamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter, which medicamento to fetch.
     */
    where?: medicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicamentos to fetch.
     */
    orderBy?: medicamentoOrderByWithRelationInput | medicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicamentos.
     */
    cursor?: medicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicamentos.
     */
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * medicamento findMany
   */
  export type medicamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter, which medicamentos to fetch.
     */
    where?: medicamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicamentos to fetch.
     */
    orderBy?: medicamentoOrderByWithRelationInput | medicamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicamentos.
     */
    cursor?: medicamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicamentos.
     */
    skip?: number
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * medicamento create
   */
  export type medicamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a medicamento.
     */
    data?: XOR<medicamentoCreateInput, medicamentoUncheckedCreateInput>
  }

  /**
   * medicamento createMany
   */
  export type medicamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicamentos.
     */
    data: medicamentoCreateManyInput | medicamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicamento createManyAndReturn
   */
  export type medicamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * The data used to create many medicamentos.
     */
    data: medicamentoCreateManyInput | medicamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicamento update
   */
  export type medicamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a medicamento.
     */
    data: XOR<medicamentoUpdateInput, medicamentoUncheckedUpdateInput>
    /**
     * Choose, which medicamento to update.
     */
    where: medicamentoWhereUniqueInput
  }

  /**
   * medicamento updateMany
   */
  export type medicamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicamentos.
     */
    data: XOR<medicamentoUpdateManyMutationInput, medicamentoUncheckedUpdateManyInput>
    /**
     * Filter which medicamentos to update
     */
    where?: medicamentoWhereInput
    /**
     * Limit how many medicamentos to update.
     */
    limit?: number
  }

  /**
   * medicamento updateManyAndReturn
   */
  export type medicamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * The data used to update medicamentos.
     */
    data: XOR<medicamentoUpdateManyMutationInput, medicamentoUncheckedUpdateManyInput>
    /**
     * Filter which medicamentos to update
     */
    where?: medicamentoWhereInput
    /**
     * Limit how many medicamentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicamento upsert
   */
  export type medicamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the medicamento to update in case it exists.
     */
    where: medicamentoWhereUniqueInput
    /**
     * In case the medicamento found by the `where` argument doesn't exist, create a new medicamento with this data.
     */
    create: XOR<medicamentoCreateInput, medicamentoUncheckedCreateInput>
    /**
     * In case the medicamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicamentoUpdateInput, medicamentoUncheckedUpdateInput>
  }

  /**
   * medicamento delete
   */
  export type medicamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    /**
     * Filter which medicamento to delete.
     */
    where: medicamentoWhereUniqueInput
  }

  /**
   * medicamento deleteMany
   */
  export type medicamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicamentos to delete
     */
    where?: medicamentoWhereInput
    /**
     * Limit how many medicamentos to delete.
     */
    limit?: number
  }

  /**
   * medicamento.proveedor
   */
  export type medicamento$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    where?: proveedorWhereInput
  }

  /**
   * medicamento without action
   */
  export type medicamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
  }


  /**
   * Model paciente
   */

  export type AggregatePaciente = {
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  export type PacienteAvgAggregateOutputType = {
    id_paciente: number | null
    id_usuario: number | null
    altura: number | null
    peso: number | null
  }

  export type PacienteSumAggregateOutputType = {
    id_paciente: number | null
    id_usuario: number | null
    altura: number | null
    peso: number | null
  }

  export type PacienteMinAggregateOutputType = {
    id_paciente: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    altura: number | null
    peso: number | null
    sexo: string | null
    tiposangre: string | null
    telefono: string | null
    correo: string | null
  }

  export type PacienteMaxAggregateOutputType = {
    id_paciente: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    altura: number | null
    peso: number | null
    sexo: string | null
    tiposangre: string | null
    telefono: string | null
    correo: string | null
  }

  export type PacienteCountAggregateOutputType = {
    id_paciente: number
    nombre: number
    segundonombre: number
    primerapellido: number
    segundoapellido: number
    nacimiento: number
    id_usuario: number
    altura: number
    peso: number
    sexo: number
    tiposangre: number
    telefono: number
    correo: number
    _all: number
  }


  export type PacienteAvgAggregateInputType = {
    id_paciente?: true
    id_usuario?: true
    altura?: true
    peso?: true
  }

  export type PacienteSumAggregateInputType = {
    id_paciente?: true
    id_usuario?: true
    altura?: true
    peso?: true
  }

  export type PacienteMinAggregateInputType = {
    id_paciente?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    altura?: true
    peso?: true
    sexo?: true
    tiposangre?: true
    telefono?: true
    correo?: true
  }

  export type PacienteMaxAggregateInputType = {
    id_paciente?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    altura?: true
    peso?: true
    sexo?: true
    tiposangre?: true
    telefono?: true
    correo?: true
  }

  export type PacienteCountAggregateInputType = {
    id_paciente?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    id_usuario?: true
    altura?: true
    peso?: true
    sexo?: true
    tiposangre?: true
    telefono?: true
    correo?: true
    _all?: true
  }

  export type PacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paciente to aggregate.
     */
    where?: pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacienteOrderByWithRelationInput | pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pacientes
    **/
    _count?: true | PacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacienteMaxAggregateInputType
  }

  export type GetPacienteAggregateType<T extends PacienteAggregateArgs> = {
        [P in keyof T & keyof AggregatePaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaciente[P]>
      : GetScalarType<T[P], AggregatePaciente[P]>
  }




  export type pacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacienteWhereInput
    orderBy?: pacienteOrderByWithAggregationInput | pacienteOrderByWithAggregationInput[]
    by: PacienteScalarFieldEnum[] | PacienteScalarFieldEnum
    having?: pacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacienteCountAggregateInputType | true
    _avg?: PacienteAvgAggregateInputType
    _sum?: PacienteSumAggregateInputType
    _min?: PacienteMinAggregateInputType
    _max?: PacienteMaxAggregateInputType
  }

  export type PacienteGroupByOutputType = {
    id_paciente: number
    nombre: string
    segundonombre: string | null
    primerapellido: string
    segundoapellido: string | null
    nacimiento: Date | null
    id_usuario: number | null
    altura: number | null
    peso: number | null
    sexo: string | null
    tiposangre: string | null
    telefono: string | null
    correo: string | null
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  type GetPacienteGroupByPayload<T extends pacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacienteGroupByOutputType[P]>
            : GetScalarType<T[P], PacienteGroupByOutputType[P]>
        }
      >
    >


  export type pacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    altura?: boolean
    peso?: boolean
    sexo?: boolean
    tiposangre?: boolean
    telefono?: boolean
    correo?: boolean
    cita?: boolean | paciente$citaArgs<ExtArgs>
    examen?: boolean | paciente$examenArgs<ExtArgs>
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
    pago?: boolean | paciente$pagoArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type pacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    altura?: boolean
    peso?: boolean
    sexo?: boolean
    tiposangre?: boolean
    telefono?: boolean
    correo?: boolean
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type pacienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    altura?: boolean
    peso?: boolean
    sexo?: boolean
    tiposangre?: boolean
    telefono?: boolean
    correo?: boolean
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type pacienteSelectScalar = {
    id_paciente?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    id_usuario?: boolean
    altura?: boolean
    peso?: boolean
    sexo?: boolean
    tiposangre?: boolean
    telefono?: boolean
    correo?: boolean
  }

  export type pacienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_paciente" | "nombre" | "segundonombre" | "primerapellido" | "segundoapellido" | "nacimiento" | "id_usuario" | "altura" | "peso" | "sexo" | "tiposangre" | "telefono" | "correo", ExtArgs["result"]["paciente"]>
  export type pacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cita?: boolean | paciente$citaArgs<ExtArgs>
    examen?: boolean | paciente$examenArgs<ExtArgs>
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
    pago?: boolean | paciente$pagoArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
  }
  export type pacienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | paciente$usuarioArgs<ExtArgs>
  }

  export type $pacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paciente"
    objects: {
      cita: Prisma.$citaPayload<ExtArgs>[]
      examen: Prisma.$examenPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
      pago: Prisma.$pagoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paciente: number
      nombre: string
      segundonombre: string | null
      primerapellido: string
      segundoapellido: string | null
      nacimiento: Date | null
      id_usuario: number | null
      altura: number | null
      peso: number | null
      sexo: string | null
      tiposangre: string | null
      telefono: string | null
      correo: string | null
    }, ExtArgs["result"]["paciente"]>
    composites: {}
  }

  type pacienteGetPayload<S extends boolean | null | undefined | pacienteDefaultArgs> = $Result.GetResult<Prisma.$pacientePayload, S>

  type pacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pacienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PacienteCountAggregateInputType | true
    }

  export interface pacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paciente'], meta: { name: 'paciente' } }
    /**
     * Find zero or one Paciente that matches the filter.
     * @param {pacienteFindUniqueArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pacienteFindUniqueArgs>(args: SelectSubset<T, pacienteFindUniqueArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paciente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pacienteFindUniqueOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, pacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteFindFirstArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pacienteFindFirstArgs>(args?: SelectSubset<T, pacienteFindFirstArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteFindFirstOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, pacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacientes
     * const pacientes = await prisma.paciente.findMany()
     * 
     * // Get first 10 Pacientes
     * const pacientes = await prisma.paciente.findMany({ take: 10 })
     * 
     * // Only select the `id_paciente`
     * const pacienteWithId_pacienteOnly = await prisma.paciente.findMany({ select: { id_paciente: true } })
     * 
     */
    findMany<T extends pacienteFindManyArgs>(args?: SelectSubset<T, pacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paciente.
     * @param {pacienteCreateArgs} args - Arguments to create a Paciente.
     * @example
     * // Create one Paciente
     * const Paciente = await prisma.paciente.create({
     *   data: {
     *     // ... data to create a Paciente
     *   }
     * })
     * 
     */
    create<T extends pacienteCreateArgs>(args: SelectSubset<T, pacienteCreateArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pacientes.
     * @param {pacienteCreateManyArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const paciente = await prisma.paciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pacienteCreateManyArgs>(args?: SelectSubset<T, pacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pacientes and returns the data saved in the database.
     * @param {pacienteCreateManyAndReturnArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const paciente = await prisma.paciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pacientes and only return the `id_paciente`
     * const pacienteWithId_pacienteOnly = await prisma.paciente.createManyAndReturn({
     *   select: { id_paciente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, pacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paciente.
     * @param {pacienteDeleteArgs} args - Arguments to delete one Paciente.
     * @example
     * // Delete one Paciente
     * const Paciente = await prisma.paciente.delete({
     *   where: {
     *     // ... filter to delete one Paciente
     *   }
     * })
     * 
     */
    delete<T extends pacienteDeleteArgs>(args: SelectSubset<T, pacienteDeleteArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paciente.
     * @param {pacienteUpdateArgs} args - Arguments to update one Paciente.
     * @example
     * // Update one Paciente
     * const paciente = await prisma.paciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pacienteUpdateArgs>(args: SelectSubset<T, pacienteUpdateArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pacientes.
     * @param {pacienteDeleteManyArgs} args - Arguments to filter Pacientes to delete.
     * @example
     * // Delete a few Pacientes
     * const { count } = await prisma.paciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pacienteDeleteManyArgs>(args?: SelectSubset<T, pacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacientes
     * const paciente = await prisma.paciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pacienteUpdateManyArgs>(args: SelectSubset<T, pacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes and returns the data updated in the database.
     * @param {pacienteUpdateManyAndReturnArgs} args - Arguments to update many Pacientes.
     * @example
     * // Update many Pacientes
     * const paciente = await prisma.paciente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pacientes and only return the `id_paciente`
     * const pacienteWithId_pacienteOnly = await prisma.paciente.updateManyAndReturn({
     *   select: { id_paciente: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pacienteUpdateManyAndReturnArgs>(args: SelectSubset<T, pacienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paciente.
     * @param {pacienteUpsertArgs} args - Arguments to update or create a Paciente.
     * @example
     * // Update or create a Paciente
     * const paciente = await prisma.paciente.upsert({
     *   create: {
     *     // ... data to create a Paciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paciente we want to update
     *   }
     * })
     */
    upsert<T extends pacienteUpsertArgs>(args: SelectSubset<T, pacienteUpsertArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteCountArgs} args - Arguments to filter Pacientes to count.
     * @example
     * // Count the number of Pacientes
     * const count = await prisma.paciente.count({
     *   where: {
     *     // ... the filter for the Pacientes we want to count
     *   }
     * })
    **/
    count<T extends pacienteCountArgs>(
      args?: Subset<T, pacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacienteAggregateArgs>(args: Subset<T, PacienteAggregateArgs>): Prisma.PrismaPromise<GetPacienteAggregateType<T>>

    /**
     * Group by Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pacienteGroupByArgs['orderBy'] }
        : { orderBy?: pacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paciente model
   */
  readonly fields: pacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cita<T extends paciente$citaArgs<ExtArgs> = {}>(args?: Subset<T, paciente$citaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examen<T extends paciente$examenArgs<ExtArgs> = {}>(args?: Subset<T, paciente$examenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario<T extends paciente$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, paciente$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pago<T extends paciente$pagoArgs<ExtArgs> = {}>(args?: Subset<T, paciente$pagoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paciente model
   */
  interface pacienteFieldRefs {
    readonly id_paciente: FieldRef<"paciente", 'Int'>
    readonly nombre: FieldRef<"paciente", 'String'>
    readonly segundonombre: FieldRef<"paciente", 'String'>
    readonly primerapellido: FieldRef<"paciente", 'String'>
    readonly segundoapellido: FieldRef<"paciente", 'String'>
    readonly nacimiento: FieldRef<"paciente", 'DateTime'>
    readonly id_usuario: FieldRef<"paciente", 'Int'>
    readonly altura: FieldRef<"paciente", 'Float'>
    readonly peso: FieldRef<"paciente", 'Float'>
    readonly sexo: FieldRef<"paciente", 'String'>
    readonly tiposangre: FieldRef<"paciente", 'String'>
    readonly telefono: FieldRef<"paciente", 'String'>
    readonly correo: FieldRef<"paciente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * paciente findUnique
   */
  export type pacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter, which paciente to fetch.
     */
    where: pacienteWhereUniqueInput
  }

  /**
   * paciente findUniqueOrThrow
   */
  export type pacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter, which paciente to fetch.
     */
    where: pacienteWhereUniqueInput
  }

  /**
   * paciente findFirst
   */
  export type pacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter, which paciente to fetch.
     */
    where?: pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacienteOrderByWithRelationInput | pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * paciente findFirstOrThrow
   */
  export type pacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter, which paciente to fetch.
     */
    where?: pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacienteOrderByWithRelationInput | pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * paciente findMany
   */
  export type pacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacienteOrderByWithRelationInput | pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pacientes.
     */
    cursor?: pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * paciente create
   */
  export type pacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a paciente.
     */
    data: XOR<pacienteCreateInput, pacienteUncheckedCreateInput>
  }

  /**
   * paciente createMany
   */
  export type pacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pacientes.
     */
    data: pacienteCreateManyInput | pacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paciente createManyAndReturn
   */
  export type pacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * The data used to create many pacientes.
     */
    data: pacienteCreateManyInput | pacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paciente update
   */
  export type pacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a paciente.
     */
    data: XOR<pacienteUpdateInput, pacienteUncheckedUpdateInput>
    /**
     * Choose, which paciente to update.
     */
    where: pacienteWhereUniqueInput
  }

  /**
   * paciente updateMany
   */
  export type pacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pacientes.
     */
    data: XOR<pacienteUpdateManyMutationInput, pacienteUncheckedUpdateManyInput>
    /**
     * Filter which pacientes to update
     */
    where?: pacienteWhereInput
    /**
     * Limit how many pacientes to update.
     */
    limit?: number
  }

  /**
   * paciente updateManyAndReturn
   */
  export type pacienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * The data used to update pacientes.
     */
    data: XOR<pacienteUpdateManyMutationInput, pacienteUncheckedUpdateManyInput>
    /**
     * Filter which pacientes to update
     */
    where?: pacienteWhereInput
    /**
     * Limit how many pacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * paciente upsert
   */
  export type pacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the paciente to update in case it exists.
     */
    where: pacienteWhereUniqueInput
    /**
     * In case the paciente found by the `where` argument doesn't exist, create a new paciente with this data.
     */
    create: XOR<pacienteCreateInput, pacienteUncheckedCreateInput>
    /**
     * In case the paciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pacienteUpdateInput, pacienteUncheckedUpdateInput>
  }

  /**
   * paciente delete
   */
  export type pacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    /**
     * Filter which paciente to delete.
     */
    where: pacienteWhereUniqueInput
  }

  /**
   * paciente deleteMany
   */
  export type pacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacientes to delete
     */
    where?: pacienteWhereInput
    /**
     * Limit how many pacientes to delete.
     */
    limit?: number
  }

  /**
   * paciente.cita
   */
  export type paciente$citaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cita
     */
    select?: citaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cita
     */
    omit?: citaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citaInclude<ExtArgs> | null
    where?: citaWhereInput
    orderBy?: citaOrderByWithRelationInput | citaOrderByWithRelationInput[]
    cursor?: citaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * paciente.examen
   */
  export type paciente$examenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examen
     */
    select?: examenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examen
     */
    omit?: examenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenInclude<ExtArgs> | null
    where?: examenWhereInput
    orderBy?: examenOrderByWithRelationInput | examenOrderByWithRelationInput[]
    cursor?: examenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * paciente.usuario
   */
  export type paciente$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * paciente.pago
   */
  export type paciente$pagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    where?: pagoWhereInput
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    cursor?: pagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * paciente without action
   */
  export type pacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
  }


  /**
   * Model pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    id_pago: number | null
    id_paciente: number | null
    monto: number | null
  }

  export type PagoSumAggregateOutputType = {
    id_pago: number | null
    id_paciente: number | null
    monto: number | null
  }

  export type PagoMinAggregateOutputType = {
    id_pago: number | null
    id_paciente: number | null
    tipopago: string | null
    monto: number | null
    fechapago: Date | null
  }

  export type PagoMaxAggregateOutputType = {
    id_pago: number | null
    id_paciente: number | null
    tipopago: string | null
    monto: number | null
    fechapago: Date | null
  }

  export type PagoCountAggregateOutputType = {
    id_pago: number
    id_paciente: number
    tipopago: number
    monto: number
    fechapago: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    id_pago?: true
    id_paciente?: true
    monto?: true
  }

  export type PagoSumAggregateInputType = {
    id_pago?: true
    id_paciente?: true
    monto?: true
  }

  export type PagoMinAggregateInputType = {
    id_pago?: true
    id_paciente?: true
    tipopago?: true
    monto?: true
    fechapago?: true
  }

  export type PagoMaxAggregateInputType = {
    id_pago?: true
    id_paciente?: true
    tipopago?: true
    monto?: true
    fechapago?: true
  }

  export type PagoCountAggregateInputType = {
    id_pago?: true
    id_paciente?: true
    tipopago?: true
    monto?: true
    fechapago?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pago to aggregate.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type pagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagoWhereInput
    orderBy?: pagoOrderByWithAggregationInput | pagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    id_pago: number
    id_paciente: number
    tipopago: string
    monto: number
    fechapago: Date | null
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type pagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_paciente?: boolean
    tipopago?: boolean
    monto?: boolean
    fechapago?: boolean
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type pagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_paciente?: boolean
    tipopago?: boolean
    monto?: boolean
    fechapago?: boolean
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type pagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pago?: boolean
    id_paciente?: boolean
    tipopago?: boolean
    monto?: boolean
    fechapago?: boolean
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type pagoSelectScalar = {
    id_pago?: boolean
    id_paciente?: boolean
    tipopago?: boolean
    monto?: boolean
    fechapago?: boolean
  }

  export type pagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pago" | "id_paciente" | "tipopago" | "monto" | "fechapago", ExtArgs["result"]["pago"]>
  export type pagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }
  export type pagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }
  export type pagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | pacienteDefaultArgs<ExtArgs>
  }

  export type $pagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pago"
    objects: {
      paciente: Prisma.$pacientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pago: number
      id_paciente: number
      tipopago: string
      monto: number
      fechapago: Date | null
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }

  type pagoGetPayload<S extends boolean | null | undefined | pagoDefaultArgs> = $Result.GetResult<Prisma.$pagoPayload, S>

  type pagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoCountAggregateInputType | true
    }

  export interface pagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pago'], meta: { name: 'pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {pagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagoFindUniqueArgs>(args: SelectSubset<T, pagoFindUniqueArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagoFindUniqueOrThrowArgs>(args: SelectSubset<T, pagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagoFindFirstArgs>(args?: SelectSubset<T, pagoFindFirstArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagoFindFirstOrThrowArgs>(args?: SelectSubset<T, pagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.findMany({ select: { id_pago: true } })
     * 
     */
    findMany<T extends pagoFindManyArgs>(args?: SelectSubset<T, pagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pago.
     * @param {pagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
     */
    create<T extends pagoCreateArgs>(args: SelectSubset<T, pagoCreateArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagos.
     * @param {pagoCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagoCreateManyArgs>(args?: SelectSubset<T, pagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagos and returns the data saved in the database.
     * @param {pagoCreateManyAndReturnArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagos and only return the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.createManyAndReturn({
     *   select: { id_pago: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pagoCreateManyAndReturnArgs>(args?: SelectSubset<T, pagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pago.
     * @param {pagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
     */
    delete<T extends pagoDeleteArgs>(args: SelectSubset<T, pagoDeleteArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pago.
     * @param {pagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagoUpdateArgs>(args: SelectSubset<T, pagoUpdateArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagos.
     * @param {pagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagoDeleteManyArgs>(args?: SelectSubset<T, pagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagoUpdateManyArgs>(args: SelectSubset<T, pagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos and returns the data updated in the database.
     * @param {pagoUpdateManyAndReturnArgs} args - Arguments to update many Pagos.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagos and only return the `id_pago`
     * const pagoWithId_pagoOnly = await prisma.pago.updateManyAndReturn({
     *   select: { id_pago: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pagoUpdateManyAndReturnArgs>(args: SelectSubset<T, pagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pago.
     * @param {pagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
     */
    upsert<T extends pagoUpsertArgs>(args: SelectSubset<T, pagoUpsertArgs<ExtArgs>>): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends pagoCountArgs>(
      args?: Subset<T, pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagoGroupByArgs['orderBy'] }
        : { orderBy?: pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pago model
   */
  readonly fields: pagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paciente<T extends pacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pacienteDefaultArgs<ExtArgs>>): Prisma__pacienteClient<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pago model
   */
  interface pagoFieldRefs {
    readonly id_pago: FieldRef<"pago", 'Int'>
    readonly id_paciente: FieldRef<"pago", 'Int'>
    readonly tipopago: FieldRef<"pago", 'String'>
    readonly monto: FieldRef<"pago", 'Float'>
    readonly fechapago: FieldRef<"pago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pago findUnique
   */
  export type pagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where: pagoWhereUniqueInput
  }

  /**
   * pago findUniqueOrThrow
   */
  export type pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where: pagoWhereUniqueInput
  }

  /**
   * pago findFirst
   */
  export type pagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * pago findFirstOrThrow
   */
  export type pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * pago findMany
   */
  export type pagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pagos to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * pago create
   */
  export type pagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The data needed to create a pago.
     */
    data: XOR<pagoCreateInput, pagoUncheckedCreateInput>
  }

  /**
   * pago createMany
   */
  export type pagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pagos.
     */
    data: pagoCreateManyInput | pagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pago createManyAndReturn
   */
  export type pagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * The data used to create many pagos.
     */
    data: pagoCreateManyInput | pagoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pago update
   */
  export type pagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The data needed to update a pago.
     */
    data: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
    /**
     * Choose, which pago to update.
     */
    where: pagoWhereUniqueInput
  }

  /**
   * pago updateMany
   */
  export type pagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pagos.
     */
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyInput>
    /**
     * Filter which pagos to update
     */
    where?: pagoWhereInput
    /**
     * Limit how many pagos to update.
     */
    limit?: number
  }

  /**
   * pago updateManyAndReturn
   */
  export type pagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * The data used to update pagos.
     */
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyInput>
    /**
     * Filter which pagos to update
     */
    where?: pagoWhereInput
    /**
     * Limit how many pagos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pago upsert
   */
  export type pagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The filter to search for the pago to update in case it exists.
     */
    where: pagoWhereUniqueInput
    /**
     * In case the pago found by the `where` argument doesn't exist, create a new pago with this data.
     */
    create: XOR<pagoCreateInput, pagoUncheckedCreateInput>
    /**
     * In case the pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
  }

  /**
   * pago delete
   */
  export type pagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter which pago to delete.
     */
    where: pagoWhereUniqueInput
  }

  /**
   * pago deleteMany
   */
  export type pagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagos to delete
     */
    where?: pagoWhereInput
    /**
     * Limit how many pagos to delete.
     */
    limit?: number
  }

  /**
   * pago without action
   */
  export type pagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pago
     */
    omit?: pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagoInclude<ExtArgs> | null
  }


  /**
   * Model prescripcion
   */

  export type AggregatePrescripcion = {
    _count: PrescripcionCountAggregateOutputType | null
    _avg: PrescripcionAvgAggregateOutputType | null
    _sum: PrescripcionSumAggregateOutputType | null
    _min: PrescripcionMinAggregateOutputType | null
    _max: PrescripcionMaxAggregateOutputType | null
  }

  export type PrescripcionAvgAggregateOutputType = {
    id_prescripcion: number | null
    id_medicamento: number | null
    id_receta: number | null
  }

  export type PrescripcionSumAggregateOutputType = {
    id_prescripcion: number | null
    id_medicamento: number | null
    id_receta: number | null
  }

  export type PrescripcionMinAggregateOutputType = {
    id_prescripcion: number | null
    dosisrecomendada: string | null
    tipo: string | null
    frecuencia: string | null
    id_medicamento: number | null
    id_receta: number | null
  }

  export type PrescripcionMaxAggregateOutputType = {
    id_prescripcion: number | null
    dosisrecomendada: string | null
    tipo: string | null
    frecuencia: string | null
    id_medicamento: number | null
    id_receta: number | null
  }

  export type PrescripcionCountAggregateOutputType = {
    id_prescripcion: number
    dosisrecomendada: number
    tipo: number
    frecuencia: number
    id_medicamento: number
    id_receta: number
    _all: number
  }


  export type PrescripcionAvgAggregateInputType = {
    id_prescripcion?: true
    id_medicamento?: true
    id_receta?: true
  }

  export type PrescripcionSumAggregateInputType = {
    id_prescripcion?: true
    id_medicamento?: true
    id_receta?: true
  }

  export type PrescripcionMinAggregateInputType = {
    id_prescripcion?: true
    dosisrecomendada?: true
    tipo?: true
    frecuencia?: true
    id_medicamento?: true
    id_receta?: true
  }

  export type PrescripcionMaxAggregateInputType = {
    id_prescripcion?: true
    dosisrecomendada?: true
    tipo?: true
    frecuencia?: true
    id_medicamento?: true
    id_receta?: true
  }

  export type PrescripcionCountAggregateInputType = {
    id_prescripcion?: true
    dosisrecomendada?: true
    tipo?: true
    frecuencia?: true
    id_medicamento?: true
    id_receta?: true
    _all?: true
  }

  export type PrescripcionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescripcion to aggregate.
     */
    where?: prescripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescripcions to fetch.
     */
    orderBy?: prescripcionOrderByWithRelationInput | prescripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prescripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prescripcions
    **/
    _count?: true | PrescripcionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescripcionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescripcionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescripcionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescripcionMaxAggregateInputType
  }

  export type GetPrescripcionAggregateType<T extends PrescripcionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescripcion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescripcion[P]>
      : GetScalarType<T[P], AggregatePrescripcion[P]>
  }




  export type prescripcionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prescripcionWhereInput
    orderBy?: prescripcionOrderByWithAggregationInput | prescripcionOrderByWithAggregationInput[]
    by: PrescripcionScalarFieldEnum[] | PrescripcionScalarFieldEnum
    having?: prescripcionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescripcionCountAggregateInputType | true
    _avg?: PrescripcionAvgAggregateInputType
    _sum?: PrescripcionSumAggregateInputType
    _min?: PrescripcionMinAggregateInputType
    _max?: PrescripcionMaxAggregateInputType
  }

  export type PrescripcionGroupByOutputType = {
    id_prescripcion: number
    dosisrecomendada: string | null
    tipo: string | null
    frecuencia: string | null
    id_medicamento: number | null
    id_receta: number | null
    _count: PrescripcionCountAggregateOutputType | null
    _avg: PrescripcionAvgAggregateOutputType | null
    _sum: PrescripcionSumAggregateOutputType | null
    _min: PrescripcionMinAggregateOutputType | null
    _max: PrescripcionMaxAggregateOutputType | null
  }

  type GetPrescripcionGroupByPayload<T extends prescripcionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescripcionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescripcionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescripcionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescripcionGroupByOutputType[P]>
        }
      >
    >


  export type prescripcionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prescripcion?: boolean
    dosisrecomendada?: boolean
    tipo?: boolean
    frecuencia?: boolean
    id_medicamento?: boolean
    id_receta?: boolean
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }, ExtArgs["result"]["prescripcion"]>

  export type prescripcionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prescripcion?: boolean
    dosisrecomendada?: boolean
    tipo?: boolean
    frecuencia?: boolean
    id_medicamento?: boolean
    id_receta?: boolean
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }, ExtArgs["result"]["prescripcion"]>

  export type prescripcionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prescripcion?: boolean
    dosisrecomendada?: boolean
    tipo?: boolean
    frecuencia?: boolean
    id_medicamento?: boolean
    id_receta?: boolean
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }, ExtArgs["result"]["prescripcion"]>

  export type prescripcionSelectScalar = {
    id_prescripcion?: boolean
    dosisrecomendada?: boolean
    tipo?: boolean
    frecuencia?: boolean
    id_medicamento?: boolean
    id_receta?: boolean
  }

  export type prescripcionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_prescripcion" | "dosisrecomendada" | "tipo" | "frecuencia" | "id_medicamento" | "id_receta", ExtArgs["result"]["prescripcion"]>
  export type prescripcionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }
  export type prescripcionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }
  export type prescripcionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receta?: boolean | prescripcion$recetaArgs<ExtArgs>
  }

  export type $prescripcionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prescripcion"
    objects: {
      receta: Prisma.$recetaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_prescripcion: number
      dosisrecomendada: string | null
      tipo: string | null
      frecuencia: string | null
      id_medicamento: number | null
      id_receta: number | null
    }, ExtArgs["result"]["prescripcion"]>
    composites: {}
  }

  type prescripcionGetPayload<S extends boolean | null | undefined | prescripcionDefaultArgs> = $Result.GetResult<Prisma.$prescripcionPayload, S>

  type prescripcionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<prescripcionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescripcionCountAggregateInputType | true
    }

  export interface prescripcionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prescripcion'], meta: { name: 'prescripcion' } }
    /**
     * Find zero or one Prescripcion that matches the filter.
     * @param {prescripcionFindUniqueArgs} args - Arguments to find a Prescripcion
     * @example
     * // Get one Prescripcion
     * const prescripcion = await prisma.prescripcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prescripcionFindUniqueArgs>(args: SelectSubset<T, prescripcionFindUniqueArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescripcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {prescripcionFindUniqueOrThrowArgs} args - Arguments to find a Prescripcion
     * @example
     * // Get one Prescripcion
     * const prescripcion = await prisma.prescripcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prescripcionFindUniqueOrThrowArgs>(args: SelectSubset<T, prescripcionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescripcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionFindFirstArgs} args - Arguments to find a Prescripcion
     * @example
     * // Get one Prescripcion
     * const prescripcion = await prisma.prescripcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prescripcionFindFirstArgs>(args?: SelectSubset<T, prescripcionFindFirstArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescripcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionFindFirstOrThrowArgs} args - Arguments to find a Prescripcion
     * @example
     * // Get one Prescripcion
     * const prescripcion = await prisma.prescripcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prescripcionFindFirstOrThrowArgs>(args?: SelectSubset<T, prescripcionFindFirstOrThrowArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescripcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescripcions
     * const prescripcions = await prisma.prescripcion.findMany()
     * 
     * // Get first 10 Prescripcions
     * const prescripcions = await prisma.prescripcion.findMany({ take: 10 })
     * 
     * // Only select the `id_prescripcion`
     * const prescripcionWithId_prescripcionOnly = await prisma.prescripcion.findMany({ select: { id_prescripcion: true } })
     * 
     */
    findMany<T extends prescripcionFindManyArgs>(args?: SelectSubset<T, prescripcionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescripcion.
     * @param {prescripcionCreateArgs} args - Arguments to create a Prescripcion.
     * @example
     * // Create one Prescripcion
     * const Prescripcion = await prisma.prescripcion.create({
     *   data: {
     *     // ... data to create a Prescripcion
     *   }
     * })
     * 
     */
    create<T extends prescripcionCreateArgs>(args: SelectSubset<T, prescripcionCreateArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescripcions.
     * @param {prescripcionCreateManyArgs} args - Arguments to create many Prescripcions.
     * @example
     * // Create many Prescripcions
     * const prescripcion = await prisma.prescripcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prescripcionCreateManyArgs>(args?: SelectSubset<T, prescripcionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescripcions and returns the data saved in the database.
     * @param {prescripcionCreateManyAndReturnArgs} args - Arguments to create many Prescripcions.
     * @example
     * // Create many Prescripcions
     * const prescripcion = await prisma.prescripcion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescripcions and only return the `id_prescripcion`
     * const prescripcionWithId_prescripcionOnly = await prisma.prescripcion.createManyAndReturn({
     *   select: { id_prescripcion: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prescripcionCreateManyAndReturnArgs>(args?: SelectSubset<T, prescripcionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescripcion.
     * @param {prescripcionDeleteArgs} args - Arguments to delete one Prescripcion.
     * @example
     * // Delete one Prescripcion
     * const Prescripcion = await prisma.prescripcion.delete({
     *   where: {
     *     // ... filter to delete one Prescripcion
     *   }
     * })
     * 
     */
    delete<T extends prescripcionDeleteArgs>(args: SelectSubset<T, prescripcionDeleteArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescripcion.
     * @param {prescripcionUpdateArgs} args - Arguments to update one Prescripcion.
     * @example
     * // Update one Prescripcion
     * const prescripcion = await prisma.prescripcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prescripcionUpdateArgs>(args: SelectSubset<T, prescripcionUpdateArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescripcions.
     * @param {prescripcionDeleteManyArgs} args - Arguments to filter Prescripcions to delete.
     * @example
     * // Delete a few Prescripcions
     * const { count } = await prisma.prescripcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prescripcionDeleteManyArgs>(args?: SelectSubset<T, prescripcionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescripcions
     * const prescripcion = await prisma.prescripcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prescripcionUpdateManyArgs>(args: SelectSubset<T, prescripcionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescripcions and returns the data updated in the database.
     * @param {prescripcionUpdateManyAndReturnArgs} args - Arguments to update many Prescripcions.
     * @example
     * // Update many Prescripcions
     * const prescripcion = await prisma.prescripcion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescripcions and only return the `id_prescripcion`
     * const prescripcionWithId_prescripcionOnly = await prisma.prescripcion.updateManyAndReturn({
     *   select: { id_prescripcion: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends prescripcionUpdateManyAndReturnArgs>(args: SelectSubset<T, prescripcionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescripcion.
     * @param {prescripcionUpsertArgs} args - Arguments to update or create a Prescripcion.
     * @example
     * // Update or create a Prescripcion
     * const prescripcion = await prisma.prescripcion.upsert({
     *   create: {
     *     // ... data to create a Prescripcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescripcion we want to update
     *   }
     * })
     */
    upsert<T extends prescripcionUpsertArgs>(args: SelectSubset<T, prescripcionUpsertArgs<ExtArgs>>): Prisma__prescripcionClient<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionCountArgs} args - Arguments to filter Prescripcions to count.
     * @example
     * // Count the number of Prescripcions
     * const count = await prisma.prescripcion.count({
     *   where: {
     *     // ... the filter for the Prescripcions we want to count
     *   }
     * })
    **/
    count<T extends prescripcionCountArgs>(
      args?: Subset<T, prescripcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescripcionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescripcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescripcionAggregateArgs>(args: Subset<T, PrescripcionAggregateArgs>): Prisma.PrismaPromise<GetPrescripcionAggregateType<T>>

    /**
     * Group by Prescripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescripcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prescripcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prescripcionGroupByArgs['orderBy'] }
        : { orderBy?: prescripcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prescripcionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescripcionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prescripcion model
   */
  readonly fields: prescripcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prescripcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prescripcionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receta<T extends prescripcion$recetaArgs<ExtArgs> = {}>(args?: Subset<T, prescripcion$recetaArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prescripcion model
   */
  interface prescripcionFieldRefs {
    readonly id_prescripcion: FieldRef<"prescripcion", 'Int'>
    readonly dosisrecomendada: FieldRef<"prescripcion", 'String'>
    readonly tipo: FieldRef<"prescripcion", 'String'>
    readonly frecuencia: FieldRef<"prescripcion", 'String'>
    readonly id_medicamento: FieldRef<"prescripcion", 'Int'>
    readonly id_receta: FieldRef<"prescripcion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * prescripcion findUnique
   */
  export type prescripcionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter, which prescripcion to fetch.
     */
    where: prescripcionWhereUniqueInput
  }

  /**
   * prescripcion findUniqueOrThrow
   */
  export type prescripcionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter, which prescripcion to fetch.
     */
    where: prescripcionWhereUniqueInput
  }

  /**
   * prescripcion findFirst
   */
  export type prescripcionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter, which prescripcion to fetch.
     */
    where?: prescripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescripcions to fetch.
     */
    orderBy?: prescripcionOrderByWithRelationInput | prescripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescripcions.
     */
    cursor?: prescripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescripcions.
     */
    distinct?: PrescripcionScalarFieldEnum | PrescripcionScalarFieldEnum[]
  }

  /**
   * prescripcion findFirstOrThrow
   */
  export type prescripcionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter, which prescripcion to fetch.
     */
    where?: prescripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescripcions to fetch.
     */
    orderBy?: prescripcionOrderByWithRelationInput | prescripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescripcions.
     */
    cursor?: prescripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescripcions.
     */
    distinct?: PrescripcionScalarFieldEnum | PrescripcionScalarFieldEnum[]
  }

  /**
   * prescripcion findMany
   */
  export type prescripcionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter, which prescripcions to fetch.
     */
    where?: prescripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescripcions to fetch.
     */
    orderBy?: prescripcionOrderByWithRelationInput | prescripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prescripcions.
     */
    cursor?: prescripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescripcions.
     */
    skip?: number
    distinct?: PrescripcionScalarFieldEnum | PrescripcionScalarFieldEnum[]
  }

  /**
   * prescripcion create
   */
  export type prescripcionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * The data needed to create a prescripcion.
     */
    data?: XOR<prescripcionCreateInput, prescripcionUncheckedCreateInput>
  }

  /**
   * prescripcion createMany
   */
  export type prescripcionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prescripcions.
     */
    data: prescripcionCreateManyInput | prescripcionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prescripcion createManyAndReturn
   */
  export type prescripcionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * The data used to create many prescripcions.
     */
    data: prescripcionCreateManyInput | prescripcionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * prescripcion update
   */
  export type prescripcionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * The data needed to update a prescripcion.
     */
    data: XOR<prescripcionUpdateInput, prescripcionUncheckedUpdateInput>
    /**
     * Choose, which prescripcion to update.
     */
    where: prescripcionWhereUniqueInput
  }

  /**
   * prescripcion updateMany
   */
  export type prescripcionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prescripcions.
     */
    data: XOR<prescripcionUpdateManyMutationInput, prescripcionUncheckedUpdateManyInput>
    /**
     * Filter which prescripcions to update
     */
    where?: prescripcionWhereInput
    /**
     * Limit how many prescripcions to update.
     */
    limit?: number
  }

  /**
   * prescripcion updateManyAndReturn
   */
  export type prescripcionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * The data used to update prescripcions.
     */
    data: XOR<prescripcionUpdateManyMutationInput, prescripcionUncheckedUpdateManyInput>
    /**
     * Filter which prescripcions to update
     */
    where?: prescripcionWhereInput
    /**
     * Limit how many prescripcions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * prescripcion upsert
   */
  export type prescripcionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * The filter to search for the prescripcion to update in case it exists.
     */
    where: prescripcionWhereUniqueInput
    /**
     * In case the prescripcion found by the `where` argument doesn't exist, create a new prescripcion with this data.
     */
    create: XOR<prescripcionCreateInput, prescripcionUncheckedCreateInput>
    /**
     * In case the prescripcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prescripcionUpdateInput, prescripcionUncheckedUpdateInput>
  }

  /**
   * prescripcion delete
   */
  export type prescripcionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    /**
     * Filter which prescripcion to delete.
     */
    where: prescripcionWhereUniqueInput
  }

  /**
   * prescripcion deleteMany
   */
  export type prescripcionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescripcions to delete
     */
    where?: prescripcionWhereInput
    /**
     * Limit how many prescripcions to delete.
     */
    limit?: number
  }

  /**
   * prescripcion.receta
   */
  export type prescripcion$recetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    where?: recetaWhereInput
  }

  /**
   * prescripcion without action
   */
  export type prescripcionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
  }


  /**
   * Model proveedor
   */

  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    id_proveedor: number | null
    id_direccion: number | null
    id_usuario: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    id_proveedor: number | null
    id_direccion: number | null
    id_usuario: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    id_proveedor: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_direccion: number | null
    id_usuario: number | null
    tipoproveedor: string | null
    estado: boolean | null
  }

  export type ProveedorMaxAggregateOutputType = {
    id_proveedor: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_direccion: number | null
    id_usuario: number | null
    tipoproveedor: string | null
    estado: boolean | null
  }

  export type ProveedorCountAggregateOutputType = {
    id_proveedor: number
    nombre: number
    segundonombre: number
    primerapellido: number
    segundoapellido: number
    nacimiento: number
    celular: number
    telefono: number
    id_direccion: number
    id_usuario: number
    tipoproveedor: number
    estado: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    id_proveedor?: true
    id_direccion?: true
    id_usuario?: true
  }

  export type ProveedorSumAggregateInputType = {
    id_proveedor?: true
    id_direccion?: true
    id_usuario?: true
  }

  export type ProveedorMinAggregateInputType = {
    id_proveedor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_direccion?: true
    id_usuario?: true
    tipoproveedor?: true
    estado?: true
  }

  export type ProveedorMaxAggregateInputType = {
    id_proveedor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_direccion?: true
    id_usuario?: true
    tipoproveedor?: true
    estado?: true
  }

  export type ProveedorCountAggregateInputType = {
    id_proveedor?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    celular?: true
    telefono?: true
    id_direccion?: true
    id_usuario?: true
    tipoproveedor?: true
    estado?: true
    _all?: true
  }

  export type ProveedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedor to aggregate.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type proveedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedorWhereInput
    orderBy?: proveedorOrderByWithAggregationInput | proveedorOrderByWithAggregationInput[]
    by: ProveedorScalarFieldEnum[] | ProveedorScalarFieldEnum
    having?: proveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }

  export type ProveedorGroupByOutputType = {
    id_proveedor: number
    nombre: string
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    celular: string | null
    telefono: string | null
    id_direccion: number | null
    id_usuario: number | null
    tipoproveedor: string | null
    estado: boolean | null
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends proveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type proveedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proveedor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_direccion?: boolean
    id_usuario?: boolean
    tipoproveedor?: boolean
    estado?: boolean
    medicamento?: boolean | proveedor$medicamentoArgs<ExtArgs>
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type proveedorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proveedor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_direccion?: boolean
    id_usuario?: boolean
    tipoproveedor?: boolean
    estado?: boolean
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type proveedorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proveedor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_direccion?: boolean
    id_usuario?: boolean
    tipoproveedor?: boolean
    estado?: boolean
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type proveedorSelectScalar = {
    id_proveedor?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    celular?: boolean
    telefono?: boolean
    id_direccion?: boolean
    id_usuario?: boolean
    tipoproveedor?: boolean
    estado?: boolean
  }

  export type proveedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_proveedor" | "nombre" | "segundonombre" | "primerapellido" | "segundoapellido" | "nacimiento" | "celular" | "telefono" | "id_direccion" | "id_usuario" | "tipoproveedor" | "estado", ExtArgs["result"]["proveedor"]>
  export type proveedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicamento?: boolean | proveedor$medicamentoArgs<ExtArgs>
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type proveedorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
  }
  export type proveedorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | proveedor$usuarioArgs<ExtArgs>
  }

  export type $proveedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proveedor"
    objects: {
      medicamento: Prisma.$medicamentoPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_proveedor: number
      nombre: string
      segundonombre: string | null
      primerapellido: string | null
      segundoapellido: string | null
      nacimiento: Date | null
      celular: string | null
      telefono: string | null
      id_direccion: number | null
      id_usuario: number | null
      tipoproveedor: string | null
      estado: boolean | null
    }, ExtArgs["result"]["proveedor"]>
    composites: {}
  }

  type proveedorGetPayload<S extends boolean | null | undefined | proveedorDefaultArgs> = $Result.GetResult<Prisma.$proveedorPayload, S>

  type proveedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<proveedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface proveedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedor'], meta: { name: 'proveedor' } }
    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {proveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proveedorFindUniqueArgs>(args: SelectSubset<T, proveedorFindUniqueArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proveedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {proveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proveedorFindUniqueOrThrowArgs>(args: SelectSubset<T, proveedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proveedorFindFirstArgs>(args?: SelectSubset<T, proveedorFindFirstArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proveedorFindFirstOrThrowArgs>(args?: SelectSubset<T, proveedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `id_proveedor`
     * const proveedorWithId_proveedorOnly = await prisma.proveedor.findMany({ select: { id_proveedor: true } })
     * 
     */
    findMany<T extends proveedorFindManyArgs>(args?: SelectSubset<T, proveedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proveedor.
     * @param {proveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
     */
    create<T extends proveedorCreateArgs>(args: SelectSubset<T, proveedorCreateArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proveedors.
     * @param {proveedorCreateManyArgs} args - Arguments to create many Proveedors.
     * @example
     * // Create many Proveedors
     * const proveedor = await prisma.proveedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proveedorCreateManyArgs>(args?: SelectSubset<T, proveedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proveedors and returns the data saved in the database.
     * @param {proveedorCreateManyAndReturnArgs} args - Arguments to create many Proveedors.
     * @example
     * // Create many Proveedors
     * const proveedor = await prisma.proveedor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proveedors and only return the `id_proveedor`
     * const proveedorWithId_proveedorOnly = await prisma.proveedor.createManyAndReturn({
     *   select: { id_proveedor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proveedorCreateManyAndReturnArgs>(args?: SelectSubset<T, proveedorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proveedor.
     * @param {proveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
     */
    delete<T extends proveedorDeleteArgs>(args: SelectSubset<T, proveedorDeleteArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proveedor.
     * @param {proveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proveedorUpdateArgs>(args: SelectSubset<T, proveedorUpdateArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proveedors.
     * @param {proveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proveedorDeleteManyArgs>(args?: SelectSubset<T, proveedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proveedorUpdateManyArgs>(args: SelectSubset<T, proveedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors and returns the data updated in the database.
     * @param {proveedorUpdateManyAndReturnArgs} args - Arguments to update many Proveedors.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proveedors and only return the `id_proveedor`
     * const proveedorWithId_proveedorOnly = await prisma.proveedor.updateManyAndReturn({
     *   select: { id_proveedor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends proveedorUpdateManyAndReturnArgs>(args: SelectSubset<T, proveedorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proveedor.
     * @param {proveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
     */
    upsert<T extends proveedorUpsertArgs>(args: SelectSubset<T, proveedorUpsertArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends proveedorCountArgs>(
      args?: Subset<T, proveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedorGroupByArgs['orderBy'] }
        : { orderBy?: proveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proveedor model
   */
  readonly fields: proveedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proveedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicamento<T extends proveedor$medicamentoArgs<ExtArgs> = {}>(args?: Subset<T, proveedor$medicamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario<T extends proveedor$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, proveedor$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proveedor model
   */
  interface proveedorFieldRefs {
    readonly id_proveedor: FieldRef<"proveedor", 'Int'>
    readonly nombre: FieldRef<"proveedor", 'String'>
    readonly segundonombre: FieldRef<"proveedor", 'String'>
    readonly primerapellido: FieldRef<"proveedor", 'String'>
    readonly segundoapellido: FieldRef<"proveedor", 'String'>
    readonly nacimiento: FieldRef<"proveedor", 'DateTime'>
    readonly celular: FieldRef<"proveedor", 'String'>
    readonly telefono: FieldRef<"proveedor", 'String'>
    readonly id_direccion: FieldRef<"proveedor", 'Int'>
    readonly id_usuario: FieldRef<"proveedor", 'Int'>
    readonly tipoproveedor: FieldRef<"proveedor", 'String'>
    readonly estado: FieldRef<"proveedor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * proveedor findUnique
   */
  export type proveedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }

  /**
   * proveedor findUniqueOrThrow
   */
  export type proveedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }

  /**
   * proveedor findFirst
   */
  export type proveedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * proveedor findFirstOrThrow
   */
  export type proveedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * proveedor findMany
   */
  export type proveedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedors to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * proveedor create
   */
  export type proveedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to create a proveedor.
     */
    data: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
  }

  /**
   * proveedor createMany
   */
  export type proveedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedors.
     */
    data: proveedorCreateManyInput | proveedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proveedor createManyAndReturn
   */
  export type proveedorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * The data used to create many proveedors.
     */
    data: proveedorCreateManyInput | proveedorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * proveedor update
   */
  export type proveedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to update a proveedor.
     */
    data: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
    /**
     * Choose, which proveedor to update.
     */
    where: proveedorWhereUniqueInput
  }

  /**
   * proveedor updateMany
   */
  export type proveedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedors.
     */
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyInput>
    /**
     * Filter which proveedors to update
     */
    where?: proveedorWhereInput
    /**
     * Limit how many proveedors to update.
     */
    limit?: number
  }

  /**
   * proveedor updateManyAndReturn
   */
  export type proveedorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * The data used to update proveedors.
     */
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyInput>
    /**
     * Filter which proveedors to update
     */
    where?: proveedorWhereInput
    /**
     * Limit how many proveedors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * proveedor upsert
   */
  export type proveedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The filter to search for the proveedor to update in case it exists.
     */
    where: proveedorWhereUniqueInput
    /**
     * In case the proveedor found by the `where` argument doesn't exist, create a new proveedor with this data.
     */
    create: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
    /**
     * In case the proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
  }

  /**
   * proveedor delete
   */
  export type proveedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter which proveedor to delete.
     */
    where: proveedorWhereUniqueInput
  }

  /**
   * proveedor deleteMany
   */
  export type proveedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedors to delete
     */
    where?: proveedorWhereInput
    /**
     * Limit how many proveedors to delete.
     */
    limit?: number
  }

  /**
   * proveedor.medicamento
   */
  export type proveedor$medicamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicamento
     */
    select?: medicamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicamento
     */
    omit?: medicamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicamentoInclude<ExtArgs> | null
    where?: medicamentoWhereInput
    orderBy?: medicamentoOrderByWithRelationInput | medicamentoOrderByWithRelationInput[]
    cursor?: medicamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicamentoScalarFieldEnum | MedicamentoScalarFieldEnum[]
  }

  /**
   * proveedor.usuario
   */
  export type proveedor$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * proveedor without action
   */
  export type proveedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
  }


  /**
   * Model receta
   */

  export type AggregateReceta = {
    _count: RecetaCountAggregateOutputType | null
    _avg: RecetaAvgAggregateOutputType | null
    _sum: RecetaSumAggregateOutputType | null
    _min: RecetaMinAggregateOutputType | null
    _max: RecetaMaxAggregateOutputType | null
  }

  export type RecetaAvgAggregateOutputType = {
    id_receta: number | null
    id_tratamiento: number | null
  }

  export type RecetaSumAggregateOutputType = {
    id_receta: number | null
    id_tratamiento: number | null
  }

  export type RecetaMinAggregateOutputType = {
    id_receta: number | null
    fechaemision: Date | null
    dosisrecomendada: string | null
    id_tratamiento: number | null
  }

  export type RecetaMaxAggregateOutputType = {
    id_receta: number | null
    fechaemision: Date | null
    dosisrecomendada: string | null
    id_tratamiento: number | null
  }

  export type RecetaCountAggregateOutputType = {
    id_receta: number
    fechaemision: number
    dosisrecomendada: number
    id_tratamiento: number
    _all: number
  }


  export type RecetaAvgAggregateInputType = {
    id_receta?: true
    id_tratamiento?: true
  }

  export type RecetaSumAggregateInputType = {
    id_receta?: true
    id_tratamiento?: true
  }

  export type RecetaMinAggregateInputType = {
    id_receta?: true
    fechaemision?: true
    dosisrecomendada?: true
    id_tratamiento?: true
  }

  export type RecetaMaxAggregateInputType = {
    id_receta?: true
    fechaemision?: true
    dosisrecomendada?: true
    id_tratamiento?: true
  }

  export type RecetaCountAggregateInputType = {
    id_receta?: true
    fechaemision?: true
    dosisrecomendada?: true
    id_tratamiento?: true
    _all?: true
  }

  export type RecetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receta to aggregate.
     */
    where?: recetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetaOrderByWithRelationInput | recetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recetas
    **/
    _count?: true | RecetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetaMaxAggregateInputType
  }

  export type GetRecetaAggregateType<T extends RecetaAggregateArgs> = {
        [P in keyof T & keyof AggregateReceta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceta[P]>
      : GetScalarType<T[P], AggregateReceta[P]>
  }




  export type recetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetaWhereInput
    orderBy?: recetaOrderByWithAggregationInput | recetaOrderByWithAggregationInput[]
    by: RecetaScalarFieldEnum[] | RecetaScalarFieldEnum
    having?: recetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetaCountAggregateInputType | true
    _avg?: RecetaAvgAggregateInputType
    _sum?: RecetaSumAggregateInputType
    _min?: RecetaMinAggregateInputType
    _max?: RecetaMaxAggregateInputType
  }

  export type RecetaGroupByOutputType = {
    id_receta: number
    fechaemision: Date | null
    dosisrecomendada: string | null
    id_tratamiento: number | null
    _count: RecetaCountAggregateOutputType | null
    _avg: RecetaAvgAggregateOutputType | null
    _sum: RecetaSumAggregateOutputType | null
    _min: RecetaMinAggregateOutputType | null
    _max: RecetaMaxAggregateOutputType | null
  }

  type GetRecetaGroupByPayload<T extends recetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetaGroupByOutputType[P]>
            : GetScalarType<T[P], RecetaGroupByOutputType[P]>
        }
      >
    >


  export type recetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_receta?: boolean
    fechaemision?: boolean
    dosisrecomendada?: boolean
    id_tratamiento?: boolean
    prescripcion?: boolean | receta$prescripcionArgs<ExtArgs>
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
    _count?: boolean | RecetaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type recetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_receta?: boolean
    fechaemision?: boolean
    dosisrecomendada?: boolean
    id_tratamiento?: boolean
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type recetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_receta?: boolean
    fechaemision?: boolean
    dosisrecomendada?: boolean
    id_tratamiento?: boolean
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type recetaSelectScalar = {
    id_receta?: boolean
    fechaemision?: boolean
    dosisrecomendada?: boolean
    id_tratamiento?: boolean
  }

  export type recetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_receta" | "fechaemision" | "dosisrecomendada" | "id_tratamiento", ExtArgs["result"]["receta"]>
  export type recetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescripcion?: boolean | receta$prescripcionArgs<ExtArgs>
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
    _count?: boolean | RecetaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type recetaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
  }
  export type recetaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tratamiento?: boolean | receta$tratamientoArgs<ExtArgs>
  }

  export type $recetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "receta"
    objects: {
      prescripcion: Prisma.$prescripcionPayload<ExtArgs>[]
      tratamiento: Prisma.$tratamientoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_receta: number
      fechaemision: Date | null
      dosisrecomendada: string | null
      id_tratamiento: number | null
    }, ExtArgs["result"]["receta"]>
    composites: {}
  }

  type recetaGetPayload<S extends boolean | null | undefined | recetaDefaultArgs> = $Result.GetResult<Prisma.$recetaPayload, S>

  type recetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecetaCountAggregateInputType | true
    }

  export interface recetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['receta'], meta: { name: 'receta' } }
    /**
     * Find zero or one Receta that matches the filter.
     * @param {recetaFindUniqueArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recetaFindUniqueArgs>(args: SelectSubset<T, recetaFindUniqueArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recetaFindUniqueOrThrowArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recetaFindUniqueOrThrowArgs>(args: SelectSubset<T, recetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaFindFirstArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recetaFindFirstArgs>(args?: SelectSubset<T, recetaFindFirstArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaFindFirstOrThrowArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recetaFindFirstOrThrowArgs>(args?: SelectSubset<T, recetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recetas
     * const recetas = await prisma.receta.findMany()
     * 
     * // Get first 10 Recetas
     * const recetas = await prisma.receta.findMany({ take: 10 })
     * 
     * // Only select the `id_receta`
     * const recetaWithId_recetaOnly = await prisma.receta.findMany({ select: { id_receta: true } })
     * 
     */
    findMany<T extends recetaFindManyArgs>(args?: SelectSubset<T, recetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receta.
     * @param {recetaCreateArgs} args - Arguments to create a Receta.
     * @example
     * // Create one Receta
     * const Receta = await prisma.receta.create({
     *   data: {
     *     // ... data to create a Receta
     *   }
     * })
     * 
     */
    create<T extends recetaCreateArgs>(args: SelectSubset<T, recetaCreateArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recetas.
     * @param {recetaCreateManyArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const receta = await prisma.receta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recetaCreateManyArgs>(args?: SelectSubset<T, recetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recetas and returns the data saved in the database.
     * @param {recetaCreateManyAndReturnArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const receta = await prisma.receta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recetas and only return the `id_receta`
     * const recetaWithId_recetaOnly = await prisma.receta.createManyAndReturn({
     *   select: { id_receta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recetaCreateManyAndReturnArgs>(args?: SelectSubset<T, recetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receta.
     * @param {recetaDeleteArgs} args - Arguments to delete one Receta.
     * @example
     * // Delete one Receta
     * const Receta = await prisma.receta.delete({
     *   where: {
     *     // ... filter to delete one Receta
     *   }
     * })
     * 
     */
    delete<T extends recetaDeleteArgs>(args: SelectSubset<T, recetaDeleteArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receta.
     * @param {recetaUpdateArgs} args - Arguments to update one Receta.
     * @example
     * // Update one Receta
     * const receta = await prisma.receta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recetaUpdateArgs>(args: SelectSubset<T, recetaUpdateArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recetas.
     * @param {recetaDeleteManyArgs} args - Arguments to filter Recetas to delete.
     * @example
     * // Delete a few Recetas
     * const { count } = await prisma.receta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recetaDeleteManyArgs>(args?: SelectSubset<T, recetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recetas
     * const receta = await prisma.receta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recetaUpdateManyArgs>(args: SelectSubset<T, recetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetas and returns the data updated in the database.
     * @param {recetaUpdateManyAndReturnArgs} args - Arguments to update many Recetas.
     * @example
     * // Update many Recetas
     * const receta = await prisma.receta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recetas and only return the `id_receta`
     * const recetaWithId_recetaOnly = await prisma.receta.updateManyAndReturn({
     *   select: { id_receta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recetaUpdateManyAndReturnArgs>(args: SelectSubset<T, recetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receta.
     * @param {recetaUpsertArgs} args - Arguments to update or create a Receta.
     * @example
     * // Update or create a Receta
     * const receta = await prisma.receta.upsert({
     *   create: {
     *     // ... data to create a Receta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receta we want to update
     *   }
     * })
     */
    upsert<T extends recetaUpsertArgs>(args: SelectSubset<T, recetaUpsertArgs<ExtArgs>>): Prisma__recetaClient<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaCountArgs} args - Arguments to filter Recetas to count.
     * @example
     * // Count the number of Recetas
     * const count = await prisma.receta.count({
     *   where: {
     *     // ... the filter for the Recetas we want to count
     *   }
     * })
    **/
    count<T extends recetaCountArgs>(
      args?: Subset<T, recetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetaAggregateArgs>(args: Subset<T, RecetaAggregateArgs>): Prisma.PrismaPromise<GetRecetaAggregateType<T>>

    /**
     * Group by Receta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recetaGroupByArgs['orderBy'] }
        : { orderBy?: recetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the receta model
   */
  readonly fields: recetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for receta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescripcion<T extends receta$prescripcionArgs<ExtArgs> = {}>(args?: Subset<T, receta$prescripcionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tratamiento<T extends receta$tratamientoArgs<ExtArgs> = {}>(args?: Subset<T, receta$tratamientoArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the receta model
   */
  interface recetaFieldRefs {
    readonly id_receta: FieldRef<"receta", 'Int'>
    readonly fechaemision: FieldRef<"receta", 'DateTime'>
    readonly dosisrecomendada: FieldRef<"receta", 'String'>
    readonly id_tratamiento: FieldRef<"receta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * receta findUnique
   */
  export type recetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter, which receta to fetch.
     */
    where: recetaWhereUniqueInput
  }

  /**
   * receta findUniqueOrThrow
   */
  export type recetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter, which receta to fetch.
     */
    where: recetaWhereUniqueInput
  }

  /**
   * receta findFirst
   */
  export type recetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter, which receta to fetch.
     */
    where?: recetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetaOrderByWithRelationInput | recetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetas.
     */
    cursor?: recetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetas.
     */
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * receta findFirstOrThrow
   */
  export type recetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter, which receta to fetch.
     */
    where?: recetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetaOrderByWithRelationInput | recetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetas.
     */
    cursor?: recetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetas.
     */
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * receta findMany
   */
  export type recetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where?: recetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetaOrderByWithRelationInput | recetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recetas.
     */
    cursor?: recetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * receta create
   */
  export type recetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * The data needed to create a receta.
     */
    data?: XOR<recetaCreateInput, recetaUncheckedCreateInput>
  }

  /**
   * receta createMany
   */
  export type recetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recetas.
     */
    data: recetaCreateManyInput | recetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * receta createManyAndReturn
   */
  export type recetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * The data used to create many recetas.
     */
    data: recetaCreateManyInput | recetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * receta update
   */
  export type recetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * The data needed to update a receta.
     */
    data: XOR<recetaUpdateInput, recetaUncheckedUpdateInput>
    /**
     * Choose, which receta to update.
     */
    where: recetaWhereUniqueInput
  }

  /**
   * receta updateMany
   */
  export type recetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recetas.
     */
    data: XOR<recetaUpdateManyMutationInput, recetaUncheckedUpdateManyInput>
    /**
     * Filter which recetas to update
     */
    where?: recetaWhereInput
    /**
     * Limit how many recetas to update.
     */
    limit?: number
  }

  /**
   * receta updateManyAndReturn
   */
  export type recetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * The data used to update recetas.
     */
    data: XOR<recetaUpdateManyMutationInput, recetaUncheckedUpdateManyInput>
    /**
     * Filter which recetas to update
     */
    where?: recetaWhereInput
    /**
     * Limit how many recetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * receta upsert
   */
  export type recetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * The filter to search for the receta to update in case it exists.
     */
    where: recetaWhereUniqueInput
    /**
     * In case the receta found by the `where` argument doesn't exist, create a new receta with this data.
     */
    create: XOR<recetaCreateInput, recetaUncheckedCreateInput>
    /**
     * In case the receta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recetaUpdateInput, recetaUncheckedUpdateInput>
  }

  /**
   * receta delete
   */
  export type recetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    /**
     * Filter which receta to delete.
     */
    where: recetaWhereUniqueInput
  }

  /**
   * receta deleteMany
   */
  export type recetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recetas to delete
     */
    where?: recetaWhereInput
    /**
     * Limit how many recetas to delete.
     */
    limit?: number
  }

  /**
   * receta.prescripcion
   */
  export type receta$prescripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescripcion
     */
    select?: prescripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescripcion
     */
    omit?: prescripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prescripcionInclude<ExtArgs> | null
    where?: prescripcionWhereInput
    orderBy?: prescripcionOrderByWithRelationInput | prescripcionOrderByWithRelationInput[]
    cursor?: prescripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescripcionScalarFieldEnum | PrescripcionScalarFieldEnum[]
  }

  /**
   * receta.tratamiento
   */
  export type receta$tratamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    where?: tratamientoWhereInput
  }

  /**
   * receta without action
   */
  export type recetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
  }


  /**
   * Model secretaria
   */

  export type AggregateSecretaria = {
    _count: SecretariaCountAggregateOutputType | null
    _avg: SecretariaAvgAggregateOutputType | null
    _sum: SecretariaSumAggregateOutputType | null
    _min: SecretariaMinAggregateOutputType | null
    _max: SecretariaMaxAggregateOutputType | null
  }

  export type SecretariaAvgAggregateOutputType = {
    id_secretaria: number | null
    id_usuario: number | null
    salario: number | null
  }

  export type SecretariaSumAggregateOutputType = {
    id_secretaria: number | null
    id_usuario: number | null
    salario: number | null
  }

  export type SecretariaMinAggregateOutputType = {
    id_secretaria: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    telefono: string | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    correo: string | null
  }

  export type SecretariaMaxAggregateOutputType = {
    id_secretaria: number | null
    nombre: string | null
    segundonombre: string | null
    primerapellido: string | null
    segundoapellido: string | null
    nacimiento: Date | null
    telefono: string | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    correo: string | null
  }

  export type SecretariaCountAggregateOutputType = {
    id_secretaria: number
    nombre: number
    segundonombre: number
    primerapellido: number
    segundoapellido: number
    nacimiento: number
    telefono: number
    id_usuario: number
    fechacontratacion: number
    salario: number
    correo: number
    _all: number
  }


  export type SecretariaAvgAggregateInputType = {
    id_secretaria?: true
    id_usuario?: true
    salario?: true
  }

  export type SecretariaSumAggregateInputType = {
    id_secretaria?: true
    id_usuario?: true
    salario?: true
  }

  export type SecretariaMinAggregateInputType = {
    id_secretaria?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    telefono?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    correo?: true
  }

  export type SecretariaMaxAggregateInputType = {
    id_secretaria?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    telefono?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    correo?: true
  }

  export type SecretariaCountAggregateInputType = {
    id_secretaria?: true
    nombre?: true
    segundonombre?: true
    primerapellido?: true
    segundoapellido?: true
    nacimiento?: true
    telefono?: true
    id_usuario?: true
    fechacontratacion?: true
    salario?: true
    correo?: true
    _all?: true
  }

  export type SecretariaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which secretaria to aggregate.
     */
    where?: secretariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of secretarias to fetch.
     */
    orderBy?: secretariaOrderByWithRelationInput | secretariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: secretariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` secretarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` secretarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned secretarias
    **/
    _count?: true | SecretariaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecretariaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecretariaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecretariaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecretariaMaxAggregateInputType
  }

  export type GetSecretariaAggregateType<T extends SecretariaAggregateArgs> = {
        [P in keyof T & keyof AggregateSecretaria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecretaria[P]>
      : GetScalarType<T[P], AggregateSecretaria[P]>
  }




  export type secretariaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: secretariaWhereInput
    orderBy?: secretariaOrderByWithAggregationInput | secretariaOrderByWithAggregationInput[]
    by: SecretariaScalarFieldEnum[] | SecretariaScalarFieldEnum
    having?: secretariaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecretariaCountAggregateInputType | true
    _avg?: SecretariaAvgAggregateInputType
    _sum?: SecretariaSumAggregateInputType
    _min?: SecretariaMinAggregateInputType
    _max?: SecretariaMaxAggregateInputType
  }

  export type SecretariaGroupByOutputType = {
    id_secretaria: number
    nombre: string
    segundonombre: string | null
    primerapellido: string
    segundoapellido: string | null
    nacimiento: Date | null
    telefono: string | null
    id_usuario: number | null
    fechacontratacion: Date | null
    salario: number | null
    correo: string | null
    _count: SecretariaCountAggregateOutputType | null
    _avg: SecretariaAvgAggregateOutputType | null
    _sum: SecretariaSumAggregateOutputType | null
    _min: SecretariaMinAggregateOutputType | null
    _max: SecretariaMaxAggregateOutputType | null
  }

  type GetSecretariaGroupByPayload<T extends secretariaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecretariaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecretariaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecretariaGroupByOutputType[P]>
            : GetScalarType<T[P], SecretariaGroupByOutputType[P]>
        }
      >
    >


  export type secretariaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_secretaria?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    correo?: boolean
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["secretaria"]>

  export type secretariaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_secretaria?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    correo?: boolean
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["secretaria"]>

  export type secretariaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_secretaria?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    correo?: boolean
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["secretaria"]>

  export type secretariaSelectScalar = {
    id_secretaria?: boolean
    nombre?: boolean
    segundonombre?: boolean
    primerapellido?: boolean
    segundoapellido?: boolean
    nacimiento?: boolean
    telefono?: boolean
    id_usuario?: boolean
    fechacontratacion?: boolean
    salario?: boolean
    correo?: boolean
  }

  export type secretariaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_secretaria" | "nombre" | "segundonombre" | "primerapellido" | "segundoapellido" | "nacimiento" | "telefono" | "id_usuario" | "fechacontratacion" | "salario" | "correo", ExtArgs["result"]["secretaria"]>
  export type secretariaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }
  export type secretariaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }
  export type secretariaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | secretaria$usuarioArgs<ExtArgs>
  }

  export type $secretariaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "secretaria"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_secretaria: number
      nombre: string
      segundonombre: string | null
      primerapellido: string
      segundoapellido: string | null
      nacimiento: Date | null
      telefono: string | null
      id_usuario: number | null
      fechacontratacion: Date | null
      salario: number | null
      correo: string | null
    }, ExtArgs["result"]["secretaria"]>
    composites: {}
  }

  type secretariaGetPayload<S extends boolean | null | undefined | secretariaDefaultArgs> = $Result.GetResult<Prisma.$secretariaPayload, S>

  type secretariaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<secretariaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecretariaCountAggregateInputType | true
    }

  export interface secretariaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['secretaria'], meta: { name: 'secretaria' } }
    /**
     * Find zero or one Secretaria that matches the filter.
     * @param {secretariaFindUniqueArgs} args - Arguments to find a Secretaria
     * @example
     * // Get one Secretaria
     * const secretaria = await prisma.secretaria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends secretariaFindUniqueArgs>(args: SelectSubset<T, secretariaFindUniqueArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Secretaria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {secretariaFindUniqueOrThrowArgs} args - Arguments to find a Secretaria
     * @example
     * // Get one Secretaria
     * const secretaria = await prisma.secretaria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends secretariaFindUniqueOrThrowArgs>(args: SelectSubset<T, secretariaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Secretaria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaFindFirstArgs} args - Arguments to find a Secretaria
     * @example
     * // Get one Secretaria
     * const secretaria = await prisma.secretaria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends secretariaFindFirstArgs>(args?: SelectSubset<T, secretariaFindFirstArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Secretaria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaFindFirstOrThrowArgs} args - Arguments to find a Secretaria
     * @example
     * // Get one Secretaria
     * const secretaria = await prisma.secretaria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends secretariaFindFirstOrThrowArgs>(args?: SelectSubset<T, secretariaFindFirstOrThrowArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Secretarias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Secretarias
     * const secretarias = await prisma.secretaria.findMany()
     * 
     * // Get first 10 Secretarias
     * const secretarias = await prisma.secretaria.findMany({ take: 10 })
     * 
     * // Only select the `id_secretaria`
     * const secretariaWithId_secretariaOnly = await prisma.secretaria.findMany({ select: { id_secretaria: true } })
     * 
     */
    findMany<T extends secretariaFindManyArgs>(args?: SelectSubset<T, secretariaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Secretaria.
     * @param {secretariaCreateArgs} args - Arguments to create a Secretaria.
     * @example
     * // Create one Secretaria
     * const Secretaria = await prisma.secretaria.create({
     *   data: {
     *     // ... data to create a Secretaria
     *   }
     * })
     * 
     */
    create<T extends secretariaCreateArgs>(args: SelectSubset<T, secretariaCreateArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Secretarias.
     * @param {secretariaCreateManyArgs} args - Arguments to create many Secretarias.
     * @example
     * // Create many Secretarias
     * const secretaria = await prisma.secretaria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends secretariaCreateManyArgs>(args?: SelectSubset<T, secretariaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Secretarias and returns the data saved in the database.
     * @param {secretariaCreateManyAndReturnArgs} args - Arguments to create many Secretarias.
     * @example
     * // Create many Secretarias
     * const secretaria = await prisma.secretaria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Secretarias and only return the `id_secretaria`
     * const secretariaWithId_secretariaOnly = await prisma.secretaria.createManyAndReturn({
     *   select: { id_secretaria: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends secretariaCreateManyAndReturnArgs>(args?: SelectSubset<T, secretariaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Secretaria.
     * @param {secretariaDeleteArgs} args - Arguments to delete one Secretaria.
     * @example
     * // Delete one Secretaria
     * const Secretaria = await prisma.secretaria.delete({
     *   where: {
     *     // ... filter to delete one Secretaria
     *   }
     * })
     * 
     */
    delete<T extends secretariaDeleteArgs>(args: SelectSubset<T, secretariaDeleteArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Secretaria.
     * @param {secretariaUpdateArgs} args - Arguments to update one Secretaria.
     * @example
     * // Update one Secretaria
     * const secretaria = await prisma.secretaria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends secretariaUpdateArgs>(args: SelectSubset<T, secretariaUpdateArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Secretarias.
     * @param {secretariaDeleteManyArgs} args - Arguments to filter Secretarias to delete.
     * @example
     * // Delete a few Secretarias
     * const { count } = await prisma.secretaria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends secretariaDeleteManyArgs>(args?: SelectSubset<T, secretariaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Secretarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Secretarias
     * const secretaria = await prisma.secretaria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends secretariaUpdateManyArgs>(args: SelectSubset<T, secretariaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Secretarias and returns the data updated in the database.
     * @param {secretariaUpdateManyAndReturnArgs} args - Arguments to update many Secretarias.
     * @example
     * // Update many Secretarias
     * const secretaria = await prisma.secretaria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Secretarias and only return the `id_secretaria`
     * const secretariaWithId_secretariaOnly = await prisma.secretaria.updateManyAndReturn({
     *   select: { id_secretaria: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends secretariaUpdateManyAndReturnArgs>(args: SelectSubset<T, secretariaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Secretaria.
     * @param {secretariaUpsertArgs} args - Arguments to update or create a Secretaria.
     * @example
     * // Update or create a Secretaria
     * const secretaria = await prisma.secretaria.upsert({
     *   create: {
     *     // ... data to create a Secretaria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Secretaria we want to update
     *   }
     * })
     */
    upsert<T extends secretariaUpsertArgs>(args: SelectSubset<T, secretariaUpsertArgs<ExtArgs>>): Prisma__secretariaClient<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Secretarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaCountArgs} args - Arguments to filter Secretarias to count.
     * @example
     * // Count the number of Secretarias
     * const count = await prisma.secretaria.count({
     *   where: {
     *     // ... the filter for the Secretarias we want to count
     *   }
     * })
    **/
    count<T extends secretariaCountArgs>(
      args?: Subset<T, secretariaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecretariaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Secretaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretariaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecretariaAggregateArgs>(args: Subset<T, SecretariaAggregateArgs>): Prisma.PrismaPromise<GetSecretariaAggregateType<T>>

    /**
     * Group by Secretaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {secretariaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends secretariaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: secretariaGroupByArgs['orderBy'] }
        : { orderBy?: secretariaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, secretariaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecretariaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the secretaria model
   */
  readonly fields: secretariaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for secretaria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__secretariaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends secretaria$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, secretaria$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the secretaria model
   */
  interface secretariaFieldRefs {
    readonly id_secretaria: FieldRef<"secretaria", 'Int'>
    readonly nombre: FieldRef<"secretaria", 'String'>
    readonly segundonombre: FieldRef<"secretaria", 'String'>
    readonly primerapellido: FieldRef<"secretaria", 'String'>
    readonly segundoapellido: FieldRef<"secretaria", 'String'>
    readonly nacimiento: FieldRef<"secretaria", 'DateTime'>
    readonly telefono: FieldRef<"secretaria", 'String'>
    readonly id_usuario: FieldRef<"secretaria", 'Int'>
    readonly fechacontratacion: FieldRef<"secretaria", 'DateTime'>
    readonly salario: FieldRef<"secretaria", 'Float'>
    readonly correo: FieldRef<"secretaria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * secretaria findUnique
   */
  export type secretariaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter, which secretaria to fetch.
     */
    where: secretariaWhereUniqueInput
  }

  /**
   * secretaria findUniqueOrThrow
   */
  export type secretariaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter, which secretaria to fetch.
     */
    where: secretariaWhereUniqueInput
  }

  /**
   * secretaria findFirst
   */
  export type secretariaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter, which secretaria to fetch.
     */
    where?: secretariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of secretarias to fetch.
     */
    orderBy?: secretariaOrderByWithRelationInput | secretariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for secretarias.
     */
    cursor?: secretariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` secretarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` secretarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of secretarias.
     */
    distinct?: SecretariaScalarFieldEnum | SecretariaScalarFieldEnum[]
  }

  /**
   * secretaria findFirstOrThrow
   */
  export type secretariaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter, which secretaria to fetch.
     */
    where?: secretariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of secretarias to fetch.
     */
    orderBy?: secretariaOrderByWithRelationInput | secretariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for secretarias.
     */
    cursor?: secretariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` secretarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` secretarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of secretarias.
     */
    distinct?: SecretariaScalarFieldEnum | SecretariaScalarFieldEnum[]
  }

  /**
   * secretaria findMany
   */
  export type secretariaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter, which secretarias to fetch.
     */
    where?: secretariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of secretarias to fetch.
     */
    orderBy?: secretariaOrderByWithRelationInput | secretariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing secretarias.
     */
    cursor?: secretariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` secretarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` secretarias.
     */
    skip?: number
    distinct?: SecretariaScalarFieldEnum | SecretariaScalarFieldEnum[]
  }

  /**
   * secretaria create
   */
  export type secretariaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * The data needed to create a secretaria.
     */
    data: XOR<secretariaCreateInput, secretariaUncheckedCreateInput>
  }

  /**
   * secretaria createMany
   */
  export type secretariaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many secretarias.
     */
    data: secretariaCreateManyInput | secretariaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * secretaria createManyAndReturn
   */
  export type secretariaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * The data used to create many secretarias.
     */
    data: secretariaCreateManyInput | secretariaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * secretaria update
   */
  export type secretariaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * The data needed to update a secretaria.
     */
    data: XOR<secretariaUpdateInput, secretariaUncheckedUpdateInput>
    /**
     * Choose, which secretaria to update.
     */
    where: secretariaWhereUniqueInput
  }

  /**
   * secretaria updateMany
   */
  export type secretariaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update secretarias.
     */
    data: XOR<secretariaUpdateManyMutationInput, secretariaUncheckedUpdateManyInput>
    /**
     * Filter which secretarias to update
     */
    where?: secretariaWhereInput
    /**
     * Limit how many secretarias to update.
     */
    limit?: number
  }

  /**
   * secretaria updateManyAndReturn
   */
  export type secretariaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * The data used to update secretarias.
     */
    data: XOR<secretariaUpdateManyMutationInput, secretariaUncheckedUpdateManyInput>
    /**
     * Filter which secretarias to update
     */
    where?: secretariaWhereInput
    /**
     * Limit how many secretarias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * secretaria upsert
   */
  export type secretariaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * The filter to search for the secretaria to update in case it exists.
     */
    where: secretariaWhereUniqueInput
    /**
     * In case the secretaria found by the `where` argument doesn't exist, create a new secretaria with this data.
     */
    create: XOR<secretariaCreateInput, secretariaUncheckedCreateInput>
    /**
     * In case the secretaria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<secretariaUpdateInput, secretariaUncheckedUpdateInput>
  }

  /**
   * secretaria delete
   */
  export type secretariaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    /**
     * Filter which secretaria to delete.
     */
    where: secretariaWhereUniqueInput
  }

  /**
   * secretaria deleteMany
   */
  export type secretariaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which secretarias to delete
     */
    where?: secretariaWhereInput
    /**
     * Limit how many secretarias to delete.
     */
    limit?: number
  }

  /**
   * secretaria.usuario
   */
  export type secretaria$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * secretaria without action
   */
  export type secretariaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
  }


  /**
   * Model telefono
   */

  export type AggregateTelefono = {
    _count: TelefonoCountAggregateOutputType | null
    _avg: TelefonoAvgAggregateOutputType | null
    _sum: TelefonoSumAggregateOutputType | null
    _min: TelefonoMinAggregateOutputType | null
    _max: TelefonoMaxAggregateOutputType | null
  }

  export type TelefonoAvgAggregateOutputType = {
    id_telefono: number | null
  }

  export type TelefonoSumAggregateOutputType = {
    id_telefono: number | null
  }

  export type TelefonoMinAggregateOutputType = {
    id_telefono: number | null
    numero: string | null
    tipo: string | null
  }

  export type TelefonoMaxAggregateOutputType = {
    id_telefono: number | null
    numero: string | null
    tipo: string | null
  }

  export type TelefonoCountAggregateOutputType = {
    id_telefono: number
    numero: number
    tipo: number
    _all: number
  }


  export type TelefonoAvgAggregateInputType = {
    id_telefono?: true
  }

  export type TelefonoSumAggregateInputType = {
    id_telefono?: true
  }

  export type TelefonoMinAggregateInputType = {
    id_telefono?: true
    numero?: true
    tipo?: true
  }

  export type TelefonoMaxAggregateInputType = {
    id_telefono?: true
    numero?: true
    tipo?: true
  }

  export type TelefonoCountAggregateInputType = {
    id_telefono?: true
    numero?: true
    tipo?: true
    _all?: true
  }

  export type TelefonoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefono to aggregate.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned telefonos
    **/
    _count?: true | TelefonoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelefonoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelefonoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelefonoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelefonoMaxAggregateInputType
  }

  export type GetTelefonoAggregateType<T extends TelefonoAggregateArgs> = {
        [P in keyof T & keyof AggregateTelefono]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelefono[P]>
      : GetScalarType<T[P], AggregateTelefono[P]>
  }




  export type telefonoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: telefonoWhereInput
    orderBy?: telefonoOrderByWithAggregationInput | telefonoOrderByWithAggregationInput[]
    by: TelefonoScalarFieldEnum[] | TelefonoScalarFieldEnum
    having?: telefonoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelefonoCountAggregateInputType | true
    _avg?: TelefonoAvgAggregateInputType
    _sum?: TelefonoSumAggregateInputType
    _min?: TelefonoMinAggregateInputType
    _max?: TelefonoMaxAggregateInputType
  }

  export type TelefonoGroupByOutputType = {
    id_telefono: number
    numero: string
    tipo: string | null
    _count: TelefonoCountAggregateOutputType | null
    _avg: TelefonoAvgAggregateOutputType | null
    _sum: TelefonoSumAggregateOutputType | null
    _min: TelefonoMinAggregateOutputType | null
    _max: TelefonoMaxAggregateOutputType | null
  }

  type GetTelefonoGroupByPayload<T extends telefonoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelefonoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelefonoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelefonoGroupByOutputType[P]>
            : GetScalarType<T[P], TelefonoGroupByOutputType[P]>
        }
      >
    >


  export type telefonoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefono?: boolean
    numero?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["telefono"]>

  export type telefonoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefono?: boolean
    numero?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["telefono"]>

  export type telefonoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefono?: boolean
    numero?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["telefono"]>

  export type telefonoSelectScalar = {
    id_telefono?: boolean
    numero?: boolean
    tipo?: boolean
  }

  export type telefonoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_telefono" | "numero" | "tipo", ExtArgs["result"]["telefono"]>

  export type $telefonoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "telefono"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_telefono: number
      numero: string
      tipo: string | null
    }, ExtArgs["result"]["telefono"]>
    composites: {}
  }

  type telefonoGetPayload<S extends boolean | null | undefined | telefonoDefaultArgs> = $Result.GetResult<Prisma.$telefonoPayload, S>

  type telefonoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<telefonoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelefonoCountAggregateInputType | true
    }

  export interface telefonoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['telefono'], meta: { name: 'telefono' } }
    /**
     * Find zero or one Telefono that matches the filter.
     * @param {telefonoFindUniqueArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends telefonoFindUniqueArgs>(args: SelectSubset<T, telefonoFindUniqueArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Telefono that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {telefonoFindUniqueOrThrowArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends telefonoFindUniqueOrThrowArgs>(args: SelectSubset<T, telefonoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Telefono that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindFirstArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends telefonoFindFirstArgs>(args?: SelectSubset<T, telefonoFindFirstArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Telefono that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindFirstOrThrowArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends telefonoFindFirstOrThrowArgs>(args?: SelectSubset<T, telefonoFindFirstOrThrowArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Telefonos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telefonos
     * const telefonos = await prisma.telefono.findMany()
     * 
     * // Get first 10 Telefonos
     * const telefonos = await prisma.telefono.findMany({ take: 10 })
     * 
     * // Only select the `id_telefono`
     * const telefonoWithId_telefonoOnly = await prisma.telefono.findMany({ select: { id_telefono: true } })
     * 
     */
    findMany<T extends telefonoFindManyArgs>(args?: SelectSubset<T, telefonoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Telefono.
     * @param {telefonoCreateArgs} args - Arguments to create a Telefono.
     * @example
     * // Create one Telefono
     * const Telefono = await prisma.telefono.create({
     *   data: {
     *     // ... data to create a Telefono
     *   }
     * })
     * 
     */
    create<T extends telefonoCreateArgs>(args: SelectSubset<T, telefonoCreateArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Telefonos.
     * @param {telefonoCreateManyArgs} args - Arguments to create many Telefonos.
     * @example
     * // Create many Telefonos
     * const telefono = await prisma.telefono.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends telefonoCreateManyArgs>(args?: SelectSubset<T, telefonoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Telefonos and returns the data saved in the database.
     * @param {telefonoCreateManyAndReturnArgs} args - Arguments to create many Telefonos.
     * @example
     * // Create many Telefonos
     * const telefono = await prisma.telefono.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Telefonos and only return the `id_telefono`
     * const telefonoWithId_telefonoOnly = await prisma.telefono.createManyAndReturn({
     *   select: { id_telefono: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends telefonoCreateManyAndReturnArgs>(args?: SelectSubset<T, telefonoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Telefono.
     * @param {telefonoDeleteArgs} args - Arguments to delete one Telefono.
     * @example
     * // Delete one Telefono
     * const Telefono = await prisma.telefono.delete({
     *   where: {
     *     // ... filter to delete one Telefono
     *   }
     * })
     * 
     */
    delete<T extends telefonoDeleteArgs>(args: SelectSubset<T, telefonoDeleteArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Telefono.
     * @param {telefonoUpdateArgs} args - Arguments to update one Telefono.
     * @example
     * // Update one Telefono
     * const telefono = await prisma.telefono.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends telefonoUpdateArgs>(args: SelectSubset<T, telefonoUpdateArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Telefonos.
     * @param {telefonoDeleteManyArgs} args - Arguments to filter Telefonos to delete.
     * @example
     * // Delete a few Telefonos
     * const { count } = await prisma.telefono.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends telefonoDeleteManyArgs>(args?: SelectSubset<T, telefonoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telefonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telefonos
     * const telefono = await prisma.telefono.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends telefonoUpdateManyArgs>(args: SelectSubset<T, telefonoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telefonos and returns the data updated in the database.
     * @param {telefonoUpdateManyAndReturnArgs} args - Arguments to update many Telefonos.
     * @example
     * // Update many Telefonos
     * const telefono = await prisma.telefono.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Telefonos and only return the `id_telefono`
     * const telefonoWithId_telefonoOnly = await prisma.telefono.updateManyAndReturn({
     *   select: { id_telefono: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends telefonoUpdateManyAndReturnArgs>(args: SelectSubset<T, telefonoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Telefono.
     * @param {telefonoUpsertArgs} args - Arguments to update or create a Telefono.
     * @example
     * // Update or create a Telefono
     * const telefono = await prisma.telefono.upsert({
     *   create: {
     *     // ... data to create a Telefono
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telefono we want to update
     *   }
     * })
     */
    upsert<T extends telefonoUpsertArgs>(args: SelectSubset<T, telefonoUpsertArgs<ExtArgs>>): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Telefonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoCountArgs} args - Arguments to filter Telefonos to count.
     * @example
     * // Count the number of Telefonos
     * const count = await prisma.telefono.count({
     *   where: {
     *     // ... the filter for the Telefonos we want to count
     *   }
     * })
    **/
    count<T extends telefonoCountArgs>(
      args?: Subset<T, telefonoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelefonoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Telefono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelefonoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelefonoAggregateArgs>(args: Subset<T, TelefonoAggregateArgs>): Prisma.PrismaPromise<GetTelefonoAggregateType<T>>

    /**
     * Group by Telefono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends telefonoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: telefonoGroupByArgs['orderBy'] }
        : { orderBy?: telefonoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, telefonoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelefonoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the telefono model
   */
  readonly fields: telefonoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for telefono.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__telefonoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the telefono model
   */
  interface telefonoFieldRefs {
    readonly id_telefono: FieldRef<"telefono", 'Int'>
    readonly numero: FieldRef<"telefono", 'String'>
    readonly tipo: FieldRef<"telefono", 'String'>
  }
    

  // Custom InputTypes
  /**
   * telefono findUnique
   */
  export type telefonoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where: telefonoWhereUniqueInput
  }

  /**
   * telefono findUniqueOrThrow
   */
  export type telefonoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where: telefonoWhereUniqueInput
  }

  /**
   * telefono findFirst
   */
  export type telefonoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefonos.
     */
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }

  /**
   * telefono findFirstOrThrow
   */
  export type telefonoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefonos.
     */
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }

  /**
   * telefono findMany
   */
  export type telefonoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter, which telefonos to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }

  /**
   * telefono create
   */
  export type telefonoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * The data needed to create a telefono.
     */
    data: XOR<telefonoCreateInput, telefonoUncheckedCreateInput>
  }

  /**
   * telefono createMany
   */
  export type telefonoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many telefonos.
     */
    data: telefonoCreateManyInput | telefonoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * telefono createManyAndReturn
   */
  export type telefonoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * The data used to create many telefonos.
     */
    data: telefonoCreateManyInput | telefonoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * telefono update
   */
  export type telefonoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * The data needed to update a telefono.
     */
    data: XOR<telefonoUpdateInput, telefonoUncheckedUpdateInput>
    /**
     * Choose, which telefono to update.
     */
    where: telefonoWhereUniqueInput
  }

  /**
   * telefono updateMany
   */
  export type telefonoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update telefonos.
     */
    data: XOR<telefonoUpdateManyMutationInput, telefonoUncheckedUpdateManyInput>
    /**
     * Filter which telefonos to update
     */
    where?: telefonoWhereInput
    /**
     * Limit how many telefonos to update.
     */
    limit?: number
  }

  /**
   * telefono updateManyAndReturn
   */
  export type telefonoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * The data used to update telefonos.
     */
    data: XOR<telefonoUpdateManyMutationInput, telefonoUncheckedUpdateManyInput>
    /**
     * Filter which telefonos to update
     */
    where?: telefonoWhereInput
    /**
     * Limit how many telefonos to update.
     */
    limit?: number
  }

  /**
   * telefono upsert
   */
  export type telefonoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * The filter to search for the telefono to update in case it exists.
     */
    where: telefonoWhereUniqueInput
    /**
     * In case the telefono found by the `where` argument doesn't exist, create a new telefono with this data.
     */
    create: XOR<telefonoCreateInput, telefonoUncheckedCreateInput>
    /**
     * In case the telefono was found with the provided `where` argument, update it with this data.
     */
    update: XOR<telefonoUpdateInput, telefonoUncheckedUpdateInput>
  }

  /**
   * telefono delete
   */
  export type telefonoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
    /**
     * Filter which telefono to delete.
     */
    where: telefonoWhereUniqueInput
  }

  /**
   * telefono deleteMany
   */
  export type telefonoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefonos to delete
     */
    where?: telefonoWhereInput
    /**
     * Limit how many telefonos to delete.
     */
    limit?: number
  }

  /**
   * telefono without action
   */
  export type telefonoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefono
     */
    omit?: telefonoOmit<ExtArgs> | null
  }


  /**
   * Model tratamiento
   */

  export type AggregateTratamiento = {
    _count: TratamientoCountAggregateOutputType | null
    _avg: TratamientoAvgAggregateOutputType | null
    _sum: TratamientoSumAggregateOutputType | null
    _min: TratamientoMinAggregateOutputType | null
    _max: TratamientoMaxAggregateOutputType | null
  }

  export type TratamientoAvgAggregateOutputType = {
    id_tratamiento: number | null
    id_diagnostico: number | null
  }

  export type TratamientoSumAggregateOutputType = {
    id_tratamiento: number | null
    id_diagnostico: number | null
  }

  export type TratamientoMinAggregateOutputType = {
    id_tratamiento: number | null
    tipotratamiento: string | null
    descripcion: string | null
    duracion: string | null
    frecuencia: string | null
    id_diagnostico: number | null
  }

  export type TratamientoMaxAggregateOutputType = {
    id_tratamiento: number | null
    tipotratamiento: string | null
    descripcion: string | null
    duracion: string | null
    frecuencia: string | null
    id_diagnostico: number | null
  }

  export type TratamientoCountAggregateOutputType = {
    id_tratamiento: number
    tipotratamiento: number
    descripcion: number
    duracion: number
    frecuencia: number
    id_diagnostico: number
    _all: number
  }


  export type TratamientoAvgAggregateInputType = {
    id_tratamiento?: true
    id_diagnostico?: true
  }

  export type TratamientoSumAggregateInputType = {
    id_tratamiento?: true
    id_diagnostico?: true
  }

  export type TratamientoMinAggregateInputType = {
    id_tratamiento?: true
    tipotratamiento?: true
    descripcion?: true
    duracion?: true
    frecuencia?: true
    id_diagnostico?: true
  }

  export type TratamientoMaxAggregateInputType = {
    id_tratamiento?: true
    tipotratamiento?: true
    descripcion?: true
    duracion?: true
    frecuencia?: true
    id_diagnostico?: true
  }

  export type TratamientoCountAggregateInputType = {
    id_tratamiento?: true
    tipotratamiento?: true
    descripcion?: true
    duracion?: true
    frecuencia?: true
    id_diagnostico?: true
    _all?: true
  }

  export type TratamientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tratamiento to aggregate.
     */
    where?: tratamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tratamientos to fetch.
     */
    orderBy?: tratamientoOrderByWithRelationInput | tratamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tratamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tratamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tratamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tratamientos
    **/
    _count?: true | TratamientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TratamientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TratamientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TratamientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TratamientoMaxAggregateInputType
  }

  export type GetTratamientoAggregateType<T extends TratamientoAggregateArgs> = {
        [P in keyof T & keyof AggregateTratamiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTratamiento[P]>
      : GetScalarType<T[P], AggregateTratamiento[P]>
  }




  export type tratamientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tratamientoWhereInput
    orderBy?: tratamientoOrderByWithAggregationInput | tratamientoOrderByWithAggregationInput[]
    by: TratamientoScalarFieldEnum[] | TratamientoScalarFieldEnum
    having?: tratamientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TratamientoCountAggregateInputType | true
    _avg?: TratamientoAvgAggregateInputType
    _sum?: TratamientoSumAggregateInputType
    _min?: TratamientoMinAggregateInputType
    _max?: TratamientoMaxAggregateInputType
  }

  export type TratamientoGroupByOutputType = {
    id_tratamiento: number
    tipotratamiento: string | null
    descripcion: string | null
    duracion: string | null
    frecuencia: string | null
    id_diagnostico: number | null
    _count: TratamientoCountAggregateOutputType | null
    _avg: TratamientoAvgAggregateOutputType | null
    _sum: TratamientoSumAggregateOutputType | null
    _min: TratamientoMinAggregateOutputType | null
    _max: TratamientoMaxAggregateOutputType | null
  }

  type GetTratamientoGroupByPayload<T extends tratamientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TratamientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TratamientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TratamientoGroupByOutputType[P]>
            : GetScalarType<T[P], TratamientoGroupByOutputType[P]>
        }
      >
    >


  export type tratamientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tratamiento?: boolean
    tipotratamiento?: boolean
    descripcion?: boolean
    duracion?: boolean
    frecuencia?: boolean
    id_diagnostico?: boolean
    receta?: boolean | tratamiento$recetaArgs<ExtArgs>
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
    _count?: boolean | TratamientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tratamiento"]>

  export type tratamientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tratamiento?: boolean
    tipotratamiento?: boolean
    descripcion?: boolean
    duracion?: boolean
    frecuencia?: boolean
    id_diagnostico?: boolean
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
  }, ExtArgs["result"]["tratamiento"]>

  export type tratamientoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tratamiento?: boolean
    tipotratamiento?: boolean
    descripcion?: boolean
    duracion?: boolean
    frecuencia?: boolean
    id_diagnostico?: boolean
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
  }, ExtArgs["result"]["tratamiento"]>

  export type tratamientoSelectScalar = {
    id_tratamiento?: boolean
    tipotratamiento?: boolean
    descripcion?: boolean
    duracion?: boolean
    frecuencia?: boolean
    id_diagnostico?: boolean
  }

  export type tratamientoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tratamiento" | "tipotratamiento" | "descripcion" | "duracion" | "frecuencia" | "id_diagnostico", ExtArgs["result"]["tratamiento"]>
  export type tratamientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receta?: boolean | tratamiento$recetaArgs<ExtArgs>
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
    _count?: boolean | TratamientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tratamientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
  }
  export type tratamientoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | tratamiento$diagnosticoArgs<ExtArgs>
  }

  export type $tratamientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tratamiento"
    objects: {
      receta: Prisma.$recetaPayload<ExtArgs>[]
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tratamiento: number
      tipotratamiento: string | null
      descripcion: string | null
      duracion: string | null
      frecuencia: string | null
      id_diagnostico: number | null
    }, ExtArgs["result"]["tratamiento"]>
    composites: {}
  }

  type tratamientoGetPayload<S extends boolean | null | undefined | tratamientoDefaultArgs> = $Result.GetResult<Prisma.$tratamientoPayload, S>

  type tratamientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tratamientoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TratamientoCountAggregateInputType | true
    }

  export interface tratamientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tratamiento'], meta: { name: 'tratamiento' } }
    /**
     * Find zero or one Tratamiento that matches the filter.
     * @param {tratamientoFindUniqueArgs} args - Arguments to find a Tratamiento
     * @example
     * // Get one Tratamiento
     * const tratamiento = await prisma.tratamiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tratamientoFindUniqueArgs>(args: SelectSubset<T, tratamientoFindUniqueArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tratamiento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tratamientoFindUniqueOrThrowArgs} args - Arguments to find a Tratamiento
     * @example
     * // Get one Tratamiento
     * const tratamiento = await prisma.tratamiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tratamientoFindUniqueOrThrowArgs>(args: SelectSubset<T, tratamientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tratamiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoFindFirstArgs} args - Arguments to find a Tratamiento
     * @example
     * // Get one Tratamiento
     * const tratamiento = await prisma.tratamiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tratamientoFindFirstArgs>(args?: SelectSubset<T, tratamientoFindFirstArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tratamiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoFindFirstOrThrowArgs} args - Arguments to find a Tratamiento
     * @example
     * // Get one Tratamiento
     * const tratamiento = await prisma.tratamiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tratamientoFindFirstOrThrowArgs>(args?: SelectSubset<T, tratamientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tratamientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tratamientos
     * const tratamientos = await prisma.tratamiento.findMany()
     * 
     * // Get first 10 Tratamientos
     * const tratamientos = await prisma.tratamiento.findMany({ take: 10 })
     * 
     * // Only select the `id_tratamiento`
     * const tratamientoWithId_tratamientoOnly = await prisma.tratamiento.findMany({ select: { id_tratamiento: true } })
     * 
     */
    findMany<T extends tratamientoFindManyArgs>(args?: SelectSubset<T, tratamientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tratamiento.
     * @param {tratamientoCreateArgs} args - Arguments to create a Tratamiento.
     * @example
     * // Create one Tratamiento
     * const Tratamiento = await prisma.tratamiento.create({
     *   data: {
     *     // ... data to create a Tratamiento
     *   }
     * })
     * 
     */
    create<T extends tratamientoCreateArgs>(args: SelectSubset<T, tratamientoCreateArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tratamientos.
     * @param {tratamientoCreateManyArgs} args - Arguments to create many Tratamientos.
     * @example
     * // Create many Tratamientos
     * const tratamiento = await prisma.tratamiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tratamientoCreateManyArgs>(args?: SelectSubset<T, tratamientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tratamientos and returns the data saved in the database.
     * @param {tratamientoCreateManyAndReturnArgs} args - Arguments to create many Tratamientos.
     * @example
     * // Create many Tratamientos
     * const tratamiento = await prisma.tratamiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tratamientos and only return the `id_tratamiento`
     * const tratamientoWithId_tratamientoOnly = await prisma.tratamiento.createManyAndReturn({
     *   select: { id_tratamiento: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tratamientoCreateManyAndReturnArgs>(args?: SelectSubset<T, tratamientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tratamiento.
     * @param {tratamientoDeleteArgs} args - Arguments to delete one Tratamiento.
     * @example
     * // Delete one Tratamiento
     * const Tratamiento = await prisma.tratamiento.delete({
     *   where: {
     *     // ... filter to delete one Tratamiento
     *   }
     * })
     * 
     */
    delete<T extends tratamientoDeleteArgs>(args: SelectSubset<T, tratamientoDeleteArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tratamiento.
     * @param {tratamientoUpdateArgs} args - Arguments to update one Tratamiento.
     * @example
     * // Update one Tratamiento
     * const tratamiento = await prisma.tratamiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tratamientoUpdateArgs>(args: SelectSubset<T, tratamientoUpdateArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tratamientos.
     * @param {tratamientoDeleteManyArgs} args - Arguments to filter Tratamientos to delete.
     * @example
     * // Delete a few Tratamientos
     * const { count } = await prisma.tratamiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tratamientoDeleteManyArgs>(args?: SelectSubset<T, tratamientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tratamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tratamientos
     * const tratamiento = await prisma.tratamiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tratamientoUpdateManyArgs>(args: SelectSubset<T, tratamientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tratamientos and returns the data updated in the database.
     * @param {tratamientoUpdateManyAndReturnArgs} args - Arguments to update many Tratamientos.
     * @example
     * // Update many Tratamientos
     * const tratamiento = await prisma.tratamiento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tratamientos and only return the `id_tratamiento`
     * const tratamientoWithId_tratamientoOnly = await prisma.tratamiento.updateManyAndReturn({
     *   select: { id_tratamiento: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tratamientoUpdateManyAndReturnArgs>(args: SelectSubset<T, tratamientoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tratamiento.
     * @param {tratamientoUpsertArgs} args - Arguments to update or create a Tratamiento.
     * @example
     * // Update or create a Tratamiento
     * const tratamiento = await prisma.tratamiento.upsert({
     *   create: {
     *     // ... data to create a Tratamiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tratamiento we want to update
     *   }
     * })
     */
    upsert<T extends tratamientoUpsertArgs>(args: SelectSubset<T, tratamientoUpsertArgs<ExtArgs>>): Prisma__tratamientoClient<$Result.GetResult<Prisma.$tratamientoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tratamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoCountArgs} args - Arguments to filter Tratamientos to count.
     * @example
     * // Count the number of Tratamientos
     * const count = await prisma.tratamiento.count({
     *   where: {
     *     // ... the filter for the Tratamientos we want to count
     *   }
     * })
    **/
    count<T extends tratamientoCountArgs>(
      args?: Subset<T, tratamientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TratamientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tratamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TratamientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TratamientoAggregateArgs>(args: Subset<T, TratamientoAggregateArgs>): Prisma.PrismaPromise<GetTratamientoAggregateType<T>>

    /**
     * Group by Tratamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tratamientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tratamientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tratamientoGroupByArgs['orderBy'] }
        : { orderBy?: tratamientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tratamientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTratamientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tratamiento model
   */
  readonly fields: tratamientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tratamiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tratamientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receta<T extends tratamiento$recetaArgs<ExtArgs> = {}>(args?: Subset<T, tratamiento$recetaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnostico<T extends tratamiento$diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, tratamiento$diagnosticoArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tratamiento model
   */
  interface tratamientoFieldRefs {
    readonly id_tratamiento: FieldRef<"tratamiento", 'Int'>
    readonly tipotratamiento: FieldRef<"tratamiento", 'String'>
    readonly descripcion: FieldRef<"tratamiento", 'String'>
    readonly duracion: FieldRef<"tratamiento", 'String'>
    readonly frecuencia: FieldRef<"tratamiento", 'String'>
    readonly id_diagnostico: FieldRef<"tratamiento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tratamiento findUnique
   */
  export type tratamientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter, which tratamiento to fetch.
     */
    where: tratamientoWhereUniqueInput
  }

  /**
   * tratamiento findUniqueOrThrow
   */
  export type tratamientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter, which tratamiento to fetch.
     */
    where: tratamientoWhereUniqueInput
  }

  /**
   * tratamiento findFirst
   */
  export type tratamientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter, which tratamiento to fetch.
     */
    where?: tratamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tratamientos to fetch.
     */
    orderBy?: tratamientoOrderByWithRelationInput | tratamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tratamientos.
     */
    cursor?: tratamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tratamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tratamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tratamientos.
     */
    distinct?: TratamientoScalarFieldEnum | TratamientoScalarFieldEnum[]
  }

  /**
   * tratamiento findFirstOrThrow
   */
  export type tratamientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter, which tratamiento to fetch.
     */
    where?: tratamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tratamientos to fetch.
     */
    orderBy?: tratamientoOrderByWithRelationInput | tratamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tratamientos.
     */
    cursor?: tratamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tratamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tratamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tratamientos.
     */
    distinct?: TratamientoScalarFieldEnum | TratamientoScalarFieldEnum[]
  }

  /**
   * tratamiento findMany
   */
  export type tratamientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter, which tratamientos to fetch.
     */
    where?: tratamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tratamientos to fetch.
     */
    orderBy?: tratamientoOrderByWithRelationInput | tratamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tratamientos.
     */
    cursor?: tratamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tratamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tratamientos.
     */
    skip?: number
    distinct?: TratamientoScalarFieldEnum | TratamientoScalarFieldEnum[]
  }

  /**
   * tratamiento create
   */
  export type tratamientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * The data needed to create a tratamiento.
     */
    data?: XOR<tratamientoCreateInput, tratamientoUncheckedCreateInput>
  }

  /**
   * tratamiento createMany
   */
  export type tratamientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tratamientos.
     */
    data: tratamientoCreateManyInput | tratamientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tratamiento createManyAndReturn
   */
  export type tratamientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * The data used to create many tratamientos.
     */
    data: tratamientoCreateManyInput | tratamientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tratamiento update
   */
  export type tratamientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * The data needed to update a tratamiento.
     */
    data: XOR<tratamientoUpdateInput, tratamientoUncheckedUpdateInput>
    /**
     * Choose, which tratamiento to update.
     */
    where: tratamientoWhereUniqueInput
  }

  /**
   * tratamiento updateMany
   */
  export type tratamientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tratamientos.
     */
    data: XOR<tratamientoUpdateManyMutationInput, tratamientoUncheckedUpdateManyInput>
    /**
     * Filter which tratamientos to update
     */
    where?: tratamientoWhereInput
    /**
     * Limit how many tratamientos to update.
     */
    limit?: number
  }

  /**
   * tratamiento updateManyAndReturn
   */
  export type tratamientoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * The data used to update tratamientos.
     */
    data: XOR<tratamientoUpdateManyMutationInput, tratamientoUncheckedUpdateManyInput>
    /**
     * Filter which tratamientos to update
     */
    where?: tratamientoWhereInput
    /**
     * Limit how many tratamientos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tratamiento upsert
   */
  export type tratamientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * The filter to search for the tratamiento to update in case it exists.
     */
    where: tratamientoWhereUniqueInput
    /**
     * In case the tratamiento found by the `where` argument doesn't exist, create a new tratamiento with this data.
     */
    create: XOR<tratamientoCreateInput, tratamientoUncheckedCreateInput>
    /**
     * In case the tratamiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tratamientoUpdateInput, tratamientoUncheckedUpdateInput>
  }

  /**
   * tratamiento delete
   */
  export type tratamientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
    /**
     * Filter which tratamiento to delete.
     */
    where: tratamientoWhereUniqueInput
  }

  /**
   * tratamiento deleteMany
   */
  export type tratamientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tratamientos to delete
     */
    where?: tratamientoWhereInput
    /**
     * Limit how many tratamientos to delete.
     */
    limit?: number
  }

  /**
   * tratamiento.receta
   */
  export type tratamiento$recetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receta
     */
    select?: recetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receta
     */
    omit?: recetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetaInclude<ExtArgs> | null
    where?: recetaWhereInput
    orderBy?: recetaOrderByWithRelationInput | recetaOrderByWithRelationInput[]
    cursor?: recetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * tratamiento.diagnostico
   */
  export type tratamiento$diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    where?: diagnosticoWhereInput
  }

  /**
   * tratamiento without action
   */
  export type tratamientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tratamiento
     */
    select?: tratamientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tratamiento
     */
    omit?: tratamientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tratamientoInclude<ExtArgs> | null
  }


  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    contrasena: string | null
    rol: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    contrasena: string | null
    rol: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    nombre: number
    contrasena: number
    rol: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    nombre?: true
    contrasena?: true
    rol?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    nombre?: true
    contrasena?: true
    rol?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    nombre?: true
    contrasena?: true
    rol?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    nombre: string
    contrasena: string
    rol: string
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    contrasena?: boolean
    rol?: boolean
    administrador?: boolean | usuario$administradorArgs<ExtArgs>
    doctor?: boolean | usuario$doctorArgs<ExtArgs>
    paciente?: boolean | usuario$pacienteArgs<ExtArgs>
    proveedor?: boolean | usuario$proveedorArgs<ExtArgs>
    secretaria?: boolean | usuario$secretariaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    contrasena?: boolean
    rol?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    contrasena?: boolean
    rol?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectScalar = {
    id_usuario?: boolean
    nombre?: boolean
    contrasena?: boolean
    rol?: boolean
  }

  export type usuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_usuario" | "nombre" | "contrasena" | "rol", ExtArgs["result"]["usuario"]>
  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrador?: boolean | usuario$administradorArgs<ExtArgs>
    doctor?: boolean | usuario$doctorArgs<ExtArgs>
    paciente?: boolean | usuario$pacienteArgs<ExtArgs>
    proveedor?: boolean | usuario$proveedorArgs<ExtArgs>
    secretaria?: boolean | usuario$secretariaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      administrador: Prisma.$administradorPayload<ExtArgs>[]
      doctor: Prisma.$doctorPayload<ExtArgs>[]
      paciente: Prisma.$pacientePayload<ExtArgs>[]
      proveedor: Prisma.$proveedorPayload<ExtArgs>[]
      secretaria: Prisma.$secretariaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      nombre: string
      contrasena: string
      rol: string
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, usuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {usuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, usuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    administrador<T extends usuario$administradorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$administradorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctor<T extends usuario$doctorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$doctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paciente<T extends usuario$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, usuario$pacienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proveedor<T extends usuario$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$proveedorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    secretaria<T extends usuario$secretariaArgs<ExtArgs> = {}>(args?: Subset<T, usuario$secretariaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$secretariaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */
  interface usuarioFieldRefs {
    readonly id_usuario: FieldRef<"usuario", 'Int'>
    readonly nombre: FieldRef<"usuario", 'String'>
    readonly contrasena: FieldRef<"usuario", 'String'>
    readonly rol: FieldRef<"usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario createManyAndReturn
   */
  export type usuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuario updateManyAndReturn
   */
  export type usuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuario.administrador
   */
  export type usuario$administradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    where?: administradorWhereInput
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    cursor?: administradorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * usuario.doctor
   */
  export type usuario$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctor
     */
    select?: doctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the doctor
     */
    omit?: doctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: doctorInclude<ExtArgs> | null
    where?: doctorWhereInput
    orderBy?: doctorOrderByWithRelationInput | doctorOrderByWithRelationInput[]
    cursor?: doctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * usuario.paciente
   */
  export type usuario$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paciente
     */
    select?: pacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paciente
     */
    omit?: pacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacienteInclude<ExtArgs> | null
    where?: pacienteWhereInput
    orderBy?: pacienteOrderByWithRelationInput | pacienteOrderByWithRelationInput[]
    cursor?: pacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * usuario.proveedor
   */
  export type usuario$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proveedor
     */
    omit?: proveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedorInclude<ExtArgs> | null
    where?: proveedorWhereInput
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    cursor?: proveedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * usuario.secretaria
   */
  export type usuario$secretariaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the secretaria
     */
    select?: secretariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the secretaria
     */
    omit?: secretariaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: secretariaInclude<ExtArgs> | null
    where?: secretariaWhereInput
    orderBy?: secretariaOrderByWithRelationInput | secretariaOrderByWithRelationInput[]
    cursor?: secretariaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecretariaScalarFieldEnum | SecretariaScalarFieldEnum[]
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdministradorScalarFieldEnum: {
    id_admin: 'id_admin',
    nombre: 'nombre',
    segundonombre: 'segundonombre',
    primerapellido: 'primerapellido',
    segundoapellido: 'segundoapellido',
    nacimiento: 'nacimiento',
    celular: 'celular',
    telefono: 'telefono',
    id_usuario: 'id_usuario',
    fechaingreso: 'fechaingreso'
  };

  export type AdministradorScalarFieldEnum = (typeof AdministradorScalarFieldEnum)[keyof typeof AdministradorScalarFieldEnum]


  export const CitaScalarFieldEnum: {
    id_cita: 'id_cita',
    fecha: 'fecha',
    horainicio: 'horainicio',
    horafin: 'horafin',
    estado: 'estado',
    motivo: 'motivo',
    id_doctor: 'id_doctor',
    id_paciente: 'id_paciente',
    hora_llegada: 'hora_llegada'
  };

  export type CitaScalarFieldEnum = (typeof CitaScalarFieldEnum)[keyof typeof CitaScalarFieldEnum]


  export const ConsultaScalarFieldEnum: {
    id_consulta: 'id_consulta',
    fecha: 'fecha',
    motivo: 'motivo',
    id_cita: 'id_cita'
  };

  export type ConsultaScalarFieldEnum = (typeof ConsultaScalarFieldEnum)[keyof typeof ConsultaScalarFieldEnum]


  export const DetallepagoScalarFieldEnum: {
    id_detalle_pago: 'id_detalle_pago',
    fechapago: 'fechapago',
    id_transaccionpp: 'id_transaccionpp'
  };

  export type DetallepagoScalarFieldEnum = (typeof DetallepagoScalarFieldEnum)[keyof typeof DetallepagoScalarFieldEnum]


  export const DiagnosticoScalarFieldEnum: {
    id_diagnostico: 'id_diagnostico',
    nombrediagnostico: 'nombrediagnostico',
    descripcion: 'descripcion',
    id_consulta: 'id_consulta'
  };

  export type DiagnosticoScalarFieldEnum = (typeof DiagnosticoScalarFieldEnum)[keyof typeof DiagnosticoScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id_doctor: 'id_doctor',
    nombre: 'nombre',
    segundonombre: 'segundonombre',
    primerapellido: 'primerapellido',
    segundoapellido: 'segundoapellido',
    nacimiento: 'nacimiento',
    id_usuario: 'id_usuario',
    fechacontratacion: 'fechacontratacion',
    salario: 'salario',
    telefono: 'telefono',
    correo: 'correo',
    id_especialidad: 'id_especialidad'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const EspecialidadScalarFieldEnum: {
    id_especialidad: 'id_especialidad',
    nombreespecialidad: 'nombreespecialidad',
    descripcion: 'descripcion'
  };

  export type EspecialidadScalarFieldEnum = (typeof EspecialidadScalarFieldEnum)[keyof typeof EspecialidadScalarFieldEnum]


  export const Especialidad_doctorScalarFieldEnum: {
    id_especialidad_doctor: 'id_especialidad_doctor',
    id_doctor: 'id_doctor',
    id_especialidad: 'id_especialidad'
  };

  export type Especialidad_doctorScalarFieldEnum = (typeof Especialidad_doctorScalarFieldEnum)[keyof typeof Especialidad_doctorScalarFieldEnum]


  export const ExamenScalarFieldEnum: {
    id_examen: 'id_examen',
    tipoexamen: 'tipoexamen',
    rutaExamen: 'rutaExamen',
    id_paciente: 'id_paciente'
  };

  export type ExamenScalarFieldEnum = (typeof ExamenScalarFieldEnum)[keyof typeof ExamenScalarFieldEnum]


  export const MedicamentoScalarFieldEnum: {
    id_medicamento: 'id_medicamento',
    nombre: 'nombre',
    tipo: 'tipo',
    descripcion: 'descripcion',
    id_proveedor: 'id_proveedor'
  };

  export type MedicamentoScalarFieldEnum = (typeof MedicamentoScalarFieldEnum)[keyof typeof MedicamentoScalarFieldEnum]


  export const PacienteScalarFieldEnum: {
    id_paciente: 'id_paciente',
    nombre: 'nombre',
    segundonombre: 'segundonombre',
    primerapellido: 'primerapellido',
    segundoapellido: 'segundoapellido',
    nacimiento: 'nacimiento',
    id_usuario: 'id_usuario',
    altura: 'altura',
    peso: 'peso',
    sexo: 'sexo',
    tiposangre: 'tiposangre',
    telefono: 'telefono',
    correo: 'correo'
  };

  export type PacienteScalarFieldEnum = (typeof PacienteScalarFieldEnum)[keyof typeof PacienteScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    id_pago: 'id_pago',
    id_paciente: 'id_paciente',
    tipopago: 'tipopago',
    monto: 'monto',
    fechapago: 'fechapago'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const PrescripcionScalarFieldEnum: {
    id_prescripcion: 'id_prescripcion',
    dosisrecomendada: 'dosisrecomendada',
    tipo: 'tipo',
    frecuencia: 'frecuencia',
    id_medicamento: 'id_medicamento',
    id_receta: 'id_receta'
  };

  export type PrescripcionScalarFieldEnum = (typeof PrescripcionScalarFieldEnum)[keyof typeof PrescripcionScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    id_proveedor: 'id_proveedor',
    nombre: 'nombre',
    segundonombre: 'segundonombre',
    primerapellido: 'primerapellido',
    segundoapellido: 'segundoapellido',
    nacimiento: 'nacimiento',
    celular: 'celular',
    telefono: 'telefono',
    id_direccion: 'id_direccion',
    id_usuario: 'id_usuario',
    tipoproveedor: 'tipoproveedor',
    estado: 'estado'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const RecetaScalarFieldEnum: {
    id_receta: 'id_receta',
    fechaemision: 'fechaemision',
    dosisrecomendada: 'dosisrecomendada',
    id_tratamiento: 'id_tratamiento'
  };

  export type RecetaScalarFieldEnum = (typeof RecetaScalarFieldEnum)[keyof typeof RecetaScalarFieldEnum]


  export const SecretariaScalarFieldEnum: {
    id_secretaria: 'id_secretaria',
    nombre: 'nombre',
    segundonombre: 'segundonombre',
    primerapellido: 'primerapellido',
    segundoapellido: 'segundoapellido',
    nacimiento: 'nacimiento',
    telefono: 'telefono',
    id_usuario: 'id_usuario',
    fechacontratacion: 'fechacontratacion',
    salario: 'salario',
    correo: 'correo'
  };

  export type SecretariaScalarFieldEnum = (typeof SecretariaScalarFieldEnum)[keyof typeof SecretariaScalarFieldEnum]


  export const TelefonoScalarFieldEnum: {
    id_telefono: 'id_telefono',
    numero: 'numero',
    tipo: 'tipo'
  };

  export type TelefonoScalarFieldEnum = (typeof TelefonoScalarFieldEnum)[keyof typeof TelefonoScalarFieldEnum]


  export const TratamientoScalarFieldEnum: {
    id_tratamiento: 'id_tratamiento',
    tipotratamiento: 'tipotratamiento',
    descripcion: 'descripcion',
    duracion: 'duracion',
    frecuencia: 'frecuencia',
    id_diagnostico: 'id_diagnostico'
  };

  export type TratamientoScalarFieldEnum = (typeof TratamientoScalarFieldEnum)[keyof typeof TratamientoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    nombre: 'nombre',
    contrasena: 'contrasena',
    rol: 'rol'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type administradorWhereInput = {
    AND?: administradorWhereInput | administradorWhereInput[]
    OR?: administradorWhereInput[]
    NOT?: administradorWhereInput | administradorWhereInput[]
    id_admin?: IntFilter<"administrador"> | number
    nombre?: StringFilter<"administrador"> | string
    segundonombre?: StringNullableFilter<"administrador"> | string | null
    primerapellido?: StringFilter<"administrador"> | string
    segundoapellido?: StringNullableFilter<"administrador"> | string | null
    nacimiento?: DateTimeNullableFilter<"administrador"> | Date | string | null
    celular?: StringNullableFilter<"administrador"> | string | null
    telefono?: StringNullableFilter<"administrador"> | string | null
    id_usuario?: IntNullableFilter<"administrador"> | number | null
    fechaingreso?: DateTimeNullableFilter<"administrador"> | Date | string | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }

  export type administradorOrderByWithRelationInput = {
    id_admin?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechaingreso?: SortOrderInput | SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type administradorWhereUniqueInput = Prisma.AtLeast<{
    id_admin?: number
    AND?: administradorWhereInput | administradorWhereInput[]
    OR?: administradorWhereInput[]
    NOT?: administradorWhereInput | administradorWhereInput[]
    nombre?: StringFilter<"administrador"> | string
    segundonombre?: StringNullableFilter<"administrador"> | string | null
    primerapellido?: StringFilter<"administrador"> | string
    segundoapellido?: StringNullableFilter<"administrador"> | string | null
    nacimiento?: DateTimeNullableFilter<"administrador"> | Date | string | null
    celular?: StringNullableFilter<"administrador"> | string | null
    telefono?: StringNullableFilter<"administrador"> | string | null
    id_usuario?: IntNullableFilter<"administrador"> | number | null
    fechaingreso?: DateTimeNullableFilter<"administrador"> | Date | string | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }, "id_admin">

  export type administradorOrderByWithAggregationInput = {
    id_admin?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechaingreso?: SortOrderInput | SortOrder
    _count?: administradorCountOrderByAggregateInput
    _avg?: administradorAvgOrderByAggregateInput
    _max?: administradorMaxOrderByAggregateInput
    _min?: administradorMinOrderByAggregateInput
    _sum?: administradorSumOrderByAggregateInput
  }

  export type administradorScalarWhereWithAggregatesInput = {
    AND?: administradorScalarWhereWithAggregatesInput | administradorScalarWhereWithAggregatesInput[]
    OR?: administradorScalarWhereWithAggregatesInput[]
    NOT?: administradorScalarWhereWithAggregatesInput | administradorScalarWhereWithAggregatesInput[]
    id_admin?: IntWithAggregatesFilter<"administrador"> | number
    nombre?: StringWithAggregatesFilter<"administrador"> | string
    segundonombre?: StringNullableWithAggregatesFilter<"administrador"> | string | null
    primerapellido?: StringWithAggregatesFilter<"administrador"> | string
    segundoapellido?: StringNullableWithAggregatesFilter<"administrador"> | string | null
    nacimiento?: DateTimeNullableWithAggregatesFilter<"administrador"> | Date | string | null
    celular?: StringNullableWithAggregatesFilter<"administrador"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"administrador"> | string | null
    id_usuario?: IntNullableWithAggregatesFilter<"administrador"> | number | null
    fechaingreso?: DateTimeNullableWithAggregatesFilter<"administrador"> | Date | string | null
  }

  export type citaWhereInput = {
    AND?: citaWhereInput | citaWhereInput[]
    OR?: citaWhereInput[]
    NOT?: citaWhereInput | citaWhereInput[]
    id_cita?: IntFilter<"cita"> | number
    fecha?: DateTimeFilter<"cita"> | Date | string
    horainicio?: DateTimeNullableFilter<"cita"> | Date | string | null
    horafin?: DateTimeNullableFilter<"cita"> | Date | string | null
    estado?: StringNullableFilter<"cita"> | string | null
    motivo?: StringNullableFilter<"cita"> | string | null
    id_doctor?: IntNullableFilter<"cita"> | number | null
    id_paciente?: IntNullableFilter<"cita"> | number | null
    hora_llegada?: DateTimeNullableFilter<"cita"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, doctorWhereInput> | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, pacienteWhereInput> | null
    consulta?: ConsultaListRelationFilter
  }

  export type citaOrderByWithRelationInput = {
    id_cita?: SortOrder
    fecha?: SortOrder
    horainicio?: SortOrderInput | SortOrder
    horafin?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    id_doctor?: SortOrderInput | SortOrder
    id_paciente?: SortOrderInput | SortOrder
    hora_llegada?: SortOrderInput | SortOrder
    doctor?: doctorOrderByWithRelationInput
    paciente?: pacienteOrderByWithRelationInput
    consulta?: consultaOrderByRelationAggregateInput
  }

  export type citaWhereUniqueInput = Prisma.AtLeast<{
    id_cita?: number
    AND?: citaWhereInput | citaWhereInput[]
    OR?: citaWhereInput[]
    NOT?: citaWhereInput | citaWhereInput[]
    fecha?: DateTimeFilter<"cita"> | Date | string
    horainicio?: DateTimeNullableFilter<"cita"> | Date | string | null
    horafin?: DateTimeNullableFilter<"cita"> | Date | string | null
    estado?: StringNullableFilter<"cita"> | string | null
    motivo?: StringNullableFilter<"cita"> | string | null
    id_doctor?: IntNullableFilter<"cita"> | number | null
    id_paciente?: IntNullableFilter<"cita"> | number | null
    hora_llegada?: DateTimeNullableFilter<"cita"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, doctorWhereInput> | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, pacienteWhereInput> | null
    consulta?: ConsultaListRelationFilter
  }, "id_cita">

  export type citaOrderByWithAggregationInput = {
    id_cita?: SortOrder
    fecha?: SortOrder
    horainicio?: SortOrderInput | SortOrder
    horafin?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    id_doctor?: SortOrderInput | SortOrder
    id_paciente?: SortOrderInput | SortOrder
    hora_llegada?: SortOrderInput | SortOrder
    _count?: citaCountOrderByAggregateInput
    _avg?: citaAvgOrderByAggregateInput
    _max?: citaMaxOrderByAggregateInput
    _min?: citaMinOrderByAggregateInput
    _sum?: citaSumOrderByAggregateInput
  }

  export type citaScalarWhereWithAggregatesInput = {
    AND?: citaScalarWhereWithAggregatesInput | citaScalarWhereWithAggregatesInput[]
    OR?: citaScalarWhereWithAggregatesInput[]
    NOT?: citaScalarWhereWithAggregatesInput | citaScalarWhereWithAggregatesInput[]
    id_cita?: IntWithAggregatesFilter<"cita"> | number
    fecha?: DateTimeWithAggregatesFilter<"cita"> | Date | string
    horainicio?: DateTimeNullableWithAggregatesFilter<"cita"> | Date | string | null
    horafin?: DateTimeNullableWithAggregatesFilter<"cita"> | Date | string | null
    estado?: StringNullableWithAggregatesFilter<"cita"> | string | null
    motivo?: StringNullableWithAggregatesFilter<"cita"> | string | null
    id_doctor?: IntNullableWithAggregatesFilter<"cita"> | number | null
    id_paciente?: IntNullableWithAggregatesFilter<"cita"> | number | null
    hora_llegada?: DateTimeNullableWithAggregatesFilter<"cita"> | Date | string | null
  }

  export type consultaWhereInput = {
    AND?: consultaWhereInput | consultaWhereInput[]
    OR?: consultaWhereInput[]
    NOT?: consultaWhereInput | consultaWhereInput[]
    id_consulta?: IntFilter<"consulta"> | number
    fecha?: DateTimeNullableFilter<"consulta"> | Date | string | null
    motivo?: StringNullableFilter<"consulta"> | string | null
    id_cita?: IntNullableFilter<"consulta"> | number | null
    cita?: XOR<CitaNullableScalarRelationFilter, citaWhereInput> | null
    diagnostico?: DiagnosticoListRelationFilter
  }

  export type consultaOrderByWithRelationInput = {
    id_consulta?: SortOrder
    fecha?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    id_cita?: SortOrderInput | SortOrder
    cita?: citaOrderByWithRelationInput
    diagnostico?: diagnosticoOrderByRelationAggregateInput
  }

  export type consultaWhereUniqueInput = Prisma.AtLeast<{
    id_consulta?: number
    AND?: consultaWhereInput | consultaWhereInput[]
    OR?: consultaWhereInput[]
    NOT?: consultaWhereInput | consultaWhereInput[]
    fecha?: DateTimeNullableFilter<"consulta"> | Date | string | null
    motivo?: StringNullableFilter<"consulta"> | string | null
    id_cita?: IntNullableFilter<"consulta"> | number | null
    cita?: XOR<CitaNullableScalarRelationFilter, citaWhereInput> | null
    diagnostico?: DiagnosticoListRelationFilter
  }, "id_consulta">

  export type consultaOrderByWithAggregationInput = {
    id_consulta?: SortOrder
    fecha?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    id_cita?: SortOrderInput | SortOrder
    _count?: consultaCountOrderByAggregateInput
    _avg?: consultaAvgOrderByAggregateInput
    _max?: consultaMaxOrderByAggregateInput
    _min?: consultaMinOrderByAggregateInput
    _sum?: consultaSumOrderByAggregateInput
  }

  export type consultaScalarWhereWithAggregatesInput = {
    AND?: consultaScalarWhereWithAggregatesInput | consultaScalarWhereWithAggregatesInput[]
    OR?: consultaScalarWhereWithAggregatesInput[]
    NOT?: consultaScalarWhereWithAggregatesInput | consultaScalarWhereWithAggregatesInput[]
    id_consulta?: IntWithAggregatesFilter<"consulta"> | number
    fecha?: DateTimeNullableWithAggregatesFilter<"consulta"> | Date | string | null
    motivo?: StringNullableWithAggregatesFilter<"consulta"> | string | null
    id_cita?: IntNullableWithAggregatesFilter<"consulta"> | number | null
  }

  export type detallepagoWhereInput = {
    AND?: detallepagoWhereInput | detallepagoWhereInput[]
    OR?: detallepagoWhereInput[]
    NOT?: detallepagoWhereInput | detallepagoWhereInput[]
    id_detalle_pago?: IntFilter<"detallepago"> | number
    fechapago?: DateTimeNullableFilter<"detallepago"> | Date | string | null
    id_transaccionpp?: IntNullableFilter<"detallepago"> | number | null
  }

  export type detallepagoOrderByWithRelationInput = {
    id_detalle_pago?: SortOrder
    fechapago?: SortOrderInput | SortOrder
    id_transaccionpp?: SortOrderInput | SortOrder
  }

  export type detallepagoWhereUniqueInput = Prisma.AtLeast<{
    id_detalle_pago?: number
    AND?: detallepagoWhereInput | detallepagoWhereInput[]
    OR?: detallepagoWhereInput[]
    NOT?: detallepagoWhereInput | detallepagoWhereInput[]
    fechapago?: DateTimeNullableFilter<"detallepago"> | Date | string | null
    id_transaccionpp?: IntNullableFilter<"detallepago"> | number | null
  }, "id_detalle_pago">

  export type detallepagoOrderByWithAggregationInput = {
    id_detalle_pago?: SortOrder
    fechapago?: SortOrderInput | SortOrder
    id_transaccionpp?: SortOrderInput | SortOrder
    _count?: detallepagoCountOrderByAggregateInput
    _avg?: detallepagoAvgOrderByAggregateInput
    _max?: detallepagoMaxOrderByAggregateInput
    _min?: detallepagoMinOrderByAggregateInput
    _sum?: detallepagoSumOrderByAggregateInput
  }

  export type detallepagoScalarWhereWithAggregatesInput = {
    AND?: detallepagoScalarWhereWithAggregatesInput | detallepagoScalarWhereWithAggregatesInput[]
    OR?: detallepagoScalarWhereWithAggregatesInput[]
    NOT?: detallepagoScalarWhereWithAggregatesInput | detallepagoScalarWhereWithAggregatesInput[]
    id_detalle_pago?: IntWithAggregatesFilter<"detallepago"> | number
    fechapago?: DateTimeNullableWithAggregatesFilter<"detallepago"> | Date | string | null
    id_transaccionpp?: IntNullableWithAggregatesFilter<"detallepago"> | number | null
  }

  export type diagnosticoWhereInput = {
    AND?: diagnosticoWhereInput | diagnosticoWhereInput[]
    OR?: diagnosticoWhereInput[]
    NOT?: diagnosticoWhereInput | diagnosticoWhereInput[]
    id_diagnostico?: IntFilter<"diagnostico"> | number
    nombrediagnostico?: StringNullableFilter<"diagnostico"> | string | null
    descripcion?: StringNullableFilter<"diagnostico"> | string | null
    id_consulta?: IntNullableFilter<"diagnostico"> | number | null
    consulta?: XOR<ConsultaNullableScalarRelationFilter, consultaWhereInput> | null
    tratamiento?: TratamientoListRelationFilter
  }

  export type diagnosticoOrderByWithRelationInput = {
    id_diagnostico?: SortOrder
    nombrediagnostico?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    id_consulta?: SortOrderInput | SortOrder
    consulta?: consultaOrderByWithRelationInput
    tratamiento?: tratamientoOrderByRelationAggregateInput
  }

  export type diagnosticoWhereUniqueInput = Prisma.AtLeast<{
    id_diagnostico?: number
    AND?: diagnosticoWhereInput | diagnosticoWhereInput[]
    OR?: diagnosticoWhereInput[]
    NOT?: diagnosticoWhereInput | diagnosticoWhereInput[]
    nombrediagnostico?: StringNullableFilter<"diagnostico"> | string | null
    descripcion?: StringNullableFilter<"diagnostico"> | string | null
    id_consulta?: IntNullableFilter<"diagnostico"> | number | null
    consulta?: XOR<ConsultaNullableScalarRelationFilter, consultaWhereInput> | null
    tratamiento?: TratamientoListRelationFilter
  }, "id_diagnostico">

  export type diagnosticoOrderByWithAggregationInput = {
    id_diagnostico?: SortOrder
    nombrediagnostico?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    id_consulta?: SortOrderInput | SortOrder
    _count?: diagnosticoCountOrderByAggregateInput
    _avg?: diagnosticoAvgOrderByAggregateInput
    _max?: diagnosticoMaxOrderByAggregateInput
    _min?: diagnosticoMinOrderByAggregateInput
    _sum?: diagnosticoSumOrderByAggregateInput
  }

  export type diagnosticoScalarWhereWithAggregatesInput = {
    AND?: diagnosticoScalarWhereWithAggregatesInput | diagnosticoScalarWhereWithAggregatesInput[]
    OR?: diagnosticoScalarWhereWithAggregatesInput[]
    NOT?: diagnosticoScalarWhereWithAggregatesInput | diagnosticoScalarWhereWithAggregatesInput[]
    id_diagnostico?: IntWithAggregatesFilter<"diagnostico"> | number
    nombrediagnostico?: StringNullableWithAggregatesFilter<"diagnostico"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"diagnostico"> | string | null
    id_consulta?: IntNullableWithAggregatesFilter<"diagnostico"> | number | null
  }

  export type doctorWhereInput = {
    AND?: doctorWhereInput | doctorWhereInput[]
    OR?: doctorWhereInput[]
    NOT?: doctorWhereInput | doctorWhereInput[]
    id_doctor?: IntFilter<"doctor"> | number
    nombre?: StringFilter<"doctor"> | string
    segundonombre?: StringNullableFilter<"doctor"> | string | null
    primerapellido?: StringFilter<"doctor"> | string
    segundoapellido?: StringNullableFilter<"doctor"> | string | null
    nacimiento?: DateTimeNullableFilter<"doctor"> | Date | string | null
    id_usuario?: IntNullableFilter<"doctor"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"doctor"> | Date | string | null
    salario?: FloatNullableFilter<"doctor"> | number | null
    telefono?: StringNullableFilter<"doctor"> | string | null
    correo?: StringNullableFilter<"doctor"> | string | null
    id_especialidad?: IntNullableFilter<"doctor"> | number | null
    cita?: CitaListRelationFilter
    especialidad?: XOR<EspecialidadNullableScalarRelationFilter, especialidadWhereInput> | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
    especialidad_doctor?: Especialidad_doctorListRelationFilter
  }

  export type doctorOrderByWithRelationInput = {
    id_doctor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechacontratacion?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    id_especialidad?: SortOrderInput | SortOrder
    cita?: citaOrderByRelationAggregateInput
    especialidad?: especialidadOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    especialidad_doctor?: especialidad_doctorOrderByRelationAggregateInput
  }

  export type doctorWhereUniqueInput = Prisma.AtLeast<{
    id_doctor?: number
    AND?: doctorWhereInput | doctorWhereInput[]
    OR?: doctorWhereInput[]
    NOT?: doctorWhereInput | doctorWhereInput[]
    nombre?: StringFilter<"doctor"> | string
    segundonombre?: StringNullableFilter<"doctor"> | string | null
    primerapellido?: StringFilter<"doctor"> | string
    segundoapellido?: StringNullableFilter<"doctor"> | string | null
    nacimiento?: DateTimeNullableFilter<"doctor"> | Date | string | null
    id_usuario?: IntNullableFilter<"doctor"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"doctor"> | Date | string | null
    salario?: FloatNullableFilter<"doctor"> | number | null
    telefono?: StringNullableFilter<"doctor"> | string | null
    correo?: StringNullableFilter<"doctor"> | string | null
    id_especialidad?: IntNullableFilter<"doctor"> | number | null
    cita?: CitaListRelationFilter
    especialidad?: XOR<EspecialidadNullableScalarRelationFilter, especialidadWhereInput> | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
    especialidad_doctor?: Especialidad_doctorListRelationFilter
  }, "id_doctor">

  export type doctorOrderByWithAggregationInput = {
    id_doctor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechacontratacion?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    id_especialidad?: SortOrderInput | SortOrder
    _count?: doctorCountOrderByAggregateInput
    _avg?: doctorAvgOrderByAggregateInput
    _max?: doctorMaxOrderByAggregateInput
    _min?: doctorMinOrderByAggregateInput
    _sum?: doctorSumOrderByAggregateInput
  }

  export type doctorScalarWhereWithAggregatesInput = {
    AND?: doctorScalarWhereWithAggregatesInput | doctorScalarWhereWithAggregatesInput[]
    OR?: doctorScalarWhereWithAggregatesInput[]
    NOT?: doctorScalarWhereWithAggregatesInput | doctorScalarWhereWithAggregatesInput[]
    id_doctor?: IntWithAggregatesFilter<"doctor"> | number
    nombre?: StringWithAggregatesFilter<"doctor"> | string
    segundonombre?: StringNullableWithAggregatesFilter<"doctor"> | string | null
    primerapellido?: StringWithAggregatesFilter<"doctor"> | string
    segundoapellido?: StringNullableWithAggregatesFilter<"doctor"> | string | null
    nacimiento?: DateTimeNullableWithAggregatesFilter<"doctor"> | Date | string | null
    id_usuario?: IntNullableWithAggregatesFilter<"doctor"> | number | null
    fechacontratacion?: DateTimeNullableWithAggregatesFilter<"doctor"> | Date | string | null
    salario?: FloatNullableWithAggregatesFilter<"doctor"> | number | null
    telefono?: StringNullableWithAggregatesFilter<"doctor"> | string | null
    correo?: StringNullableWithAggregatesFilter<"doctor"> | string | null
    id_especialidad?: IntNullableWithAggregatesFilter<"doctor"> | number | null
  }

  export type especialidadWhereInput = {
    AND?: especialidadWhereInput | especialidadWhereInput[]
    OR?: especialidadWhereInput[]
    NOT?: especialidadWhereInput | especialidadWhereInput[]
    id_especialidad?: IntFilter<"especialidad"> | number
    nombreespecialidad?: StringNullableFilter<"especialidad"> | string | null
    descripcion?: StringNullableFilter<"especialidad"> | string | null
    doctor?: DoctorListRelationFilter
    especialidad_doctor?: Especialidad_doctorListRelationFilter
  }

  export type especialidadOrderByWithRelationInput = {
    id_especialidad?: SortOrder
    nombreespecialidad?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    doctor?: doctorOrderByRelationAggregateInput
    especialidad_doctor?: especialidad_doctorOrderByRelationAggregateInput
  }

  export type especialidadWhereUniqueInput = Prisma.AtLeast<{
    id_especialidad?: number
    AND?: especialidadWhereInput | especialidadWhereInput[]
    OR?: especialidadWhereInput[]
    NOT?: especialidadWhereInput | especialidadWhereInput[]
    nombreespecialidad?: StringNullableFilter<"especialidad"> | string | null
    descripcion?: StringNullableFilter<"especialidad"> | string | null
    doctor?: DoctorListRelationFilter
    especialidad_doctor?: Especialidad_doctorListRelationFilter
  }, "id_especialidad">

  export type especialidadOrderByWithAggregationInput = {
    id_especialidad?: SortOrder
    nombreespecialidad?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: especialidadCountOrderByAggregateInput
    _avg?: especialidadAvgOrderByAggregateInput
    _max?: especialidadMaxOrderByAggregateInput
    _min?: especialidadMinOrderByAggregateInput
    _sum?: especialidadSumOrderByAggregateInput
  }

  export type especialidadScalarWhereWithAggregatesInput = {
    AND?: especialidadScalarWhereWithAggregatesInput | especialidadScalarWhereWithAggregatesInput[]
    OR?: especialidadScalarWhereWithAggregatesInput[]
    NOT?: especialidadScalarWhereWithAggregatesInput | especialidadScalarWhereWithAggregatesInput[]
    id_especialidad?: IntWithAggregatesFilter<"especialidad"> | number
    nombreespecialidad?: StringNullableWithAggregatesFilter<"especialidad"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"especialidad"> | string | null
  }

  export type especialidad_doctorWhereInput = {
    AND?: especialidad_doctorWhereInput | especialidad_doctorWhereInput[]
    OR?: especialidad_doctorWhereInput[]
    NOT?: especialidad_doctorWhereInput | especialidad_doctorWhereInput[]
    id_especialidad_doctor?: IntFilter<"especialidad_doctor"> | number
    id_doctor?: IntNullableFilter<"especialidad_doctor"> | number | null
    id_especialidad?: IntNullableFilter<"especialidad_doctor"> | number | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, doctorWhereInput> | null
    especialidad?: XOR<EspecialidadNullableScalarRelationFilter, especialidadWhereInput> | null
  }

  export type especialidad_doctorOrderByWithRelationInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrderInput | SortOrder
    id_especialidad?: SortOrderInput | SortOrder
    doctor?: doctorOrderByWithRelationInput
    especialidad?: especialidadOrderByWithRelationInput
  }

  export type especialidad_doctorWhereUniqueInput = Prisma.AtLeast<{
    id_especialidad_doctor?: number
    AND?: especialidad_doctorWhereInput | especialidad_doctorWhereInput[]
    OR?: especialidad_doctorWhereInput[]
    NOT?: especialidad_doctorWhereInput | especialidad_doctorWhereInput[]
    id_doctor?: IntNullableFilter<"especialidad_doctor"> | number | null
    id_especialidad?: IntNullableFilter<"especialidad_doctor"> | number | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, doctorWhereInput> | null
    especialidad?: XOR<EspecialidadNullableScalarRelationFilter, especialidadWhereInput> | null
  }, "id_especialidad_doctor">

  export type especialidad_doctorOrderByWithAggregationInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrderInput | SortOrder
    id_especialidad?: SortOrderInput | SortOrder
    _count?: especialidad_doctorCountOrderByAggregateInput
    _avg?: especialidad_doctorAvgOrderByAggregateInput
    _max?: especialidad_doctorMaxOrderByAggregateInput
    _min?: especialidad_doctorMinOrderByAggregateInput
    _sum?: especialidad_doctorSumOrderByAggregateInput
  }

  export type especialidad_doctorScalarWhereWithAggregatesInput = {
    AND?: especialidad_doctorScalarWhereWithAggregatesInput | especialidad_doctorScalarWhereWithAggregatesInput[]
    OR?: especialidad_doctorScalarWhereWithAggregatesInput[]
    NOT?: especialidad_doctorScalarWhereWithAggregatesInput | especialidad_doctorScalarWhereWithAggregatesInput[]
    id_especialidad_doctor?: IntWithAggregatesFilter<"especialidad_doctor"> | number
    id_doctor?: IntNullableWithAggregatesFilter<"especialidad_doctor"> | number | null
    id_especialidad?: IntNullableWithAggregatesFilter<"especialidad_doctor"> | number | null
  }

  export type examenWhereInput = {
    AND?: examenWhereInput | examenWhereInput[]
    OR?: examenWhereInput[]
    NOT?: examenWhereInput | examenWhereInput[]
    id_examen?: IntFilter<"examen"> | number
    tipoexamen?: StringNullableFilter<"examen"> | string | null
    rutaExamen?: StringNullableFilter<"examen"> | string | null
    id_paciente?: IntNullableFilter<"examen"> | number | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, pacienteWhereInput> | null
  }

  export type examenOrderByWithRelationInput = {
    id_examen?: SortOrder
    tipoexamen?: SortOrderInput | SortOrder
    rutaExamen?: SortOrderInput | SortOrder
    id_paciente?: SortOrderInput | SortOrder
    paciente?: pacienteOrderByWithRelationInput
  }

  export type examenWhereUniqueInput = Prisma.AtLeast<{
    id_examen?: number
    AND?: examenWhereInput | examenWhereInput[]
    OR?: examenWhereInput[]
    NOT?: examenWhereInput | examenWhereInput[]
    tipoexamen?: StringNullableFilter<"examen"> | string | null
    rutaExamen?: StringNullableFilter<"examen"> | string | null
    id_paciente?: IntNullableFilter<"examen"> | number | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, pacienteWhereInput> | null
  }, "id_examen">

  export type examenOrderByWithAggregationInput = {
    id_examen?: SortOrder
    tipoexamen?: SortOrderInput | SortOrder
    rutaExamen?: SortOrderInput | SortOrder
    id_paciente?: SortOrderInput | SortOrder
    _count?: examenCountOrderByAggregateInput
    _avg?: examenAvgOrderByAggregateInput
    _max?: examenMaxOrderByAggregateInput
    _min?: examenMinOrderByAggregateInput
    _sum?: examenSumOrderByAggregateInput
  }

  export type examenScalarWhereWithAggregatesInput = {
    AND?: examenScalarWhereWithAggregatesInput | examenScalarWhereWithAggregatesInput[]
    OR?: examenScalarWhereWithAggregatesInput[]
    NOT?: examenScalarWhereWithAggregatesInput | examenScalarWhereWithAggregatesInput[]
    id_examen?: IntWithAggregatesFilter<"examen"> | number
    tipoexamen?: StringNullableWithAggregatesFilter<"examen"> | string | null
    rutaExamen?: StringNullableWithAggregatesFilter<"examen"> | string | null
    id_paciente?: IntNullableWithAggregatesFilter<"examen"> | number | null
  }

  export type medicamentoWhereInput = {
    AND?: medicamentoWhereInput | medicamentoWhereInput[]
    OR?: medicamentoWhereInput[]
    NOT?: medicamentoWhereInput | medicamentoWhereInput[]
    id_medicamento?: IntFilter<"medicamento"> | number
    nombre?: StringNullableFilter<"medicamento"> | string | null
    tipo?: StringNullableFilter<"medicamento"> | string | null
    descripcion?: StringNullableFilter<"medicamento"> | string | null
    id_proveedor?: IntNullableFilter<"medicamento"> | number | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, proveedorWhereInput> | null
  }

  export type medicamentoOrderByWithRelationInput = {
    id_medicamento?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    id_proveedor?: SortOrderInput | SortOrder
    proveedor?: proveedorOrderByWithRelationInput
  }

  export type medicamentoWhereUniqueInput = Prisma.AtLeast<{
    id_medicamento?: number
    AND?: medicamentoWhereInput | medicamentoWhereInput[]
    OR?: medicamentoWhereInput[]
    NOT?: medicamentoWhereInput | medicamentoWhereInput[]
    nombre?: StringNullableFilter<"medicamento"> | string | null
    tipo?: StringNullableFilter<"medicamento"> | string | null
    descripcion?: StringNullableFilter<"medicamento"> | string | null
    id_proveedor?: IntNullableFilter<"medicamento"> | number | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, proveedorWhereInput> | null
  }, "id_medicamento">

  export type medicamentoOrderByWithAggregationInput = {
    id_medicamento?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    id_proveedor?: SortOrderInput | SortOrder
    _count?: medicamentoCountOrderByAggregateInput
    _avg?: medicamentoAvgOrderByAggregateInput
    _max?: medicamentoMaxOrderByAggregateInput
    _min?: medicamentoMinOrderByAggregateInput
    _sum?: medicamentoSumOrderByAggregateInput
  }

  export type medicamentoScalarWhereWithAggregatesInput = {
    AND?: medicamentoScalarWhereWithAggregatesInput | medicamentoScalarWhereWithAggregatesInput[]
    OR?: medicamentoScalarWhereWithAggregatesInput[]
    NOT?: medicamentoScalarWhereWithAggregatesInput | medicamentoScalarWhereWithAggregatesInput[]
    id_medicamento?: IntWithAggregatesFilter<"medicamento"> | number
    nombre?: StringNullableWithAggregatesFilter<"medicamento"> | string | null
    tipo?: StringNullableWithAggregatesFilter<"medicamento"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"medicamento"> | string | null
    id_proveedor?: IntNullableWithAggregatesFilter<"medicamento"> | number | null
  }

  export type pacienteWhereInput = {
    AND?: pacienteWhereInput | pacienteWhereInput[]
    OR?: pacienteWhereInput[]
    NOT?: pacienteWhereInput | pacienteWhereInput[]
    id_paciente?: IntFilter<"paciente"> | number
    nombre?: StringFilter<"paciente"> | string
    segundonombre?: StringNullableFilter<"paciente"> | string | null
    primerapellido?: StringFilter<"paciente"> | string
    segundoapellido?: StringNullableFilter<"paciente"> | string | null
    nacimiento?: DateTimeNullableFilter<"paciente"> | Date | string | null
    id_usuario?: IntNullableFilter<"paciente"> | number | null
    altura?: FloatNullableFilter<"paciente"> | number | null
    peso?: FloatNullableFilter<"paciente"> | number | null
    sexo?: StringNullableFilter<"paciente"> | string | null
    tiposangre?: StringNullableFilter<"paciente"> | string | null
    telefono?: StringNullableFilter<"paciente"> | string | null
    correo?: StringNullableFilter<"paciente"> | string | null
    cita?: CitaListRelationFilter
    examen?: ExamenListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
    pago?: PagoListRelationFilter
  }

  export type pacienteOrderByWithRelationInput = {
    id_paciente?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    tiposangre?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    cita?: citaOrderByRelationAggregateInput
    examen?: examenOrderByRelationAggregateInput
    usuario?: usuarioOrderByWithRelationInput
    pago?: pagoOrderByRelationAggregateInput
  }

  export type pacienteWhereUniqueInput = Prisma.AtLeast<{
    id_paciente?: number
    AND?: pacienteWhereInput | pacienteWhereInput[]
    OR?: pacienteWhereInput[]
    NOT?: pacienteWhereInput | pacienteWhereInput[]
    nombre?: StringFilter<"paciente"> | string
    segundonombre?: StringNullableFilter<"paciente"> | string | null
    primerapellido?: StringFilter<"paciente"> | string
    segundoapellido?: StringNullableFilter<"paciente"> | string | null
    nacimiento?: DateTimeNullableFilter<"paciente"> | Date | string | null
    id_usuario?: IntNullableFilter<"paciente"> | number | null
    altura?: FloatNullableFilter<"paciente"> | number | null
    peso?: FloatNullableFilter<"paciente"> | number | null
    sexo?: StringNullableFilter<"paciente"> | string | null
    tiposangre?: StringNullableFilter<"paciente"> | string | null
    telefono?: StringNullableFilter<"paciente"> | string | null
    correo?: StringNullableFilter<"paciente"> | string | null
    cita?: CitaListRelationFilter
    examen?: ExamenListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
    pago?: PagoListRelationFilter
  }, "id_paciente">

  export type pacienteOrderByWithAggregationInput = {
    id_paciente?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    tiposangre?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    _count?: pacienteCountOrderByAggregateInput
    _avg?: pacienteAvgOrderByAggregateInput
    _max?: pacienteMaxOrderByAggregateInput
    _min?: pacienteMinOrderByAggregateInput
    _sum?: pacienteSumOrderByAggregateInput
  }

  export type pacienteScalarWhereWithAggregatesInput = {
    AND?: pacienteScalarWhereWithAggregatesInput | pacienteScalarWhereWithAggregatesInput[]
    OR?: pacienteScalarWhereWithAggregatesInput[]
    NOT?: pacienteScalarWhereWithAggregatesInput | pacienteScalarWhereWithAggregatesInput[]
    id_paciente?: IntWithAggregatesFilter<"paciente"> | number
    nombre?: StringWithAggregatesFilter<"paciente"> | string
    segundonombre?: StringNullableWithAggregatesFilter<"paciente"> | string | null
    primerapellido?: StringWithAggregatesFilter<"paciente"> | string
    segundoapellido?: StringNullableWithAggregatesFilter<"paciente"> | string | null
    nacimiento?: DateTimeNullableWithAggregatesFilter<"paciente"> | Date | string | null
    id_usuario?: IntNullableWithAggregatesFilter<"paciente"> | number | null
    altura?: FloatNullableWithAggregatesFilter<"paciente"> | number | null
    peso?: FloatNullableWithAggregatesFilter<"paciente"> | number | null
    sexo?: StringNullableWithAggregatesFilter<"paciente"> | string | null
    tiposangre?: StringNullableWithAggregatesFilter<"paciente"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"paciente"> | string | null
    correo?: StringNullableWithAggregatesFilter<"paciente"> | string | null
  }

  export type pagoWhereInput = {
    AND?: pagoWhereInput | pagoWhereInput[]
    OR?: pagoWhereInput[]
    NOT?: pagoWhereInput | pagoWhereInput[]
    id_pago?: IntFilter<"pago"> | number
    id_paciente?: IntFilter<"pago"> | number
    tipopago?: StringFilter<"pago"> | string
    monto?: FloatFilter<"pago"> | number
    fechapago?: DateTimeNullableFilter<"pago"> | Date | string | null
    paciente?: XOR<PacienteScalarRelationFilter, pacienteWhereInput>
  }

  export type pagoOrderByWithRelationInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    tipopago?: SortOrder
    monto?: SortOrder
    fechapago?: SortOrderInput | SortOrder
    paciente?: pacienteOrderByWithRelationInput
  }

  export type pagoWhereUniqueInput = Prisma.AtLeast<{
    id_pago?: number
    AND?: pagoWhereInput | pagoWhereInput[]
    OR?: pagoWhereInput[]
    NOT?: pagoWhereInput | pagoWhereInput[]
    id_paciente?: IntFilter<"pago"> | number
    tipopago?: StringFilter<"pago"> | string
    monto?: FloatFilter<"pago"> | number
    fechapago?: DateTimeNullableFilter<"pago"> | Date | string | null
    paciente?: XOR<PacienteScalarRelationFilter, pacienteWhereInput>
  }, "id_pago">

  export type pagoOrderByWithAggregationInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    tipopago?: SortOrder
    monto?: SortOrder
    fechapago?: SortOrderInput | SortOrder
    _count?: pagoCountOrderByAggregateInput
    _avg?: pagoAvgOrderByAggregateInput
    _max?: pagoMaxOrderByAggregateInput
    _min?: pagoMinOrderByAggregateInput
    _sum?: pagoSumOrderByAggregateInput
  }

  export type pagoScalarWhereWithAggregatesInput = {
    AND?: pagoScalarWhereWithAggregatesInput | pagoScalarWhereWithAggregatesInput[]
    OR?: pagoScalarWhereWithAggregatesInput[]
    NOT?: pagoScalarWhereWithAggregatesInput | pagoScalarWhereWithAggregatesInput[]
    id_pago?: IntWithAggregatesFilter<"pago"> | number
    id_paciente?: IntWithAggregatesFilter<"pago"> | number
    tipopago?: StringWithAggregatesFilter<"pago"> | string
    monto?: FloatWithAggregatesFilter<"pago"> | number
    fechapago?: DateTimeNullableWithAggregatesFilter<"pago"> | Date | string | null
  }

  export type prescripcionWhereInput = {
    AND?: prescripcionWhereInput | prescripcionWhereInput[]
    OR?: prescripcionWhereInput[]
    NOT?: prescripcionWhereInput | prescripcionWhereInput[]
    id_prescripcion?: IntFilter<"prescripcion"> | number
    dosisrecomendada?: StringNullableFilter<"prescripcion"> | string | null
    tipo?: StringNullableFilter<"prescripcion"> | string | null
    frecuencia?: StringNullableFilter<"prescripcion"> | string | null
    id_medicamento?: IntNullableFilter<"prescripcion"> | number | null
    id_receta?: IntNullableFilter<"prescripcion"> | number | null
    receta?: XOR<RecetaNullableScalarRelationFilter, recetaWhereInput> | null
  }

  export type prescripcionOrderByWithRelationInput = {
    id_prescripcion?: SortOrder
    dosisrecomendada?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    frecuencia?: SortOrderInput | SortOrder
    id_medicamento?: SortOrderInput | SortOrder
    id_receta?: SortOrderInput | SortOrder
    receta?: recetaOrderByWithRelationInput
  }

  export type prescripcionWhereUniqueInput = Prisma.AtLeast<{
    id_prescripcion?: number
    AND?: prescripcionWhereInput | prescripcionWhereInput[]
    OR?: prescripcionWhereInput[]
    NOT?: prescripcionWhereInput | prescripcionWhereInput[]
    dosisrecomendada?: StringNullableFilter<"prescripcion"> | string | null
    tipo?: StringNullableFilter<"prescripcion"> | string | null
    frecuencia?: StringNullableFilter<"prescripcion"> | string | null
    id_medicamento?: IntNullableFilter<"prescripcion"> | number | null
    id_receta?: IntNullableFilter<"prescripcion"> | number | null
    receta?: XOR<RecetaNullableScalarRelationFilter, recetaWhereInput> | null
  }, "id_prescripcion">

  export type prescripcionOrderByWithAggregationInput = {
    id_prescripcion?: SortOrder
    dosisrecomendada?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    frecuencia?: SortOrderInput | SortOrder
    id_medicamento?: SortOrderInput | SortOrder
    id_receta?: SortOrderInput | SortOrder
    _count?: prescripcionCountOrderByAggregateInput
    _avg?: prescripcionAvgOrderByAggregateInput
    _max?: prescripcionMaxOrderByAggregateInput
    _min?: prescripcionMinOrderByAggregateInput
    _sum?: prescripcionSumOrderByAggregateInput
  }

  export type prescripcionScalarWhereWithAggregatesInput = {
    AND?: prescripcionScalarWhereWithAggregatesInput | prescripcionScalarWhereWithAggregatesInput[]
    OR?: prescripcionScalarWhereWithAggregatesInput[]
    NOT?: prescripcionScalarWhereWithAggregatesInput | prescripcionScalarWhereWithAggregatesInput[]
    id_prescripcion?: IntWithAggregatesFilter<"prescripcion"> | number
    dosisrecomendada?: StringNullableWithAggregatesFilter<"prescripcion"> | string | null
    tipo?: StringNullableWithAggregatesFilter<"prescripcion"> | string | null
    frecuencia?: StringNullableWithAggregatesFilter<"prescripcion"> | string | null
    id_medicamento?: IntNullableWithAggregatesFilter<"prescripcion"> | number | null
    id_receta?: IntNullableWithAggregatesFilter<"prescripcion"> | number | null
  }

  export type proveedorWhereInput = {
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    id_proveedor?: IntFilter<"proveedor"> | number
    nombre?: StringFilter<"proveedor"> | string
    segundonombre?: StringNullableFilter<"proveedor"> | string | null
    primerapellido?: StringNullableFilter<"proveedor"> | string | null
    segundoapellido?: StringNullableFilter<"proveedor"> | string | null
    nacimiento?: DateTimeNullableFilter<"proveedor"> | Date | string | null
    celular?: StringNullableFilter<"proveedor"> | string | null
    telefono?: StringNullableFilter<"proveedor"> | string | null
    id_direccion?: IntNullableFilter<"proveedor"> | number | null
    id_usuario?: IntNullableFilter<"proveedor"> | number | null
    tipoproveedor?: StringNullableFilter<"proveedor"> | string | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
    medicamento?: MedicamentoListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }

  export type proveedorOrderByWithRelationInput = {
    id_proveedor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrderInput | SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_direccion?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    tipoproveedor?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    medicamento?: medicamentoOrderByRelationAggregateInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type proveedorWhereUniqueInput = Prisma.AtLeast<{
    id_proveedor?: number
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    nombre?: StringFilter<"proveedor"> | string
    segundonombre?: StringNullableFilter<"proveedor"> | string | null
    primerapellido?: StringNullableFilter<"proveedor"> | string | null
    segundoapellido?: StringNullableFilter<"proveedor"> | string | null
    nacimiento?: DateTimeNullableFilter<"proveedor"> | Date | string | null
    celular?: StringNullableFilter<"proveedor"> | string | null
    telefono?: StringNullableFilter<"proveedor"> | string | null
    id_direccion?: IntNullableFilter<"proveedor"> | number | null
    id_usuario?: IntNullableFilter<"proveedor"> | number | null
    tipoproveedor?: StringNullableFilter<"proveedor"> | string | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
    medicamento?: MedicamentoListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }, "id_proveedor">

  export type proveedorOrderByWithAggregationInput = {
    id_proveedor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrderInput | SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_direccion?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    tipoproveedor?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: proveedorCountOrderByAggregateInput
    _avg?: proveedorAvgOrderByAggregateInput
    _max?: proveedorMaxOrderByAggregateInput
    _min?: proveedorMinOrderByAggregateInput
    _sum?: proveedorSumOrderByAggregateInput
  }

  export type proveedorScalarWhereWithAggregatesInput = {
    AND?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    OR?: proveedorScalarWhereWithAggregatesInput[]
    NOT?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    id_proveedor?: IntWithAggregatesFilter<"proveedor"> | number
    nombre?: StringWithAggregatesFilter<"proveedor"> | string
    segundonombre?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    primerapellido?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    segundoapellido?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    nacimiento?: DateTimeNullableWithAggregatesFilter<"proveedor"> | Date | string | null
    celular?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    id_direccion?: IntNullableWithAggregatesFilter<"proveedor"> | number | null
    id_usuario?: IntNullableWithAggregatesFilter<"proveedor"> | number | null
    tipoproveedor?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    estado?: BoolNullableWithAggregatesFilter<"proveedor"> | boolean | null
  }

  export type recetaWhereInput = {
    AND?: recetaWhereInput | recetaWhereInput[]
    OR?: recetaWhereInput[]
    NOT?: recetaWhereInput | recetaWhereInput[]
    id_receta?: IntFilter<"receta"> | number
    fechaemision?: DateTimeNullableFilter<"receta"> | Date | string | null
    dosisrecomendada?: StringNullableFilter<"receta"> | string | null
    id_tratamiento?: IntNullableFilter<"receta"> | number | null
    prescripcion?: PrescripcionListRelationFilter
    tratamiento?: XOR<TratamientoNullableScalarRelationFilter, tratamientoWhereInput> | null
  }

  export type recetaOrderByWithRelationInput = {
    id_receta?: SortOrder
    fechaemision?: SortOrderInput | SortOrder
    dosisrecomendada?: SortOrderInput | SortOrder
    id_tratamiento?: SortOrderInput | SortOrder
    prescripcion?: prescripcionOrderByRelationAggregateInput
    tratamiento?: tratamientoOrderByWithRelationInput
  }

  export type recetaWhereUniqueInput = Prisma.AtLeast<{
    id_receta?: number
    AND?: recetaWhereInput | recetaWhereInput[]
    OR?: recetaWhereInput[]
    NOT?: recetaWhereInput | recetaWhereInput[]
    fechaemision?: DateTimeNullableFilter<"receta"> | Date | string | null
    dosisrecomendada?: StringNullableFilter<"receta"> | string | null
    id_tratamiento?: IntNullableFilter<"receta"> | number | null
    prescripcion?: PrescripcionListRelationFilter
    tratamiento?: XOR<TratamientoNullableScalarRelationFilter, tratamientoWhereInput> | null
  }, "id_receta">

  export type recetaOrderByWithAggregationInput = {
    id_receta?: SortOrder
    fechaemision?: SortOrderInput | SortOrder
    dosisrecomendada?: SortOrderInput | SortOrder
    id_tratamiento?: SortOrderInput | SortOrder
    _count?: recetaCountOrderByAggregateInput
    _avg?: recetaAvgOrderByAggregateInput
    _max?: recetaMaxOrderByAggregateInput
    _min?: recetaMinOrderByAggregateInput
    _sum?: recetaSumOrderByAggregateInput
  }

  export type recetaScalarWhereWithAggregatesInput = {
    AND?: recetaScalarWhereWithAggregatesInput | recetaScalarWhereWithAggregatesInput[]
    OR?: recetaScalarWhereWithAggregatesInput[]
    NOT?: recetaScalarWhereWithAggregatesInput | recetaScalarWhereWithAggregatesInput[]
    id_receta?: IntWithAggregatesFilter<"receta"> | number
    fechaemision?: DateTimeNullableWithAggregatesFilter<"receta"> | Date | string | null
    dosisrecomendada?: StringNullableWithAggregatesFilter<"receta"> | string | null
    id_tratamiento?: IntNullableWithAggregatesFilter<"receta"> | number | null
  }

  export type secretariaWhereInput = {
    AND?: secretariaWhereInput | secretariaWhereInput[]
    OR?: secretariaWhereInput[]
    NOT?: secretariaWhereInput | secretariaWhereInput[]
    id_secretaria?: IntFilter<"secretaria"> | number
    nombre?: StringFilter<"secretaria"> | string
    segundonombre?: StringNullableFilter<"secretaria"> | string | null
    primerapellido?: StringFilter<"secretaria"> | string
    segundoapellido?: StringNullableFilter<"secretaria"> | string | null
    nacimiento?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    telefono?: StringNullableFilter<"secretaria"> | string | null
    id_usuario?: IntNullableFilter<"secretaria"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    salario?: FloatNullableFilter<"secretaria"> | number | null
    correo?: StringNullableFilter<"secretaria"> | string | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }

  export type secretariaOrderByWithRelationInput = {
    id_secretaria?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechacontratacion?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type secretariaWhereUniqueInput = Prisma.AtLeast<{
    id_secretaria?: number
    AND?: secretariaWhereInput | secretariaWhereInput[]
    OR?: secretariaWhereInput[]
    NOT?: secretariaWhereInput | secretariaWhereInput[]
    nombre?: StringFilter<"secretaria"> | string
    segundonombre?: StringNullableFilter<"secretaria"> | string | null
    primerapellido?: StringFilter<"secretaria"> | string
    segundoapellido?: StringNullableFilter<"secretaria"> | string | null
    nacimiento?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    telefono?: StringNullableFilter<"secretaria"> | string | null
    id_usuario?: IntNullableFilter<"secretaria"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    salario?: FloatNullableFilter<"secretaria"> | number | null
    correo?: StringNullableFilter<"secretaria"> | string | null
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }, "id_secretaria">

  export type secretariaOrderByWithAggregationInput = {
    id_secretaria?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrderInput | SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrderInput | SortOrder
    nacimiento?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    fechacontratacion?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    _count?: secretariaCountOrderByAggregateInput
    _avg?: secretariaAvgOrderByAggregateInput
    _max?: secretariaMaxOrderByAggregateInput
    _min?: secretariaMinOrderByAggregateInput
    _sum?: secretariaSumOrderByAggregateInput
  }

  export type secretariaScalarWhereWithAggregatesInput = {
    AND?: secretariaScalarWhereWithAggregatesInput | secretariaScalarWhereWithAggregatesInput[]
    OR?: secretariaScalarWhereWithAggregatesInput[]
    NOT?: secretariaScalarWhereWithAggregatesInput | secretariaScalarWhereWithAggregatesInput[]
    id_secretaria?: IntWithAggregatesFilter<"secretaria"> | number
    nombre?: StringWithAggregatesFilter<"secretaria"> | string
    segundonombre?: StringNullableWithAggregatesFilter<"secretaria"> | string | null
    primerapellido?: StringWithAggregatesFilter<"secretaria"> | string
    segundoapellido?: StringNullableWithAggregatesFilter<"secretaria"> | string | null
    nacimiento?: DateTimeNullableWithAggregatesFilter<"secretaria"> | Date | string | null
    telefono?: StringNullableWithAggregatesFilter<"secretaria"> | string | null
    id_usuario?: IntNullableWithAggregatesFilter<"secretaria"> | number | null
    fechacontratacion?: DateTimeNullableWithAggregatesFilter<"secretaria"> | Date | string | null
    salario?: FloatNullableWithAggregatesFilter<"secretaria"> | number | null
    correo?: StringNullableWithAggregatesFilter<"secretaria"> | string | null
  }

  export type telefonoWhereInput = {
    AND?: telefonoWhereInput | telefonoWhereInput[]
    OR?: telefonoWhereInput[]
    NOT?: telefonoWhereInput | telefonoWhereInput[]
    id_telefono?: IntFilter<"telefono"> | number
    numero?: StringFilter<"telefono"> | string
    tipo?: StringNullableFilter<"telefono"> | string | null
  }

  export type telefonoOrderByWithRelationInput = {
    id_telefono?: SortOrder
    numero?: SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type telefonoWhereUniqueInput = Prisma.AtLeast<{
    id_telefono?: number
    AND?: telefonoWhereInput | telefonoWhereInput[]
    OR?: telefonoWhereInput[]
    NOT?: telefonoWhereInput | telefonoWhereInput[]
    numero?: StringFilter<"telefono"> | string
    tipo?: StringNullableFilter<"telefono"> | string | null
  }, "id_telefono">

  export type telefonoOrderByWithAggregationInput = {
    id_telefono?: SortOrder
    numero?: SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: telefonoCountOrderByAggregateInput
    _avg?: telefonoAvgOrderByAggregateInput
    _max?: telefonoMaxOrderByAggregateInput
    _min?: telefonoMinOrderByAggregateInput
    _sum?: telefonoSumOrderByAggregateInput
  }

  export type telefonoScalarWhereWithAggregatesInput = {
    AND?: telefonoScalarWhereWithAggregatesInput | telefonoScalarWhereWithAggregatesInput[]
    OR?: telefonoScalarWhereWithAggregatesInput[]
    NOT?: telefonoScalarWhereWithAggregatesInput | telefonoScalarWhereWithAggregatesInput[]
    id_telefono?: IntWithAggregatesFilter<"telefono"> | number
    numero?: StringWithAggregatesFilter<"telefono"> | string
    tipo?: StringNullableWithAggregatesFilter<"telefono"> | string | null
  }

  export type tratamientoWhereInput = {
    AND?: tratamientoWhereInput | tratamientoWhereInput[]
    OR?: tratamientoWhereInput[]
    NOT?: tratamientoWhereInput | tratamientoWhereInput[]
    id_tratamiento?: IntFilter<"tratamiento"> | number
    tipotratamiento?: StringNullableFilter<"tratamiento"> | string | null
    descripcion?: StringNullableFilter<"tratamiento"> | string | null
    duracion?: StringNullableFilter<"tratamiento"> | string | null
    frecuencia?: StringNullableFilter<"tratamiento"> | string | null
    id_diagnostico?: IntNullableFilter<"tratamiento"> | number | null
    receta?: RecetaListRelationFilter
    diagnostico?: XOR<DiagnosticoNullableScalarRelationFilter, diagnosticoWhereInput> | null
  }

  export type tratamientoOrderByWithRelationInput = {
    id_tratamiento?: SortOrder
    tipotratamiento?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    frecuencia?: SortOrderInput | SortOrder
    id_diagnostico?: SortOrderInput | SortOrder
    receta?: recetaOrderByRelationAggregateInput
    diagnostico?: diagnosticoOrderByWithRelationInput
  }

  export type tratamientoWhereUniqueInput = Prisma.AtLeast<{
    id_tratamiento?: number
    AND?: tratamientoWhereInput | tratamientoWhereInput[]
    OR?: tratamientoWhereInput[]
    NOT?: tratamientoWhereInput | tratamientoWhereInput[]
    tipotratamiento?: StringNullableFilter<"tratamiento"> | string | null
    descripcion?: StringNullableFilter<"tratamiento"> | string | null
    duracion?: StringNullableFilter<"tratamiento"> | string | null
    frecuencia?: StringNullableFilter<"tratamiento"> | string | null
    id_diagnostico?: IntNullableFilter<"tratamiento"> | number | null
    receta?: RecetaListRelationFilter
    diagnostico?: XOR<DiagnosticoNullableScalarRelationFilter, diagnosticoWhereInput> | null
  }, "id_tratamiento">

  export type tratamientoOrderByWithAggregationInput = {
    id_tratamiento?: SortOrder
    tipotratamiento?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    frecuencia?: SortOrderInput | SortOrder
    id_diagnostico?: SortOrderInput | SortOrder
    _count?: tratamientoCountOrderByAggregateInput
    _avg?: tratamientoAvgOrderByAggregateInput
    _max?: tratamientoMaxOrderByAggregateInput
    _min?: tratamientoMinOrderByAggregateInput
    _sum?: tratamientoSumOrderByAggregateInput
  }

  export type tratamientoScalarWhereWithAggregatesInput = {
    AND?: tratamientoScalarWhereWithAggregatesInput | tratamientoScalarWhereWithAggregatesInput[]
    OR?: tratamientoScalarWhereWithAggregatesInput[]
    NOT?: tratamientoScalarWhereWithAggregatesInput | tratamientoScalarWhereWithAggregatesInput[]
    id_tratamiento?: IntWithAggregatesFilter<"tratamiento"> | number
    tipotratamiento?: StringNullableWithAggregatesFilter<"tratamiento"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"tratamiento"> | string | null
    duracion?: StringNullableWithAggregatesFilter<"tratamiento"> | string | null
    frecuencia?: StringNullableWithAggregatesFilter<"tratamiento"> | string | null
    id_diagnostico?: IntNullableWithAggregatesFilter<"tratamiento"> | number | null
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    id_usuario?: IntFilter<"usuario"> | number
    nombre?: StringFilter<"usuario"> | string
    contrasena?: StringFilter<"usuario"> | string
    rol?: StringFilter<"usuario"> | string
    administrador?: AdministradorListRelationFilter
    doctor?: DoctorListRelationFilter
    paciente?: PacienteListRelationFilter
    proveedor?: ProveedorListRelationFilter
    secretaria?: SecretariaListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    contrasena?: SortOrder
    rol?: SortOrder
    administrador?: administradorOrderByRelationAggregateInput
    doctor?: doctorOrderByRelationAggregateInput
    paciente?: pacienteOrderByRelationAggregateInput
    proveedor?: proveedorOrderByRelationAggregateInput
    secretaria?: secretariaOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    nombre?: StringFilter<"usuario"> | string
    contrasena?: StringFilter<"usuario"> | string
    rol?: StringFilter<"usuario"> | string
    administrador?: AdministradorListRelationFilter
    doctor?: DoctorListRelationFilter
    paciente?: PacienteListRelationFilter
    proveedor?: ProveedorListRelationFilter
    secretaria?: SecretariaListRelationFilter
  }, "id_usuario">

  export type usuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    contrasena?: SortOrder
    rol?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"usuario"> | number
    nombre?: StringWithAggregatesFilter<"usuario"> | string
    contrasena?: StringWithAggregatesFilter<"usuario"> | string
    rol?: StringWithAggregatesFilter<"usuario"> | string
  }

  export type administradorCreateInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    fechaingreso?: Date | string | null
    usuario?: usuarioCreateNestedOneWithoutAdministradorInput
  }

  export type administradorUncheckedCreateInput = {
    id_admin?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_usuario?: number | null
    fechaingreso?: Date | string | null
  }

  export type administradorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: usuarioUpdateOneWithoutAdministradorNestedInput
  }

  export type administradorUncheckedUpdateInput = {
    id_admin?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administradorCreateManyInput = {
    id_admin?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_usuario?: number | null
    fechaingreso?: Date | string | null
  }

  export type administradorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administradorUncheckedUpdateManyInput = {
    id_admin?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citaCreateInput = {
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    hora_llegada?: Date | string | null
    doctor?: doctorCreateNestedOneWithoutCitaInput
    paciente?: pacienteCreateNestedOneWithoutCitaInput
    consulta?: consultaCreateNestedManyWithoutCitaInput
  }

  export type citaUncheckedCreateInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_doctor?: number | null
    id_paciente?: number | null
    hora_llegada?: Date | string | null
    consulta?: consultaUncheckedCreateNestedManyWithoutCitaInput
  }

  export type citaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: doctorUpdateOneWithoutCitaNestedInput
    paciente?: pacienteUpdateOneWithoutCitaNestedInput
    consulta?: consultaUpdateManyWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consulta?: consultaUncheckedUpdateManyWithoutCitaNestedInput
  }

  export type citaCreateManyInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_doctor?: number | null
    id_paciente?: number | null
    hora_llegada?: Date | string | null
  }

  export type citaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citaUncheckedUpdateManyInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type consultaCreateInput = {
    fecha?: Date | string | null
    motivo?: string | null
    cita?: citaCreateNestedOneWithoutConsultaInput
    diagnostico?: diagnosticoCreateNestedManyWithoutConsultaInput
  }

  export type consultaUncheckedCreateInput = {
    id_consulta?: number
    fecha?: Date | string | null
    motivo?: string | null
    id_cita?: number | null
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutConsultaInput
  }

  export type consultaUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateOneWithoutConsultaNestedInput
    diagnostico?: diagnosticoUpdateManyWithoutConsultaNestedInput
  }

  export type consultaUncheckedUpdateInput = {
    id_consulta?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_cita?: NullableIntFieldUpdateOperationsInput | number | null
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutConsultaNestedInput
  }

  export type consultaCreateManyInput = {
    id_consulta?: number
    fecha?: Date | string | null
    motivo?: string | null
    id_cita?: number | null
  }

  export type consultaUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultaUncheckedUpdateManyInput = {
    id_consulta?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_cita?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detallepagoCreateInput = {
    fechapago?: Date | string | null
    id_transaccionpp?: number | null
  }

  export type detallepagoUncheckedCreateInput = {
    id_detalle_pago?: number
    fechapago?: Date | string | null
    id_transaccionpp?: number | null
  }

  export type detallepagoUpdateInput = {
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_transaccionpp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detallepagoUncheckedUpdateInput = {
    id_detalle_pago?: IntFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_transaccionpp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detallepagoCreateManyInput = {
    id_detalle_pago?: number
    fechapago?: Date | string | null
    id_transaccionpp?: number | null
  }

  export type detallepagoUpdateManyMutationInput = {
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_transaccionpp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detallepagoUncheckedUpdateManyInput = {
    id_detalle_pago?: IntFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_transaccionpp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type diagnosticoCreateInput = {
    nombrediagnostico?: string | null
    descripcion?: string | null
    consulta?: consultaCreateNestedOneWithoutDiagnosticoInput
    tratamiento?: tratamientoCreateNestedManyWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateInput = {
    id_diagnostico?: number
    nombrediagnostico?: string | null
    descripcion?: string | null
    id_consulta?: number | null
    tratamiento?: tratamientoUncheckedCreateNestedManyWithoutDiagnosticoInput
  }

  export type diagnosticoUpdateInput = {
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    consulta?: consultaUpdateOneWithoutDiagnosticoNestedInput
    tratamiento?: tratamientoUpdateManyWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateInput = {
    id_diagnostico?: IntFieldUpdateOperationsInput | number
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    id_consulta?: NullableIntFieldUpdateOperationsInput | number | null
    tratamiento?: tratamientoUncheckedUpdateManyWithoutDiagnosticoNestedInput
  }

  export type diagnosticoCreateManyInput = {
    id_diagnostico?: number
    nombrediagnostico?: string | null
    descripcion?: string | null
    id_consulta?: number | null
  }

  export type diagnosticoUpdateManyMutationInput = {
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosticoUncheckedUpdateManyInput = {
    id_diagnostico?: IntFieldUpdateOperationsInput | number
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    id_consulta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctorCreateInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutDoctorInput
    especialidad?: especialidadCreateNestedOneWithoutDoctorInput
    usuario?: usuarioCreateNestedOneWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutDoctorInput
  }

  export type doctorUncheckedCreateInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
    cita?: citaUncheckedCreateNestedManyWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type doctorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutDoctorNestedInput
    especialidad?: especialidadUpdateOneWithoutDoctorNestedInput
    usuario?: usuarioUpdateOneWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
    cita?: citaUncheckedUpdateManyWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type doctorCreateManyInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
  }

  export type doctorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type doctorUncheckedUpdateManyInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidadCreateInput = {
    nombreespecialidad?: string | null
    descripcion?: string | null
    doctor?: doctorCreateNestedManyWithoutEspecialidadInput
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUncheckedCreateInput = {
    id_especialidad?: number
    nombreespecialidad?: string | null
    descripcion?: string | null
    doctor?: doctorUncheckedCreateNestedManyWithoutEspecialidadInput
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUpdateInput = {
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: doctorUpdateManyWithoutEspecialidadNestedInput
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadUncheckedUpdateInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: doctorUncheckedUpdateManyWithoutEspecialidadNestedInput
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadCreateManyInput = {
    id_especialidad?: number
    nombreespecialidad?: string | null
    descripcion?: string | null
  }

  export type especialidadUpdateManyMutationInput = {
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type especialidadUncheckedUpdateManyInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type especialidad_doctorCreateInput = {
    doctor?: doctorCreateNestedOneWithoutEspecialidad_doctorInput
    especialidad?: especialidadCreateNestedOneWithoutEspecialidad_doctorInput
  }

  export type especialidad_doctorUncheckedCreateInput = {
    id_especialidad_doctor?: number
    id_doctor?: number | null
    id_especialidad?: number | null
  }

  export type especialidad_doctorUpdateInput = {
    doctor?: doctorUpdateOneWithoutEspecialidad_doctorNestedInput
    especialidad?: especialidadUpdateOneWithoutEspecialidad_doctorNestedInput
  }

  export type especialidad_doctorUncheckedUpdateInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidad_doctorCreateManyInput = {
    id_especialidad_doctor?: number
    id_doctor?: number | null
    id_especialidad?: number | null
  }

  export type especialidad_doctorUpdateManyMutationInput = {

  }

  export type especialidad_doctorUncheckedUpdateManyInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type examenCreateInput = {
    tipoexamen?: string | null
    rutaExamen?: string | null
    paciente?: pacienteCreateNestedOneWithoutExamenInput
  }

  export type examenUncheckedCreateInput = {
    id_examen?: number
    tipoexamen?: string | null
    rutaExamen?: string | null
    id_paciente?: number | null
  }

  export type examenUpdateInput = {
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
    paciente?: pacienteUpdateOneWithoutExamenNestedInput
  }

  export type examenUncheckedUpdateInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type examenCreateManyInput = {
    id_examen?: number
    tipoexamen?: string | null
    rutaExamen?: string | null
    id_paciente?: number | null
  }

  export type examenUpdateManyMutationInput = {
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type examenUncheckedUpdateManyInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type medicamentoCreateInput = {
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
    proveedor?: proveedorCreateNestedOneWithoutMedicamentoInput
  }

  export type medicamentoUncheckedCreateInput = {
    id_medicamento?: number
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
    id_proveedor?: number | null
  }

  export type medicamentoUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: proveedorUpdateOneWithoutMedicamentoNestedInput
  }

  export type medicamentoUncheckedUpdateInput = {
    id_medicamento?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type medicamentoCreateManyInput = {
    id_medicamento?: number
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
    id_proveedor?: number | null
  }

  export type medicamentoUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicamentoUncheckedUpdateManyInput = {
    id_medicamento?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pacienteCreateInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutPacienteInput
    examen?: examenCreateNestedManyWithoutPacienteInput
    usuario?: usuarioCreateNestedOneWithoutPacienteInput
    pago?: pagoCreateNestedManyWithoutPacienteInput
  }

  export type pacienteUncheckedCreateInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaUncheckedCreateNestedManyWithoutPacienteInput
    examen?: examenUncheckedCreateNestedManyWithoutPacienteInput
    pago?: pagoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type pacienteUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutPacienteNestedInput
    examen?: examenUpdateManyWithoutPacienteNestedInput
    usuario?: usuarioUpdateOneWithoutPacienteNestedInput
    pago?: pagoUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUncheckedUpdateManyWithoutPacienteNestedInput
    examen?: examenUncheckedUpdateManyWithoutPacienteNestedInput
    pago?: pagoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteCreateManyInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
  }

  export type pacienteUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pacienteUncheckedUpdateManyInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagoCreateInput = {
    tipopago: string
    monto: number
    fechapago?: Date | string | null
    paciente: pacienteCreateNestedOneWithoutPagoInput
  }

  export type pagoUncheckedCreateInput = {
    id_pago?: number
    id_paciente: number
    tipopago: string
    monto: number
    fechapago?: Date | string | null
  }

  export type pagoUpdateInput = {
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paciente?: pacienteUpdateOneRequiredWithoutPagoNestedInput
  }

  export type pagoUncheckedUpdateInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pagoCreateManyInput = {
    id_pago?: number
    id_paciente: number
    tipopago: string
    monto: number
    fechapago?: Date | string | null
  }

  export type pagoUpdateManyMutationInput = {
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pagoUncheckedUpdateManyInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescripcionCreateInput = {
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
    receta?: recetaCreateNestedOneWithoutPrescripcionInput
  }

  export type prescripcionUncheckedCreateInput = {
    id_prescripcion?: number
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
    id_receta?: number | null
  }

  export type prescripcionUpdateInput = {
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
    receta?: recetaUpdateOneWithoutPrescripcionNestedInput
  }

  export type prescripcionUncheckedUpdateInput = {
    id_prescripcion?: IntFieldUpdateOperationsInput | number
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
    id_receta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescripcionCreateManyInput = {
    id_prescripcion?: number
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
    id_receta?: number | null
  }

  export type prescripcionUpdateManyMutationInput = {
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescripcionUncheckedUpdateManyInput = {
    id_prescripcion?: IntFieldUpdateOperationsInput | number
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
    id_receta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type proveedorCreateInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
    medicamento?: medicamentoCreateNestedManyWithoutProveedorInput
    usuario?: usuarioCreateNestedOneWithoutProveedorInput
  }

  export type proveedorUncheckedCreateInput = {
    id_proveedor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    id_usuario?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
    medicamento?: medicamentoUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamento?: medicamentoUpdateManyWithoutProveedorNestedInput
    usuario?: usuarioUpdateOneWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamento?: medicamentoUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorCreateManyInput = {
    id_proveedor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    id_usuario?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
  }

  export type proveedorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type proveedorUncheckedUpdateManyInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type recetaCreateInput = {
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    prescripcion?: prescripcionCreateNestedManyWithoutRecetaInput
    tratamiento?: tratamientoCreateNestedOneWithoutRecetaInput
  }

  export type recetaUncheckedCreateInput = {
    id_receta?: number
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    id_tratamiento?: number | null
    prescripcion?: prescripcionUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type recetaUpdateInput = {
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    prescripcion?: prescripcionUpdateManyWithoutRecetaNestedInput
    tratamiento?: tratamientoUpdateOneWithoutRecetaNestedInput
  }

  export type recetaUncheckedUpdateInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    id_tratamiento?: NullableIntFieldUpdateOperationsInput | number | null
    prescripcion?: prescripcionUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type recetaCreateManyInput = {
    id_receta?: number
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    id_tratamiento?: number | null
  }

  export type recetaUpdateManyMutationInput = {
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetaUncheckedUpdateManyInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    id_tratamiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type secretariaCreateInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
    usuario?: usuarioCreateNestedOneWithoutSecretariaInput
  }

  export type secretariaUncheckedCreateInput = {
    id_secretaria?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
  }

  export type secretariaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateOneWithoutSecretariaNestedInput
  }

  export type secretariaUncheckedUpdateInput = {
    id_secretaria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type secretariaCreateManyInput = {
    id_secretaria?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
  }

  export type secretariaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type secretariaUncheckedUpdateManyInput = {
    id_secretaria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type telefonoCreateInput = {
    numero: string
    tipo?: string | null
  }

  export type telefonoUncheckedCreateInput = {
    id_telefono?: number
    numero: string
    tipo?: string | null
  }

  export type telefonoUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type telefonoUncheckedUpdateInput = {
    id_telefono?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type telefonoCreateManyInput = {
    id_telefono?: number
    numero: string
    tipo?: string | null
  }

  export type telefonoUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type telefonoUncheckedUpdateManyInput = {
    id_telefono?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tratamientoCreateInput = {
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    receta?: recetaCreateNestedManyWithoutTratamientoInput
    diagnostico?: diagnosticoCreateNestedOneWithoutTratamientoInput
  }

  export type tratamientoUncheckedCreateInput = {
    id_tratamiento?: number
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    id_diagnostico?: number | null
    receta?: recetaUncheckedCreateNestedManyWithoutTratamientoInput
  }

  export type tratamientoUpdateInput = {
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    receta?: recetaUpdateManyWithoutTratamientoNestedInput
    diagnostico?: diagnosticoUpdateOneWithoutTratamientoNestedInput
  }

  export type tratamientoUncheckedUpdateInput = {
    id_tratamiento?: IntFieldUpdateOperationsInput | number
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_diagnostico?: NullableIntFieldUpdateOperationsInput | number | null
    receta?: recetaUncheckedUpdateManyWithoutTratamientoNestedInput
  }

  export type tratamientoCreateManyInput = {
    id_tratamiento?: number
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    id_diagnostico?: number | null
  }

  export type tratamientoUpdateManyMutationInput = {
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tratamientoUncheckedUpdateManyInput = {
    id_tratamiento?: IntFieldUpdateOperationsInput | number
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_diagnostico?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuarioCreateInput = {
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorCreateNestedManyWithoutUsuarioInput
    doctor?: doctorCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorUncheckedCreateNestedManyWithoutUsuarioInput
    doctor?: doctorUncheckedCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteUncheckedCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUncheckedUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUncheckedUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUncheckedUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
  }

  export type usuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
  }

  export type usuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsuarioNullableScalarRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type administradorCountOrderByAggregateInput = {
    id_admin?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechaingreso?: SortOrder
  }

  export type administradorAvgOrderByAggregateInput = {
    id_admin?: SortOrder
    id_usuario?: SortOrder
  }

  export type administradorMaxOrderByAggregateInput = {
    id_admin?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechaingreso?: SortOrder
  }

  export type administradorMinOrderByAggregateInput = {
    id_admin?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechaingreso?: SortOrder
  }

  export type administradorSumOrderByAggregateInput = {
    id_admin?: SortOrder
    id_usuario?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DoctorNullableScalarRelationFilter = {
    is?: doctorWhereInput | null
    isNot?: doctorWhereInput | null
  }

  export type PacienteNullableScalarRelationFilter = {
    is?: pacienteWhereInput | null
    isNot?: pacienteWhereInput | null
  }

  export type ConsultaListRelationFilter = {
    every?: consultaWhereInput
    some?: consultaWhereInput
    none?: consultaWhereInput
  }

  export type consultaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citaCountOrderByAggregateInput = {
    id_cita?: SortOrder
    fecha?: SortOrder
    horainicio?: SortOrder
    horafin?: SortOrder
    estado?: SortOrder
    motivo?: SortOrder
    id_doctor?: SortOrder
    id_paciente?: SortOrder
    hora_llegada?: SortOrder
  }

  export type citaAvgOrderByAggregateInput = {
    id_cita?: SortOrder
    id_doctor?: SortOrder
    id_paciente?: SortOrder
  }

  export type citaMaxOrderByAggregateInput = {
    id_cita?: SortOrder
    fecha?: SortOrder
    horainicio?: SortOrder
    horafin?: SortOrder
    estado?: SortOrder
    motivo?: SortOrder
    id_doctor?: SortOrder
    id_paciente?: SortOrder
    hora_llegada?: SortOrder
  }

  export type citaMinOrderByAggregateInput = {
    id_cita?: SortOrder
    fecha?: SortOrder
    horainicio?: SortOrder
    horafin?: SortOrder
    estado?: SortOrder
    motivo?: SortOrder
    id_doctor?: SortOrder
    id_paciente?: SortOrder
    hora_llegada?: SortOrder
  }

  export type citaSumOrderByAggregateInput = {
    id_cita?: SortOrder
    id_doctor?: SortOrder
    id_paciente?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CitaNullableScalarRelationFilter = {
    is?: citaWhereInput | null
    isNot?: citaWhereInput | null
  }

  export type DiagnosticoListRelationFilter = {
    every?: diagnosticoWhereInput
    some?: diagnosticoWhereInput
    none?: diagnosticoWhereInput
  }

  export type diagnosticoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type consultaCountOrderByAggregateInput = {
    id_consulta?: SortOrder
    fecha?: SortOrder
    motivo?: SortOrder
    id_cita?: SortOrder
  }

  export type consultaAvgOrderByAggregateInput = {
    id_consulta?: SortOrder
    id_cita?: SortOrder
  }

  export type consultaMaxOrderByAggregateInput = {
    id_consulta?: SortOrder
    fecha?: SortOrder
    motivo?: SortOrder
    id_cita?: SortOrder
  }

  export type consultaMinOrderByAggregateInput = {
    id_consulta?: SortOrder
    fecha?: SortOrder
    motivo?: SortOrder
    id_cita?: SortOrder
  }

  export type consultaSumOrderByAggregateInput = {
    id_consulta?: SortOrder
    id_cita?: SortOrder
  }

  export type detallepagoCountOrderByAggregateInput = {
    id_detalle_pago?: SortOrder
    fechapago?: SortOrder
    id_transaccionpp?: SortOrder
  }

  export type detallepagoAvgOrderByAggregateInput = {
    id_detalle_pago?: SortOrder
    id_transaccionpp?: SortOrder
  }

  export type detallepagoMaxOrderByAggregateInput = {
    id_detalle_pago?: SortOrder
    fechapago?: SortOrder
    id_transaccionpp?: SortOrder
  }

  export type detallepagoMinOrderByAggregateInput = {
    id_detalle_pago?: SortOrder
    fechapago?: SortOrder
    id_transaccionpp?: SortOrder
  }

  export type detallepagoSumOrderByAggregateInput = {
    id_detalle_pago?: SortOrder
    id_transaccionpp?: SortOrder
  }

  export type ConsultaNullableScalarRelationFilter = {
    is?: consultaWhereInput | null
    isNot?: consultaWhereInput | null
  }

  export type TratamientoListRelationFilter = {
    every?: tratamientoWhereInput
    some?: tratamientoWhereInput
    none?: tratamientoWhereInput
  }

  export type tratamientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type diagnosticoCountOrderByAggregateInput = {
    id_diagnostico?: SortOrder
    nombrediagnostico?: SortOrder
    descripcion?: SortOrder
    id_consulta?: SortOrder
  }

  export type diagnosticoAvgOrderByAggregateInput = {
    id_diagnostico?: SortOrder
    id_consulta?: SortOrder
  }

  export type diagnosticoMaxOrderByAggregateInput = {
    id_diagnostico?: SortOrder
    nombrediagnostico?: SortOrder
    descripcion?: SortOrder
    id_consulta?: SortOrder
  }

  export type diagnosticoMinOrderByAggregateInput = {
    id_diagnostico?: SortOrder
    nombrediagnostico?: SortOrder
    descripcion?: SortOrder
    id_consulta?: SortOrder
  }

  export type diagnosticoSumOrderByAggregateInput = {
    id_diagnostico?: SortOrder
    id_consulta?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CitaListRelationFilter = {
    every?: citaWhereInput
    some?: citaWhereInput
    none?: citaWhereInput
  }

  export type EspecialidadNullableScalarRelationFilter = {
    is?: especialidadWhereInput | null
    isNot?: especialidadWhereInput | null
  }

  export type Especialidad_doctorListRelationFilter = {
    every?: especialidad_doctorWhereInput
    some?: especialidad_doctorWhereInput
    none?: especialidad_doctorWhereInput
  }

  export type citaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type especialidad_doctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type doctorCountOrderByAggregateInput = {
    id_doctor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    id_especialidad?: SortOrder
  }

  export type doctorAvgOrderByAggregateInput = {
    id_doctor?: SortOrder
    id_usuario?: SortOrder
    salario?: SortOrder
    id_especialidad?: SortOrder
  }

  export type doctorMaxOrderByAggregateInput = {
    id_doctor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    id_especialidad?: SortOrder
  }

  export type doctorMinOrderByAggregateInput = {
    id_doctor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    id_especialidad?: SortOrder
  }

  export type doctorSumOrderByAggregateInput = {
    id_doctor?: SortOrder
    id_usuario?: SortOrder
    salario?: SortOrder
    id_especialidad?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DoctorListRelationFilter = {
    every?: doctorWhereInput
    some?: doctorWhereInput
    none?: doctorWhereInput
  }

  export type doctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type especialidadCountOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombreespecialidad?: SortOrder
    descripcion?: SortOrder
  }

  export type especialidadAvgOrderByAggregateInput = {
    id_especialidad?: SortOrder
  }

  export type especialidadMaxOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombreespecialidad?: SortOrder
    descripcion?: SortOrder
  }

  export type especialidadMinOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombreespecialidad?: SortOrder
    descripcion?: SortOrder
  }

  export type especialidadSumOrderByAggregateInput = {
    id_especialidad?: SortOrder
  }

  export type especialidad_doctorCountOrderByAggregateInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrder
    id_especialidad?: SortOrder
  }

  export type especialidad_doctorAvgOrderByAggregateInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrder
    id_especialidad?: SortOrder
  }

  export type especialidad_doctorMaxOrderByAggregateInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrder
    id_especialidad?: SortOrder
  }

  export type especialidad_doctorMinOrderByAggregateInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrder
    id_especialidad?: SortOrder
  }

  export type especialidad_doctorSumOrderByAggregateInput = {
    id_especialidad_doctor?: SortOrder
    id_doctor?: SortOrder
    id_especialidad?: SortOrder
  }

  export type examenCountOrderByAggregateInput = {
    id_examen?: SortOrder
    tipoexamen?: SortOrder
    rutaExamen?: SortOrder
    id_paciente?: SortOrder
  }

  export type examenAvgOrderByAggregateInput = {
    id_examen?: SortOrder
    id_paciente?: SortOrder
  }

  export type examenMaxOrderByAggregateInput = {
    id_examen?: SortOrder
    tipoexamen?: SortOrder
    rutaExamen?: SortOrder
    id_paciente?: SortOrder
  }

  export type examenMinOrderByAggregateInput = {
    id_examen?: SortOrder
    tipoexamen?: SortOrder
    rutaExamen?: SortOrder
    id_paciente?: SortOrder
  }

  export type examenSumOrderByAggregateInput = {
    id_examen?: SortOrder
    id_paciente?: SortOrder
  }

  export type ProveedorNullableScalarRelationFilter = {
    is?: proveedorWhereInput | null
    isNot?: proveedorWhereInput | null
  }

  export type medicamentoCountOrderByAggregateInput = {
    id_medicamento?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    id_proveedor?: SortOrder
  }

  export type medicamentoAvgOrderByAggregateInput = {
    id_medicamento?: SortOrder
    id_proveedor?: SortOrder
  }

  export type medicamentoMaxOrderByAggregateInput = {
    id_medicamento?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    id_proveedor?: SortOrder
  }

  export type medicamentoMinOrderByAggregateInput = {
    id_medicamento?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    id_proveedor?: SortOrder
  }

  export type medicamentoSumOrderByAggregateInput = {
    id_medicamento?: SortOrder
    id_proveedor?: SortOrder
  }

  export type ExamenListRelationFilter = {
    every?: examenWhereInput
    some?: examenWhereInput
    none?: examenWhereInput
  }

  export type PagoListRelationFilter = {
    every?: pagoWhereInput
    some?: pagoWhereInput
    none?: pagoWhereInput
  }

  export type examenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pacienteCountOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    sexo?: SortOrder
    tiposangre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
  }

  export type pacienteAvgOrderByAggregateInput = {
    id_paciente?: SortOrder
    id_usuario?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
  }

  export type pacienteMaxOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    sexo?: SortOrder
    tiposangre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
  }

  export type pacienteMinOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    id_usuario?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    sexo?: SortOrder
    tiposangre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
  }

  export type pacienteSumOrderByAggregateInput = {
    id_paciente?: SortOrder
    id_usuario?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PacienteScalarRelationFilter = {
    is?: pacienteWhereInput
    isNot?: pacienteWhereInput
  }

  export type pagoCountOrderByAggregateInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    tipopago?: SortOrder
    monto?: SortOrder
    fechapago?: SortOrder
  }

  export type pagoAvgOrderByAggregateInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    monto?: SortOrder
  }

  export type pagoMaxOrderByAggregateInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    tipopago?: SortOrder
    monto?: SortOrder
    fechapago?: SortOrder
  }

  export type pagoMinOrderByAggregateInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    tipopago?: SortOrder
    monto?: SortOrder
    fechapago?: SortOrder
  }

  export type pagoSumOrderByAggregateInput = {
    id_pago?: SortOrder
    id_paciente?: SortOrder
    monto?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RecetaNullableScalarRelationFilter = {
    is?: recetaWhereInput | null
    isNot?: recetaWhereInput | null
  }

  export type prescripcionCountOrderByAggregateInput = {
    id_prescripcion?: SortOrder
    dosisrecomendada?: SortOrder
    tipo?: SortOrder
    frecuencia?: SortOrder
    id_medicamento?: SortOrder
    id_receta?: SortOrder
  }

  export type prescripcionAvgOrderByAggregateInput = {
    id_prescripcion?: SortOrder
    id_medicamento?: SortOrder
    id_receta?: SortOrder
  }

  export type prescripcionMaxOrderByAggregateInput = {
    id_prescripcion?: SortOrder
    dosisrecomendada?: SortOrder
    tipo?: SortOrder
    frecuencia?: SortOrder
    id_medicamento?: SortOrder
    id_receta?: SortOrder
  }

  export type prescripcionMinOrderByAggregateInput = {
    id_prescripcion?: SortOrder
    dosisrecomendada?: SortOrder
    tipo?: SortOrder
    frecuencia?: SortOrder
    id_medicamento?: SortOrder
    id_receta?: SortOrder
  }

  export type prescripcionSumOrderByAggregateInput = {
    id_prescripcion?: SortOrder
    id_medicamento?: SortOrder
    id_receta?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type MedicamentoListRelationFilter = {
    every?: medicamentoWhereInput
    some?: medicamentoWhereInput
    none?: medicamentoWhereInput
  }

  export type medicamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proveedorCountOrderByAggregateInput = {
    id_proveedor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_direccion?: SortOrder
    id_usuario?: SortOrder
    tipoproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedorAvgOrderByAggregateInput = {
    id_proveedor?: SortOrder
    id_direccion?: SortOrder
    id_usuario?: SortOrder
  }

  export type proveedorMaxOrderByAggregateInput = {
    id_proveedor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_direccion?: SortOrder
    id_usuario?: SortOrder
    tipoproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedorMinOrderByAggregateInput = {
    id_proveedor?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    celular?: SortOrder
    telefono?: SortOrder
    id_direccion?: SortOrder
    id_usuario?: SortOrder
    tipoproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedorSumOrderByAggregateInput = {
    id_proveedor?: SortOrder
    id_direccion?: SortOrder
    id_usuario?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PrescripcionListRelationFilter = {
    every?: prescripcionWhereInput
    some?: prescripcionWhereInput
    none?: prescripcionWhereInput
  }

  export type TratamientoNullableScalarRelationFilter = {
    is?: tratamientoWhereInput | null
    isNot?: tratamientoWhereInput | null
  }

  export type prescripcionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recetaCountOrderByAggregateInput = {
    id_receta?: SortOrder
    fechaemision?: SortOrder
    dosisrecomendada?: SortOrder
    id_tratamiento?: SortOrder
  }

  export type recetaAvgOrderByAggregateInput = {
    id_receta?: SortOrder
    id_tratamiento?: SortOrder
  }

  export type recetaMaxOrderByAggregateInput = {
    id_receta?: SortOrder
    fechaemision?: SortOrder
    dosisrecomendada?: SortOrder
    id_tratamiento?: SortOrder
  }

  export type recetaMinOrderByAggregateInput = {
    id_receta?: SortOrder
    fechaemision?: SortOrder
    dosisrecomendada?: SortOrder
    id_tratamiento?: SortOrder
  }

  export type recetaSumOrderByAggregateInput = {
    id_receta?: SortOrder
    id_tratamiento?: SortOrder
  }

  export type secretariaCountOrderByAggregateInput = {
    id_secretaria?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    correo?: SortOrder
  }

  export type secretariaAvgOrderByAggregateInput = {
    id_secretaria?: SortOrder
    id_usuario?: SortOrder
    salario?: SortOrder
  }

  export type secretariaMaxOrderByAggregateInput = {
    id_secretaria?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    correo?: SortOrder
  }

  export type secretariaMinOrderByAggregateInput = {
    id_secretaria?: SortOrder
    nombre?: SortOrder
    segundonombre?: SortOrder
    primerapellido?: SortOrder
    segundoapellido?: SortOrder
    nacimiento?: SortOrder
    telefono?: SortOrder
    id_usuario?: SortOrder
    fechacontratacion?: SortOrder
    salario?: SortOrder
    correo?: SortOrder
  }

  export type secretariaSumOrderByAggregateInput = {
    id_secretaria?: SortOrder
    id_usuario?: SortOrder
    salario?: SortOrder
  }

  export type telefonoCountOrderByAggregateInput = {
    id_telefono?: SortOrder
    numero?: SortOrder
    tipo?: SortOrder
  }

  export type telefonoAvgOrderByAggregateInput = {
    id_telefono?: SortOrder
  }

  export type telefonoMaxOrderByAggregateInput = {
    id_telefono?: SortOrder
    numero?: SortOrder
    tipo?: SortOrder
  }

  export type telefonoMinOrderByAggregateInput = {
    id_telefono?: SortOrder
    numero?: SortOrder
    tipo?: SortOrder
  }

  export type telefonoSumOrderByAggregateInput = {
    id_telefono?: SortOrder
  }

  export type RecetaListRelationFilter = {
    every?: recetaWhereInput
    some?: recetaWhereInput
    none?: recetaWhereInput
  }

  export type DiagnosticoNullableScalarRelationFilter = {
    is?: diagnosticoWhereInput | null
    isNot?: diagnosticoWhereInput | null
  }

  export type recetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tratamientoCountOrderByAggregateInput = {
    id_tratamiento?: SortOrder
    tipotratamiento?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    frecuencia?: SortOrder
    id_diagnostico?: SortOrder
  }

  export type tratamientoAvgOrderByAggregateInput = {
    id_tratamiento?: SortOrder
    id_diagnostico?: SortOrder
  }

  export type tratamientoMaxOrderByAggregateInput = {
    id_tratamiento?: SortOrder
    tipotratamiento?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    frecuencia?: SortOrder
    id_diagnostico?: SortOrder
  }

  export type tratamientoMinOrderByAggregateInput = {
    id_tratamiento?: SortOrder
    tipotratamiento?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    frecuencia?: SortOrder
    id_diagnostico?: SortOrder
  }

  export type tratamientoSumOrderByAggregateInput = {
    id_tratamiento?: SortOrder
    id_diagnostico?: SortOrder
  }

  export type AdministradorListRelationFilter = {
    every?: administradorWhereInput
    some?: administradorWhereInput
    none?: administradorWhereInput
  }

  export type PacienteListRelationFilter = {
    every?: pacienteWhereInput
    some?: pacienteWhereInput
    none?: pacienteWhereInput
  }

  export type ProveedorListRelationFilter = {
    every?: proveedorWhereInput
    some?: proveedorWhereInput
    none?: proveedorWhereInput
  }

  export type SecretariaListRelationFilter = {
    every?: secretariaWhereInput
    some?: secretariaWhereInput
    none?: secretariaWhereInput
  }

  export type administradorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proveedorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type secretariaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    contrasena?: SortOrder
    rol?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    contrasena?: SortOrder
    rol?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    contrasena?: SortOrder
    rol?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
  }

  export type usuarioCreateNestedOneWithoutAdministradorInput = {
    create?: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAdministradorInput
    connect?: usuarioWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usuarioUpdateOneWithoutAdministradorNestedInput = {
    create?: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAdministradorInput
    upsert?: usuarioUpsertWithoutAdministradorInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutAdministradorInput, usuarioUpdateWithoutAdministradorInput>, usuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type doctorCreateNestedOneWithoutCitaInput = {
    create?: XOR<doctorCreateWithoutCitaInput, doctorUncheckedCreateWithoutCitaInput>
    connectOrCreate?: doctorCreateOrConnectWithoutCitaInput
    connect?: doctorWhereUniqueInput
  }

  export type pacienteCreateNestedOneWithoutCitaInput = {
    create?: XOR<pacienteCreateWithoutCitaInput, pacienteUncheckedCreateWithoutCitaInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutCitaInput
    connect?: pacienteWhereUniqueInput
  }

  export type consultaCreateNestedManyWithoutCitaInput = {
    create?: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput> | consultaCreateWithoutCitaInput[] | consultaUncheckedCreateWithoutCitaInput[]
    connectOrCreate?: consultaCreateOrConnectWithoutCitaInput | consultaCreateOrConnectWithoutCitaInput[]
    createMany?: consultaCreateManyCitaInputEnvelope
    connect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
  }

  export type consultaUncheckedCreateNestedManyWithoutCitaInput = {
    create?: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput> | consultaCreateWithoutCitaInput[] | consultaUncheckedCreateWithoutCitaInput[]
    connectOrCreate?: consultaCreateOrConnectWithoutCitaInput | consultaCreateOrConnectWithoutCitaInput[]
    createMany?: consultaCreateManyCitaInputEnvelope
    connect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type doctorUpdateOneWithoutCitaNestedInput = {
    create?: XOR<doctorCreateWithoutCitaInput, doctorUncheckedCreateWithoutCitaInput>
    connectOrCreate?: doctorCreateOrConnectWithoutCitaInput
    upsert?: doctorUpsertWithoutCitaInput
    disconnect?: doctorWhereInput | boolean
    delete?: doctorWhereInput | boolean
    connect?: doctorWhereUniqueInput
    update?: XOR<XOR<doctorUpdateToOneWithWhereWithoutCitaInput, doctorUpdateWithoutCitaInput>, doctorUncheckedUpdateWithoutCitaInput>
  }

  export type pacienteUpdateOneWithoutCitaNestedInput = {
    create?: XOR<pacienteCreateWithoutCitaInput, pacienteUncheckedCreateWithoutCitaInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutCitaInput
    upsert?: pacienteUpsertWithoutCitaInput
    disconnect?: pacienteWhereInput | boolean
    delete?: pacienteWhereInput | boolean
    connect?: pacienteWhereUniqueInput
    update?: XOR<XOR<pacienteUpdateToOneWithWhereWithoutCitaInput, pacienteUpdateWithoutCitaInput>, pacienteUncheckedUpdateWithoutCitaInput>
  }

  export type consultaUpdateManyWithoutCitaNestedInput = {
    create?: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput> | consultaCreateWithoutCitaInput[] | consultaUncheckedCreateWithoutCitaInput[]
    connectOrCreate?: consultaCreateOrConnectWithoutCitaInput | consultaCreateOrConnectWithoutCitaInput[]
    upsert?: consultaUpsertWithWhereUniqueWithoutCitaInput | consultaUpsertWithWhereUniqueWithoutCitaInput[]
    createMany?: consultaCreateManyCitaInputEnvelope
    set?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    disconnect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    delete?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    connect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    update?: consultaUpdateWithWhereUniqueWithoutCitaInput | consultaUpdateWithWhereUniqueWithoutCitaInput[]
    updateMany?: consultaUpdateManyWithWhereWithoutCitaInput | consultaUpdateManyWithWhereWithoutCitaInput[]
    deleteMany?: consultaScalarWhereInput | consultaScalarWhereInput[]
  }

  export type consultaUncheckedUpdateManyWithoutCitaNestedInput = {
    create?: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput> | consultaCreateWithoutCitaInput[] | consultaUncheckedCreateWithoutCitaInput[]
    connectOrCreate?: consultaCreateOrConnectWithoutCitaInput | consultaCreateOrConnectWithoutCitaInput[]
    upsert?: consultaUpsertWithWhereUniqueWithoutCitaInput | consultaUpsertWithWhereUniqueWithoutCitaInput[]
    createMany?: consultaCreateManyCitaInputEnvelope
    set?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    disconnect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    delete?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    connect?: consultaWhereUniqueInput | consultaWhereUniqueInput[]
    update?: consultaUpdateWithWhereUniqueWithoutCitaInput | consultaUpdateWithWhereUniqueWithoutCitaInput[]
    updateMany?: consultaUpdateManyWithWhereWithoutCitaInput | consultaUpdateManyWithWhereWithoutCitaInput[]
    deleteMany?: consultaScalarWhereInput | consultaScalarWhereInput[]
  }

  export type citaCreateNestedOneWithoutConsultaInput = {
    create?: XOR<citaCreateWithoutConsultaInput, citaUncheckedCreateWithoutConsultaInput>
    connectOrCreate?: citaCreateOrConnectWithoutConsultaInput
    connect?: citaWhereUniqueInput
  }

  export type diagnosticoCreateNestedManyWithoutConsultaInput = {
    create?: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput> | diagnosticoCreateWithoutConsultaInput[] | diagnosticoUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutConsultaInput | diagnosticoCreateOrConnectWithoutConsultaInput[]
    createMany?: diagnosticoCreateManyConsultaInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type diagnosticoUncheckedCreateNestedManyWithoutConsultaInput = {
    create?: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput> | diagnosticoCreateWithoutConsultaInput[] | diagnosticoUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutConsultaInput | diagnosticoCreateOrConnectWithoutConsultaInput[]
    createMany?: diagnosticoCreateManyConsultaInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type citaUpdateOneWithoutConsultaNestedInput = {
    create?: XOR<citaCreateWithoutConsultaInput, citaUncheckedCreateWithoutConsultaInput>
    connectOrCreate?: citaCreateOrConnectWithoutConsultaInput
    upsert?: citaUpsertWithoutConsultaInput
    disconnect?: citaWhereInput | boolean
    delete?: citaWhereInput | boolean
    connect?: citaWhereUniqueInput
    update?: XOR<XOR<citaUpdateToOneWithWhereWithoutConsultaInput, citaUpdateWithoutConsultaInput>, citaUncheckedUpdateWithoutConsultaInput>
  }

  export type diagnosticoUpdateManyWithoutConsultaNestedInput = {
    create?: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput> | diagnosticoCreateWithoutConsultaInput[] | diagnosticoUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutConsultaInput | diagnosticoCreateOrConnectWithoutConsultaInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutConsultaInput | diagnosticoUpsertWithWhereUniqueWithoutConsultaInput[]
    createMany?: diagnosticoCreateManyConsultaInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutConsultaInput | diagnosticoUpdateWithWhereUniqueWithoutConsultaInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutConsultaInput | diagnosticoUpdateManyWithWhereWithoutConsultaInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type diagnosticoUncheckedUpdateManyWithoutConsultaNestedInput = {
    create?: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput> | diagnosticoCreateWithoutConsultaInput[] | diagnosticoUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutConsultaInput | diagnosticoCreateOrConnectWithoutConsultaInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutConsultaInput | diagnosticoUpsertWithWhereUniqueWithoutConsultaInput[]
    createMany?: diagnosticoCreateManyConsultaInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutConsultaInput | diagnosticoUpdateWithWhereUniqueWithoutConsultaInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutConsultaInput | diagnosticoUpdateManyWithWhereWithoutConsultaInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type consultaCreateNestedOneWithoutDiagnosticoInput = {
    create?: XOR<consultaCreateWithoutDiagnosticoInput, consultaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: consultaCreateOrConnectWithoutDiagnosticoInput
    connect?: consultaWhereUniqueInput
  }

  export type tratamientoCreateNestedManyWithoutDiagnosticoInput = {
    create?: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput> | tratamientoCreateWithoutDiagnosticoInput[] | tratamientoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: tratamientoCreateOrConnectWithoutDiagnosticoInput | tratamientoCreateOrConnectWithoutDiagnosticoInput[]
    createMany?: tratamientoCreateManyDiagnosticoInputEnvelope
    connect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
  }

  export type tratamientoUncheckedCreateNestedManyWithoutDiagnosticoInput = {
    create?: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput> | tratamientoCreateWithoutDiagnosticoInput[] | tratamientoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: tratamientoCreateOrConnectWithoutDiagnosticoInput | tratamientoCreateOrConnectWithoutDiagnosticoInput[]
    createMany?: tratamientoCreateManyDiagnosticoInputEnvelope
    connect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
  }

  export type consultaUpdateOneWithoutDiagnosticoNestedInput = {
    create?: XOR<consultaCreateWithoutDiagnosticoInput, consultaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: consultaCreateOrConnectWithoutDiagnosticoInput
    upsert?: consultaUpsertWithoutDiagnosticoInput
    disconnect?: consultaWhereInput | boolean
    delete?: consultaWhereInput | boolean
    connect?: consultaWhereUniqueInput
    update?: XOR<XOR<consultaUpdateToOneWithWhereWithoutDiagnosticoInput, consultaUpdateWithoutDiagnosticoInput>, consultaUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type tratamientoUpdateManyWithoutDiagnosticoNestedInput = {
    create?: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput> | tratamientoCreateWithoutDiagnosticoInput[] | tratamientoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: tratamientoCreateOrConnectWithoutDiagnosticoInput | tratamientoCreateOrConnectWithoutDiagnosticoInput[]
    upsert?: tratamientoUpsertWithWhereUniqueWithoutDiagnosticoInput | tratamientoUpsertWithWhereUniqueWithoutDiagnosticoInput[]
    createMany?: tratamientoCreateManyDiagnosticoInputEnvelope
    set?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    disconnect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    delete?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    connect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    update?: tratamientoUpdateWithWhereUniqueWithoutDiagnosticoInput | tratamientoUpdateWithWhereUniqueWithoutDiagnosticoInput[]
    updateMany?: tratamientoUpdateManyWithWhereWithoutDiagnosticoInput | tratamientoUpdateManyWithWhereWithoutDiagnosticoInput[]
    deleteMany?: tratamientoScalarWhereInput | tratamientoScalarWhereInput[]
  }

  export type tratamientoUncheckedUpdateManyWithoutDiagnosticoNestedInput = {
    create?: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput> | tratamientoCreateWithoutDiagnosticoInput[] | tratamientoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: tratamientoCreateOrConnectWithoutDiagnosticoInput | tratamientoCreateOrConnectWithoutDiagnosticoInput[]
    upsert?: tratamientoUpsertWithWhereUniqueWithoutDiagnosticoInput | tratamientoUpsertWithWhereUniqueWithoutDiagnosticoInput[]
    createMany?: tratamientoCreateManyDiagnosticoInputEnvelope
    set?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    disconnect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    delete?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    connect?: tratamientoWhereUniqueInput | tratamientoWhereUniqueInput[]
    update?: tratamientoUpdateWithWhereUniqueWithoutDiagnosticoInput | tratamientoUpdateWithWhereUniqueWithoutDiagnosticoInput[]
    updateMany?: tratamientoUpdateManyWithWhereWithoutDiagnosticoInput | tratamientoUpdateManyWithWhereWithoutDiagnosticoInput[]
    deleteMany?: tratamientoScalarWhereInput | tratamientoScalarWhereInput[]
  }

  export type citaCreateNestedManyWithoutDoctorInput = {
    create?: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput> | citaCreateWithoutDoctorInput[] | citaUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: citaCreateOrConnectWithoutDoctorInput | citaCreateOrConnectWithoutDoctorInput[]
    createMany?: citaCreateManyDoctorInputEnvelope
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
  }

  export type especialidadCreateNestedOneWithoutDoctorInput = {
    create?: XOR<especialidadCreateWithoutDoctorInput, especialidadUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutDoctorInput
    connect?: especialidadWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutDoctorInput = {
    create?: XOR<usuarioCreateWithoutDoctorInput, usuarioUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDoctorInput
    connect?: usuarioWhereUniqueInput
  }

  export type especialidad_doctorCreateNestedManyWithoutDoctorInput = {
    create?: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput> | especialidad_doctorCreateWithoutDoctorInput[] | especialidad_doctorUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutDoctorInput | especialidad_doctorCreateOrConnectWithoutDoctorInput[]
    createMany?: especialidad_doctorCreateManyDoctorInputEnvelope
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
  }

  export type citaUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput> | citaCreateWithoutDoctorInput[] | citaUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: citaCreateOrConnectWithoutDoctorInput | citaCreateOrConnectWithoutDoctorInput[]
    createMany?: citaCreateManyDoctorInputEnvelope
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
  }

  export type especialidad_doctorUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput> | especialidad_doctorCreateWithoutDoctorInput[] | especialidad_doctorUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutDoctorInput | especialidad_doctorCreateOrConnectWithoutDoctorInput[]
    createMany?: especialidad_doctorCreateManyDoctorInputEnvelope
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type citaUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput> | citaCreateWithoutDoctorInput[] | citaUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: citaCreateOrConnectWithoutDoctorInput | citaCreateOrConnectWithoutDoctorInput[]
    upsert?: citaUpsertWithWhereUniqueWithoutDoctorInput | citaUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: citaCreateManyDoctorInputEnvelope
    set?: citaWhereUniqueInput | citaWhereUniqueInput[]
    disconnect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    delete?: citaWhereUniqueInput | citaWhereUniqueInput[]
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    update?: citaUpdateWithWhereUniqueWithoutDoctorInput | citaUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: citaUpdateManyWithWhereWithoutDoctorInput | citaUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: citaScalarWhereInput | citaScalarWhereInput[]
  }

  export type especialidadUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<especialidadCreateWithoutDoctorInput, especialidadUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutDoctorInput
    upsert?: especialidadUpsertWithoutDoctorInput
    disconnect?: especialidadWhereInput | boolean
    delete?: especialidadWhereInput | boolean
    connect?: especialidadWhereUniqueInput
    update?: XOR<XOR<especialidadUpdateToOneWithWhereWithoutDoctorInput, especialidadUpdateWithoutDoctorInput>, especialidadUncheckedUpdateWithoutDoctorInput>
  }

  export type usuarioUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<usuarioCreateWithoutDoctorInput, usuarioUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDoctorInput
    upsert?: usuarioUpsertWithoutDoctorInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutDoctorInput, usuarioUpdateWithoutDoctorInput>, usuarioUncheckedUpdateWithoutDoctorInput>
  }

  export type especialidad_doctorUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput> | especialidad_doctorCreateWithoutDoctorInput[] | especialidad_doctorUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutDoctorInput | especialidad_doctorCreateOrConnectWithoutDoctorInput[]
    upsert?: especialidad_doctorUpsertWithWhereUniqueWithoutDoctorInput | especialidad_doctorUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: especialidad_doctorCreateManyDoctorInputEnvelope
    set?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    disconnect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    delete?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    update?: especialidad_doctorUpdateWithWhereUniqueWithoutDoctorInput | especialidad_doctorUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: especialidad_doctorUpdateManyWithWhereWithoutDoctorInput | especialidad_doctorUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
  }

  export type citaUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput> | citaCreateWithoutDoctorInput[] | citaUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: citaCreateOrConnectWithoutDoctorInput | citaCreateOrConnectWithoutDoctorInput[]
    upsert?: citaUpsertWithWhereUniqueWithoutDoctorInput | citaUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: citaCreateManyDoctorInputEnvelope
    set?: citaWhereUniqueInput | citaWhereUniqueInput[]
    disconnect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    delete?: citaWhereUniqueInput | citaWhereUniqueInput[]
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    update?: citaUpdateWithWhereUniqueWithoutDoctorInput | citaUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: citaUpdateManyWithWhereWithoutDoctorInput | citaUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: citaScalarWhereInput | citaScalarWhereInput[]
  }

  export type especialidad_doctorUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput> | especialidad_doctorCreateWithoutDoctorInput[] | especialidad_doctorUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutDoctorInput | especialidad_doctorCreateOrConnectWithoutDoctorInput[]
    upsert?: especialidad_doctorUpsertWithWhereUniqueWithoutDoctorInput | especialidad_doctorUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: especialidad_doctorCreateManyDoctorInputEnvelope
    set?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    disconnect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    delete?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    update?: especialidad_doctorUpdateWithWhereUniqueWithoutDoctorInput | especialidad_doctorUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: especialidad_doctorUpdateManyWithWhereWithoutDoctorInput | especialidad_doctorUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
  }

  export type doctorCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput> | doctorCreateWithoutEspecialidadInput[] | doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidadInput | doctorCreateOrConnectWithoutEspecialidadInput[]
    createMany?: doctorCreateManyEspecialidadInputEnvelope
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
  }

  export type especialidad_doctorCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput> | especialidad_doctorCreateWithoutEspecialidadInput[] | especialidad_doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutEspecialidadInput | especialidad_doctorCreateOrConnectWithoutEspecialidadInput[]
    createMany?: especialidad_doctorCreateManyEspecialidadInputEnvelope
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
  }

  export type doctorUncheckedCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput> | doctorCreateWithoutEspecialidadInput[] | doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidadInput | doctorCreateOrConnectWithoutEspecialidadInput[]
    createMany?: doctorCreateManyEspecialidadInputEnvelope
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
  }

  export type especialidad_doctorUncheckedCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput> | especialidad_doctorCreateWithoutEspecialidadInput[] | especialidad_doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutEspecialidadInput | especialidad_doctorCreateOrConnectWithoutEspecialidadInput[]
    createMany?: especialidad_doctorCreateManyEspecialidadInputEnvelope
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
  }

  export type doctorUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput> | doctorCreateWithoutEspecialidadInput[] | doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidadInput | doctorCreateOrConnectWithoutEspecialidadInput[]
    upsert?: doctorUpsertWithWhereUniqueWithoutEspecialidadInput | doctorUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: doctorCreateManyEspecialidadInputEnvelope
    set?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    disconnect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    delete?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    update?: doctorUpdateWithWhereUniqueWithoutEspecialidadInput | doctorUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: doctorUpdateManyWithWhereWithoutEspecialidadInput | doctorUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: doctorScalarWhereInput | doctorScalarWhereInput[]
  }

  export type especialidad_doctorUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput> | especialidad_doctorCreateWithoutEspecialidadInput[] | especialidad_doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutEspecialidadInput | especialidad_doctorCreateOrConnectWithoutEspecialidadInput[]
    upsert?: especialidad_doctorUpsertWithWhereUniqueWithoutEspecialidadInput | especialidad_doctorUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: especialidad_doctorCreateManyEspecialidadInputEnvelope
    set?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    disconnect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    delete?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    update?: especialidad_doctorUpdateWithWhereUniqueWithoutEspecialidadInput | especialidad_doctorUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: especialidad_doctorUpdateManyWithWhereWithoutEspecialidadInput | especialidad_doctorUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
  }

  export type doctorUncheckedUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput> | doctorCreateWithoutEspecialidadInput[] | doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidadInput | doctorCreateOrConnectWithoutEspecialidadInput[]
    upsert?: doctorUpsertWithWhereUniqueWithoutEspecialidadInput | doctorUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: doctorCreateManyEspecialidadInputEnvelope
    set?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    disconnect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    delete?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    update?: doctorUpdateWithWhereUniqueWithoutEspecialidadInput | doctorUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: doctorUpdateManyWithWhereWithoutEspecialidadInput | doctorUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: doctorScalarWhereInput | doctorScalarWhereInput[]
  }

  export type especialidad_doctorUncheckedUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput> | especialidad_doctorCreateWithoutEspecialidadInput[] | especialidad_doctorUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: especialidad_doctorCreateOrConnectWithoutEspecialidadInput | especialidad_doctorCreateOrConnectWithoutEspecialidadInput[]
    upsert?: especialidad_doctorUpsertWithWhereUniqueWithoutEspecialidadInput | especialidad_doctorUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: especialidad_doctorCreateManyEspecialidadInputEnvelope
    set?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    disconnect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    delete?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    connect?: especialidad_doctorWhereUniqueInput | especialidad_doctorWhereUniqueInput[]
    update?: especialidad_doctorUpdateWithWhereUniqueWithoutEspecialidadInput | especialidad_doctorUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: especialidad_doctorUpdateManyWithWhereWithoutEspecialidadInput | especialidad_doctorUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
  }

  export type doctorCreateNestedOneWithoutEspecialidad_doctorInput = {
    create?: XOR<doctorCreateWithoutEspecialidad_doctorInput, doctorUncheckedCreateWithoutEspecialidad_doctorInput>
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidad_doctorInput
    connect?: doctorWhereUniqueInput
  }

  export type especialidadCreateNestedOneWithoutEspecialidad_doctorInput = {
    create?: XOR<especialidadCreateWithoutEspecialidad_doctorInput, especialidadUncheckedCreateWithoutEspecialidad_doctorInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutEspecialidad_doctorInput
    connect?: especialidadWhereUniqueInput
  }

  export type doctorUpdateOneWithoutEspecialidad_doctorNestedInput = {
    create?: XOR<doctorCreateWithoutEspecialidad_doctorInput, doctorUncheckedCreateWithoutEspecialidad_doctorInput>
    connectOrCreate?: doctorCreateOrConnectWithoutEspecialidad_doctorInput
    upsert?: doctorUpsertWithoutEspecialidad_doctorInput
    disconnect?: doctorWhereInput | boolean
    delete?: doctorWhereInput | boolean
    connect?: doctorWhereUniqueInput
    update?: XOR<XOR<doctorUpdateToOneWithWhereWithoutEspecialidad_doctorInput, doctorUpdateWithoutEspecialidad_doctorInput>, doctorUncheckedUpdateWithoutEspecialidad_doctorInput>
  }

  export type especialidadUpdateOneWithoutEspecialidad_doctorNestedInput = {
    create?: XOR<especialidadCreateWithoutEspecialidad_doctorInput, especialidadUncheckedCreateWithoutEspecialidad_doctorInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutEspecialidad_doctorInput
    upsert?: especialidadUpsertWithoutEspecialidad_doctorInput
    disconnect?: especialidadWhereInput | boolean
    delete?: especialidadWhereInput | boolean
    connect?: especialidadWhereUniqueInput
    update?: XOR<XOR<especialidadUpdateToOneWithWhereWithoutEspecialidad_doctorInput, especialidadUpdateWithoutEspecialidad_doctorInput>, especialidadUncheckedUpdateWithoutEspecialidad_doctorInput>
  }

  export type pacienteCreateNestedOneWithoutExamenInput = {
    create?: XOR<pacienteCreateWithoutExamenInput, pacienteUncheckedCreateWithoutExamenInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutExamenInput
    connect?: pacienteWhereUniqueInput
  }

  export type pacienteUpdateOneWithoutExamenNestedInput = {
    create?: XOR<pacienteCreateWithoutExamenInput, pacienteUncheckedCreateWithoutExamenInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutExamenInput
    upsert?: pacienteUpsertWithoutExamenInput
    disconnect?: pacienteWhereInput | boolean
    delete?: pacienteWhereInput | boolean
    connect?: pacienteWhereUniqueInput
    update?: XOR<XOR<pacienteUpdateToOneWithWhereWithoutExamenInput, pacienteUpdateWithoutExamenInput>, pacienteUncheckedUpdateWithoutExamenInput>
  }

  export type proveedorCreateNestedOneWithoutMedicamentoInput = {
    create?: XOR<proveedorCreateWithoutMedicamentoInput, proveedorUncheckedCreateWithoutMedicamentoInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutMedicamentoInput
    connect?: proveedorWhereUniqueInput
  }

  export type proveedorUpdateOneWithoutMedicamentoNestedInput = {
    create?: XOR<proveedorCreateWithoutMedicamentoInput, proveedorUncheckedCreateWithoutMedicamentoInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutMedicamentoInput
    upsert?: proveedorUpsertWithoutMedicamentoInput
    disconnect?: proveedorWhereInput | boolean
    delete?: proveedorWhereInput | boolean
    connect?: proveedorWhereUniqueInput
    update?: XOR<XOR<proveedorUpdateToOneWithWhereWithoutMedicamentoInput, proveedorUpdateWithoutMedicamentoInput>, proveedorUncheckedUpdateWithoutMedicamentoInput>
  }

  export type citaCreateNestedManyWithoutPacienteInput = {
    create?: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput> | citaCreateWithoutPacienteInput[] | citaUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: citaCreateOrConnectWithoutPacienteInput | citaCreateOrConnectWithoutPacienteInput[]
    createMany?: citaCreateManyPacienteInputEnvelope
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
  }

  export type examenCreateNestedManyWithoutPacienteInput = {
    create?: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput> | examenCreateWithoutPacienteInput[] | examenUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: examenCreateOrConnectWithoutPacienteInput | examenCreateOrConnectWithoutPacienteInput[]
    createMany?: examenCreateManyPacienteInputEnvelope
    connect?: examenWhereUniqueInput | examenWhereUniqueInput[]
  }

  export type usuarioCreateNestedOneWithoutPacienteInput = {
    create?: XOR<usuarioCreateWithoutPacienteInput, usuarioUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPacienteInput
    connect?: usuarioWhereUniqueInput
  }

  export type pagoCreateNestedManyWithoutPacienteInput = {
    create?: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput> | pagoCreateWithoutPacienteInput[] | pagoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutPacienteInput | pagoCreateOrConnectWithoutPacienteInput[]
    createMany?: pagoCreateManyPacienteInputEnvelope
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
  }

  export type citaUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput> | citaCreateWithoutPacienteInput[] | citaUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: citaCreateOrConnectWithoutPacienteInput | citaCreateOrConnectWithoutPacienteInput[]
    createMany?: citaCreateManyPacienteInputEnvelope
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
  }

  export type examenUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput> | examenCreateWithoutPacienteInput[] | examenUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: examenCreateOrConnectWithoutPacienteInput | examenCreateOrConnectWithoutPacienteInput[]
    createMany?: examenCreateManyPacienteInputEnvelope
    connect?: examenWhereUniqueInput | examenWhereUniqueInput[]
  }

  export type pagoUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput> | pagoCreateWithoutPacienteInput[] | pagoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutPacienteInput | pagoCreateOrConnectWithoutPacienteInput[]
    createMany?: pagoCreateManyPacienteInputEnvelope
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
  }

  export type citaUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput> | citaCreateWithoutPacienteInput[] | citaUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: citaCreateOrConnectWithoutPacienteInput | citaCreateOrConnectWithoutPacienteInput[]
    upsert?: citaUpsertWithWhereUniqueWithoutPacienteInput | citaUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: citaCreateManyPacienteInputEnvelope
    set?: citaWhereUniqueInput | citaWhereUniqueInput[]
    disconnect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    delete?: citaWhereUniqueInput | citaWhereUniqueInput[]
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    update?: citaUpdateWithWhereUniqueWithoutPacienteInput | citaUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: citaUpdateManyWithWhereWithoutPacienteInput | citaUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: citaScalarWhereInput | citaScalarWhereInput[]
  }

  export type examenUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput> | examenCreateWithoutPacienteInput[] | examenUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: examenCreateOrConnectWithoutPacienteInput | examenCreateOrConnectWithoutPacienteInput[]
    upsert?: examenUpsertWithWhereUniqueWithoutPacienteInput | examenUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: examenCreateManyPacienteInputEnvelope
    set?: examenWhereUniqueInput | examenWhereUniqueInput[]
    disconnect?: examenWhereUniqueInput | examenWhereUniqueInput[]
    delete?: examenWhereUniqueInput | examenWhereUniqueInput[]
    connect?: examenWhereUniqueInput | examenWhereUniqueInput[]
    update?: examenUpdateWithWhereUniqueWithoutPacienteInput | examenUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: examenUpdateManyWithWhereWithoutPacienteInput | examenUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: examenScalarWhereInput | examenScalarWhereInput[]
  }

  export type usuarioUpdateOneWithoutPacienteNestedInput = {
    create?: XOR<usuarioCreateWithoutPacienteInput, usuarioUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPacienteInput
    upsert?: usuarioUpsertWithoutPacienteInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutPacienteInput, usuarioUpdateWithoutPacienteInput>, usuarioUncheckedUpdateWithoutPacienteInput>
  }

  export type pagoUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput> | pagoCreateWithoutPacienteInput[] | pagoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutPacienteInput | pagoCreateOrConnectWithoutPacienteInput[]
    upsert?: pagoUpsertWithWhereUniqueWithoutPacienteInput | pagoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: pagoCreateManyPacienteInputEnvelope
    set?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    disconnect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    delete?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    update?: pagoUpdateWithWhereUniqueWithoutPacienteInput | pagoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: pagoUpdateManyWithWhereWithoutPacienteInput | pagoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: pagoScalarWhereInput | pagoScalarWhereInput[]
  }

  export type citaUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput> | citaCreateWithoutPacienteInput[] | citaUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: citaCreateOrConnectWithoutPacienteInput | citaCreateOrConnectWithoutPacienteInput[]
    upsert?: citaUpsertWithWhereUniqueWithoutPacienteInput | citaUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: citaCreateManyPacienteInputEnvelope
    set?: citaWhereUniqueInput | citaWhereUniqueInput[]
    disconnect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    delete?: citaWhereUniqueInput | citaWhereUniqueInput[]
    connect?: citaWhereUniqueInput | citaWhereUniqueInput[]
    update?: citaUpdateWithWhereUniqueWithoutPacienteInput | citaUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: citaUpdateManyWithWhereWithoutPacienteInput | citaUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: citaScalarWhereInput | citaScalarWhereInput[]
  }

  export type examenUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput> | examenCreateWithoutPacienteInput[] | examenUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: examenCreateOrConnectWithoutPacienteInput | examenCreateOrConnectWithoutPacienteInput[]
    upsert?: examenUpsertWithWhereUniqueWithoutPacienteInput | examenUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: examenCreateManyPacienteInputEnvelope
    set?: examenWhereUniqueInput | examenWhereUniqueInput[]
    disconnect?: examenWhereUniqueInput | examenWhereUniqueInput[]
    delete?: examenWhereUniqueInput | examenWhereUniqueInput[]
    connect?: examenWhereUniqueInput | examenWhereUniqueInput[]
    update?: examenUpdateWithWhereUniqueWithoutPacienteInput | examenUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: examenUpdateManyWithWhereWithoutPacienteInput | examenUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: examenScalarWhereInput | examenScalarWhereInput[]
  }

  export type pagoUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput> | pagoCreateWithoutPacienteInput[] | pagoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutPacienteInput | pagoCreateOrConnectWithoutPacienteInput[]
    upsert?: pagoUpsertWithWhereUniqueWithoutPacienteInput | pagoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: pagoCreateManyPacienteInputEnvelope
    set?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    disconnect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    delete?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    update?: pagoUpdateWithWhereUniqueWithoutPacienteInput | pagoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: pagoUpdateManyWithWhereWithoutPacienteInput | pagoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: pagoScalarWhereInput | pagoScalarWhereInput[]
  }

  export type pacienteCreateNestedOneWithoutPagoInput = {
    create?: XOR<pacienteCreateWithoutPagoInput, pacienteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutPagoInput
    connect?: pacienteWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type pacienteUpdateOneRequiredWithoutPagoNestedInput = {
    create?: XOR<pacienteCreateWithoutPagoInput, pacienteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: pacienteCreateOrConnectWithoutPagoInput
    upsert?: pacienteUpsertWithoutPagoInput
    connect?: pacienteWhereUniqueInput
    update?: XOR<XOR<pacienteUpdateToOneWithWhereWithoutPagoInput, pacienteUpdateWithoutPagoInput>, pacienteUncheckedUpdateWithoutPagoInput>
  }

  export type recetaCreateNestedOneWithoutPrescripcionInput = {
    create?: XOR<recetaCreateWithoutPrescripcionInput, recetaUncheckedCreateWithoutPrescripcionInput>
    connectOrCreate?: recetaCreateOrConnectWithoutPrescripcionInput
    connect?: recetaWhereUniqueInput
  }

  export type recetaUpdateOneWithoutPrescripcionNestedInput = {
    create?: XOR<recetaCreateWithoutPrescripcionInput, recetaUncheckedCreateWithoutPrescripcionInput>
    connectOrCreate?: recetaCreateOrConnectWithoutPrescripcionInput
    upsert?: recetaUpsertWithoutPrescripcionInput
    disconnect?: recetaWhereInput | boolean
    delete?: recetaWhereInput | boolean
    connect?: recetaWhereUniqueInput
    update?: XOR<XOR<recetaUpdateToOneWithWhereWithoutPrescripcionInput, recetaUpdateWithoutPrescripcionInput>, recetaUncheckedUpdateWithoutPrescripcionInput>
  }

  export type medicamentoCreateNestedManyWithoutProveedorInput = {
    create?: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput> | medicamentoCreateWithoutProveedorInput[] | medicamentoUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: medicamentoCreateOrConnectWithoutProveedorInput | medicamentoCreateOrConnectWithoutProveedorInput[]
    createMany?: medicamentoCreateManyProveedorInputEnvelope
    connect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
  }

  export type usuarioCreateNestedOneWithoutProveedorInput = {
    create?: XOR<usuarioCreateWithoutProveedorInput, usuarioUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProveedorInput
    connect?: usuarioWhereUniqueInput
  }

  export type medicamentoUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput> | medicamentoCreateWithoutProveedorInput[] | medicamentoUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: medicamentoCreateOrConnectWithoutProveedorInput | medicamentoCreateOrConnectWithoutProveedorInput[]
    createMany?: medicamentoCreateManyProveedorInputEnvelope
    connect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type medicamentoUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput> | medicamentoCreateWithoutProveedorInput[] | medicamentoUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: medicamentoCreateOrConnectWithoutProveedorInput | medicamentoCreateOrConnectWithoutProveedorInput[]
    upsert?: medicamentoUpsertWithWhereUniqueWithoutProveedorInput | medicamentoUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: medicamentoCreateManyProveedorInputEnvelope
    set?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    disconnect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    delete?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    connect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    update?: medicamentoUpdateWithWhereUniqueWithoutProveedorInput | medicamentoUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: medicamentoUpdateManyWithWhereWithoutProveedorInput | medicamentoUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: medicamentoScalarWhereInput | medicamentoScalarWhereInput[]
  }

  export type usuarioUpdateOneWithoutProveedorNestedInput = {
    create?: XOR<usuarioCreateWithoutProveedorInput, usuarioUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProveedorInput
    upsert?: usuarioUpsertWithoutProveedorInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutProveedorInput, usuarioUpdateWithoutProveedorInput>, usuarioUncheckedUpdateWithoutProveedorInput>
  }

  export type medicamentoUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput> | medicamentoCreateWithoutProveedorInput[] | medicamentoUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: medicamentoCreateOrConnectWithoutProveedorInput | medicamentoCreateOrConnectWithoutProveedorInput[]
    upsert?: medicamentoUpsertWithWhereUniqueWithoutProveedorInput | medicamentoUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: medicamentoCreateManyProveedorInputEnvelope
    set?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    disconnect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    delete?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    connect?: medicamentoWhereUniqueInput | medicamentoWhereUniqueInput[]
    update?: medicamentoUpdateWithWhereUniqueWithoutProveedorInput | medicamentoUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: medicamentoUpdateManyWithWhereWithoutProveedorInput | medicamentoUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: medicamentoScalarWhereInput | medicamentoScalarWhereInput[]
  }

  export type prescripcionCreateNestedManyWithoutRecetaInput = {
    create?: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput> | prescripcionCreateWithoutRecetaInput[] | prescripcionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: prescripcionCreateOrConnectWithoutRecetaInput | prescripcionCreateOrConnectWithoutRecetaInput[]
    createMany?: prescripcionCreateManyRecetaInputEnvelope
    connect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
  }

  export type tratamientoCreateNestedOneWithoutRecetaInput = {
    create?: XOR<tratamientoCreateWithoutRecetaInput, tratamientoUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: tratamientoCreateOrConnectWithoutRecetaInput
    connect?: tratamientoWhereUniqueInput
  }

  export type prescripcionUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput> | prescripcionCreateWithoutRecetaInput[] | prescripcionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: prescripcionCreateOrConnectWithoutRecetaInput | prescripcionCreateOrConnectWithoutRecetaInput[]
    createMany?: prescripcionCreateManyRecetaInputEnvelope
    connect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
  }

  export type prescripcionUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput> | prescripcionCreateWithoutRecetaInput[] | prescripcionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: prescripcionCreateOrConnectWithoutRecetaInput | prescripcionCreateOrConnectWithoutRecetaInput[]
    upsert?: prescripcionUpsertWithWhereUniqueWithoutRecetaInput | prescripcionUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: prescripcionCreateManyRecetaInputEnvelope
    set?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    disconnect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    delete?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    connect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    update?: prescripcionUpdateWithWhereUniqueWithoutRecetaInput | prescripcionUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: prescripcionUpdateManyWithWhereWithoutRecetaInput | prescripcionUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: prescripcionScalarWhereInput | prescripcionScalarWhereInput[]
  }

  export type tratamientoUpdateOneWithoutRecetaNestedInput = {
    create?: XOR<tratamientoCreateWithoutRecetaInput, tratamientoUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: tratamientoCreateOrConnectWithoutRecetaInput
    upsert?: tratamientoUpsertWithoutRecetaInput
    disconnect?: tratamientoWhereInput | boolean
    delete?: tratamientoWhereInput | boolean
    connect?: tratamientoWhereUniqueInput
    update?: XOR<XOR<tratamientoUpdateToOneWithWhereWithoutRecetaInput, tratamientoUpdateWithoutRecetaInput>, tratamientoUncheckedUpdateWithoutRecetaInput>
  }

  export type prescripcionUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput> | prescripcionCreateWithoutRecetaInput[] | prescripcionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: prescripcionCreateOrConnectWithoutRecetaInput | prescripcionCreateOrConnectWithoutRecetaInput[]
    upsert?: prescripcionUpsertWithWhereUniqueWithoutRecetaInput | prescripcionUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: prescripcionCreateManyRecetaInputEnvelope
    set?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    disconnect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    delete?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    connect?: prescripcionWhereUniqueInput | prescripcionWhereUniqueInput[]
    update?: prescripcionUpdateWithWhereUniqueWithoutRecetaInput | prescripcionUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: prescripcionUpdateManyWithWhereWithoutRecetaInput | prescripcionUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: prescripcionScalarWhereInput | prescripcionScalarWhereInput[]
  }

  export type usuarioCreateNestedOneWithoutSecretariaInput = {
    create?: XOR<usuarioCreateWithoutSecretariaInput, usuarioUncheckedCreateWithoutSecretariaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutSecretariaInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneWithoutSecretariaNestedInput = {
    create?: XOR<usuarioCreateWithoutSecretariaInput, usuarioUncheckedCreateWithoutSecretariaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutSecretariaInput
    upsert?: usuarioUpsertWithoutSecretariaInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutSecretariaInput, usuarioUpdateWithoutSecretariaInput>, usuarioUncheckedUpdateWithoutSecretariaInput>
  }

  export type recetaCreateNestedManyWithoutTratamientoInput = {
    create?: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput> | recetaCreateWithoutTratamientoInput[] | recetaUncheckedCreateWithoutTratamientoInput[]
    connectOrCreate?: recetaCreateOrConnectWithoutTratamientoInput | recetaCreateOrConnectWithoutTratamientoInput[]
    createMany?: recetaCreateManyTratamientoInputEnvelope
    connect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
  }

  export type diagnosticoCreateNestedOneWithoutTratamientoInput = {
    create?: XOR<diagnosticoCreateWithoutTratamientoInput, diagnosticoUncheckedCreateWithoutTratamientoInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutTratamientoInput
    connect?: diagnosticoWhereUniqueInput
  }

  export type recetaUncheckedCreateNestedManyWithoutTratamientoInput = {
    create?: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput> | recetaCreateWithoutTratamientoInput[] | recetaUncheckedCreateWithoutTratamientoInput[]
    connectOrCreate?: recetaCreateOrConnectWithoutTratamientoInput | recetaCreateOrConnectWithoutTratamientoInput[]
    createMany?: recetaCreateManyTratamientoInputEnvelope
    connect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
  }

  export type recetaUpdateManyWithoutTratamientoNestedInput = {
    create?: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput> | recetaCreateWithoutTratamientoInput[] | recetaUncheckedCreateWithoutTratamientoInput[]
    connectOrCreate?: recetaCreateOrConnectWithoutTratamientoInput | recetaCreateOrConnectWithoutTratamientoInput[]
    upsert?: recetaUpsertWithWhereUniqueWithoutTratamientoInput | recetaUpsertWithWhereUniqueWithoutTratamientoInput[]
    createMany?: recetaCreateManyTratamientoInputEnvelope
    set?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    disconnect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    delete?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    connect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    update?: recetaUpdateWithWhereUniqueWithoutTratamientoInput | recetaUpdateWithWhereUniqueWithoutTratamientoInput[]
    updateMany?: recetaUpdateManyWithWhereWithoutTratamientoInput | recetaUpdateManyWithWhereWithoutTratamientoInput[]
    deleteMany?: recetaScalarWhereInput | recetaScalarWhereInput[]
  }

  export type diagnosticoUpdateOneWithoutTratamientoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutTratamientoInput, diagnosticoUncheckedCreateWithoutTratamientoInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutTratamientoInput
    upsert?: diagnosticoUpsertWithoutTratamientoInput
    disconnect?: diagnosticoWhereInput | boolean
    delete?: diagnosticoWhereInput | boolean
    connect?: diagnosticoWhereUniqueInput
    update?: XOR<XOR<diagnosticoUpdateToOneWithWhereWithoutTratamientoInput, diagnosticoUpdateWithoutTratamientoInput>, diagnosticoUncheckedUpdateWithoutTratamientoInput>
  }

  export type recetaUncheckedUpdateManyWithoutTratamientoNestedInput = {
    create?: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput> | recetaCreateWithoutTratamientoInput[] | recetaUncheckedCreateWithoutTratamientoInput[]
    connectOrCreate?: recetaCreateOrConnectWithoutTratamientoInput | recetaCreateOrConnectWithoutTratamientoInput[]
    upsert?: recetaUpsertWithWhereUniqueWithoutTratamientoInput | recetaUpsertWithWhereUniqueWithoutTratamientoInput[]
    createMany?: recetaCreateManyTratamientoInputEnvelope
    set?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    disconnect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    delete?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    connect?: recetaWhereUniqueInput | recetaWhereUniqueInput[]
    update?: recetaUpdateWithWhereUniqueWithoutTratamientoInput | recetaUpdateWithWhereUniqueWithoutTratamientoInput[]
    updateMany?: recetaUpdateManyWithWhereWithoutTratamientoInput | recetaUpdateManyWithWhereWithoutTratamientoInput[]
    deleteMany?: recetaScalarWhereInput | recetaScalarWhereInput[]
  }

  export type administradorCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput> | administradorCreateWithoutUsuarioInput[] | administradorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput | administradorCreateOrConnectWithoutUsuarioInput[]
    createMany?: administradorCreateManyUsuarioInputEnvelope
    connect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
  }

  export type doctorCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput> | doctorCreateWithoutUsuarioInput[] | doctorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutUsuarioInput | doctorCreateOrConnectWithoutUsuarioInput[]
    createMany?: doctorCreateManyUsuarioInputEnvelope
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
  }

  export type pacienteCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput> | pacienteCreateWithoutUsuarioInput[] | pacienteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: pacienteCreateOrConnectWithoutUsuarioInput | pacienteCreateOrConnectWithoutUsuarioInput[]
    createMany?: pacienteCreateManyUsuarioInputEnvelope
    connect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
  }

  export type proveedorCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput> | proveedorCreateWithoutUsuarioInput[] | proveedorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutUsuarioInput | proveedorCreateOrConnectWithoutUsuarioInput[]
    createMany?: proveedorCreateManyUsuarioInputEnvelope
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
  }

  export type secretariaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput> | secretariaCreateWithoutUsuarioInput[] | secretariaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: secretariaCreateOrConnectWithoutUsuarioInput | secretariaCreateOrConnectWithoutUsuarioInput[]
    createMany?: secretariaCreateManyUsuarioInputEnvelope
    connect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
  }

  export type administradorUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput> | administradorCreateWithoutUsuarioInput[] | administradorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput | administradorCreateOrConnectWithoutUsuarioInput[]
    createMany?: administradorCreateManyUsuarioInputEnvelope
    connect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
  }

  export type doctorUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput> | doctorCreateWithoutUsuarioInput[] | doctorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutUsuarioInput | doctorCreateOrConnectWithoutUsuarioInput[]
    createMany?: doctorCreateManyUsuarioInputEnvelope
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
  }

  export type pacienteUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput> | pacienteCreateWithoutUsuarioInput[] | pacienteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: pacienteCreateOrConnectWithoutUsuarioInput | pacienteCreateOrConnectWithoutUsuarioInput[]
    createMany?: pacienteCreateManyUsuarioInputEnvelope
    connect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
  }

  export type proveedorUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput> | proveedorCreateWithoutUsuarioInput[] | proveedorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutUsuarioInput | proveedorCreateOrConnectWithoutUsuarioInput[]
    createMany?: proveedorCreateManyUsuarioInputEnvelope
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
  }

  export type secretariaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput> | secretariaCreateWithoutUsuarioInput[] | secretariaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: secretariaCreateOrConnectWithoutUsuarioInput | secretariaCreateOrConnectWithoutUsuarioInput[]
    createMany?: secretariaCreateManyUsuarioInputEnvelope
    connect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
  }

  export type administradorUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput> | administradorCreateWithoutUsuarioInput[] | administradorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput | administradorCreateOrConnectWithoutUsuarioInput[]
    upsert?: administradorUpsertWithWhereUniqueWithoutUsuarioInput | administradorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: administradorCreateManyUsuarioInputEnvelope
    set?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    disconnect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    delete?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    connect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    update?: administradorUpdateWithWhereUniqueWithoutUsuarioInput | administradorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: administradorUpdateManyWithWhereWithoutUsuarioInput | administradorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: administradorScalarWhereInput | administradorScalarWhereInput[]
  }

  export type doctorUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput> | doctorCreateWithoutUsuarioInput[] | doctorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutUsuarioInput | doctorCreateOrConnectWithoutUsuarioInput[]
    upsert?: doctorUpsertWithWhereUniqueWithoutUsuarioInput | doctorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: doctorCreateManyUsuarioInputEnvelope
    set?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    disconnect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    delete?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    update?: doctorUpdateWithWhereUniqueWithoutUsuarioInput | doctorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: doctorUpdateManyWithWhereWithoutUsuarioInput | doctorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: doctorScalarWhereInput | doctorScalarWhereInput[]
  }

  export type pacienteUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput> | pacienteCreateWithoutUsuarioInput[] | pacienteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: pacienteCreateOrConnectWithoutUsuarioInput | pacienteCreateOrConnectWithoutUsuarioInput[]
    upsert?: pacienteUpsertWithWhereUniqueWithoutUsuarioInput | pacienteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: pacienteCreateManyUsuarioInputEnvelope
    set?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    disconnect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    delete?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    connect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    update?: pacienteUpdateWithWhereUniqueWithoutUsuarioInput | pacienteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: pacienteUpdateManyWithWhereWithoutUsuarioInput | pacienteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: pacienteScalarWhereInput | pacienteScalarWhereInput[]
  }

  export type proveedorUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput> | proveedorCreateWithoutUsuarioInput[] | proveedorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutUsuarioInput | proveedorCreateOrConnectWithoutUsuarioInput[]
    upsert?: proveedorUpsertWithWhereUniqueWithoutUsuarioInput | proveedorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: proveedorCreateManyUsuarioInputEnvelope
    set?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    disconnect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    delete?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    update?: proveedorUpdateWithWhereUniqueWithoutUsuarioInput | proveedorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: proveedorUpdateManyWithWhereWithoutUsuarioInput | proveedorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
  }

  export type secretariaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput> | secretariaCreateWithoutUsuarioInput[] | secretariaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: secretariaCreateOrConnectWithoutUsuarioInput | secretariaCreateOrConnectWithoutUsuarioInput[]
    upsert?: secretariaUpsertWithWhereUniqueWithoutUsuarioInput | secretariaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: secretariaCreateManyUsuarioInputEnvelope
    set?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    disconnect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    delete?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    connect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    update?: secretariaUpdateWithWhereUniqueWithoutUsuarioInput | secretariaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: secretariaUpdateManyWithWhereWithoutUsuarioInput | secretariaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: secretariaScalarWhereInput | secretariaScalarWhereInput[]
  }

  export type administradorUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput> | administradorCreateWithoutUsuarioInput[] | administradorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput | administradorCreateOrConnectWithoutUsuarioInput[]
    upsert?: administradorUpsertWithWhereUniqueWithoutUsuarioInput | administradorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: administradorCreateManyUsuarioInputEnvelope
    set?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    disconnect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    delete?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    connect?: administradorWhereUniqueInput | administradorWhereUniqueInput[]
    update?: administradorUpdateWithWhereUniqueWithoutUsuarioInput | administradorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: administradorUpdateManyWithWhereWithoutUsuarioInput | administradorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: administradorScalarWhereInput | administradorScalarWhereInput[]
  }

  export type doctorUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput> | doctorCreateWithoutUsuarioInput[] | doctorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: doctorCreateOrConnectWithoutUsuarioInput | doctorCreateOrConnectWithoutUsuarioInput[]
    upsert?: doctorUpsertWithWhereUniqueWithoutUsuarioInput | doctorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: doctorCreateManyUsuarioInputEnvelope
    set?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    disconnect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    delete?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    connect?: doctorWhereUniqueInput | doctorWhereUniqueInput[]
    update?: doctorUpdateWithWhereUniqueWithoutUsuarioInput | doctorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: doctorUpdateManyWithWhereWithoutUsuarioInput | doctorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: doctorScalarWhereInput | doctorScalarWhereInput[]
  }

  export type pacienteUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput> | pacienteCreateWithoutUsuarioInput[] | pacienteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: pacienteCreateOrConnectWithoutUsuarioInput | pacienteCreateOrConnectWithoutUsuarioInput[]
    upsert?: pacienteUpsertWithWhereUniqueWithoutUsuarioInput | pacienteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: pacienteCreateManyUsuarioInputEnvelope
    set?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    disconnect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    delete?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    connect?: pacienteWhereUniqueInput | pacienteWhereUniqueInput[]
    update?: pacienteUpdateWithWhereUniqueWithoutUsuarioInput | pacienteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: pacienteUpdateManyWithWhereWithoutUsuarioInput | pacienteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: pacienteScalarWhereInput | pacienteScalarWhereInput[]
  }

  export type proveedorUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput> | proveedorCreateWithoutUsuarioInput[] | proveedorUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutUsuarioInput | proveedorCreateOrConnectWithoutUsuarioInput[]
    upsert?: proveedorUpsertWithWhereUniqueWithoutUsuarioInput | proveedorUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: proveedorCreateManyUsuarioInputEnvelope
    set?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    disconnect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    delete?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    update?: proveedorUpdateWithWhereUniqueWithoutUsuarioInput | proveedorUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: proveedorUpdateManyWithWhereWithoutUsuarioInput | proveedorUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
  }

  export type secretariaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput> | secretariaCreateWithoutUsuarioInput[] | secretariaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: secretariaCreateOrConnectWithoutUsuarioInput | secretariaCreateOrConnectWithoutUsuarioInput[]
    upsert?: secretariaUpsertWithWhereUniqueWithoutUsuarioInput | secretariaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: secretariaCreateManyUsuarioInputEnvelope
    set?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    disconnect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    delete?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    connect?: secretariaWhereUniqueInput | secretariaWhereUniqueInput[]
    update?: secretariaUpdateWithWhereUniqueWithoutUsuarioInput | secretariaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: secretariaUpdateManyWithWhereWithoutUsuarioInput | secretariaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: secretariaScalarWhereInput | secretariaScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type usuarioCreateWithoutAdministradorInput = {
    nombre: string
    contrasena: string
    rol: string
    doctor?: doctorCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutAdministradorInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    doctor?: doctorUncheckedCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteUncheckedCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutAdministradorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
  }

  export type usuarioUpsertWithoutAdministradorInput = {
    update: XOR<usuarioUpdateWithoutAdministradorInput, usuarioUncheckedUpdateWithoutAdministradorInput>
    create: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutAdministradorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutAdministradorInput, usuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type usuarioUpdateWithoutAdministradorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    doctor?: doctorUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutAdministradorInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    doctor?: doctorUncheckedUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUncheckedUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type doctorCreateWithoutCitaInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    especialidad?: especialidadCreateNestedOneWithoutDoctorInput
    usuario?: usuarioCreateNestedOneWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutDoctorInput
  }

  export type doctorUncheckedCreateWithoutCitaInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type doctorCreateOrConnectWithoutCitaInput = {
    where: doctorWhereUniqueInput
    create: XOR<doctorCreateWithoutCitaInput, doctorUncheckedCreateWithoutCitaInput>
  }

  export type pacienteCreateWithoutCitaInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    examen?: examenCreateNestedManyWithoutPacienteInput
    usuario?: usuarioCreateNestedOneWithoutPacienteInput
    pago?: pagoCreateNestedManyWithoutPacienteInput
  }

  export type pacienteUncheckedCreateWithoutCitaInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    examen?: examenUncheckedCreateNestedManyWithoutPacienteInput
    pago?: pagoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type pacienteCreateOrConnectWithoutCitaInput = {
    where: pacienteWhereUniqueInput
    create: XOR<pacienteCreateWithoutCitaInput, pacienteUncheckedCreateWithoutCitaInput>
  }

  export type consultaCreateWithoutCitaInput = {
    fecha?: Date | string | null
    motivo?: string | null
    diagnostico?: diagnosticoCreateNestedManyWithoutConsultaInput
  }

  export type consultaUncheckedCreateWithoutCitaInput = {
    id_consulta?: number
    fecha?: Date | string | null
    motivo?: string | null
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutConsultaInput
  }

  export type consultaCreateOrConnectWithoutCitaInput = {
    where: consultaWhereUniqueInput
    create: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput>
  }

  export type consultaCreateManyCitaInputEnvelope = {
    data: consultaCreateManyCitaInput | consultaCreateManyCitaInput[]
    skipDuplicates?: boolean
  }

  export type doctorUpsertWithoutCitaInput = {
    update: XOR<doctorUpdateWithoutCitaInput, doctorUncheckedUpdateWithoutCitaInput>
    create: XOR<doctorCreateWithoutCitaInput, doctorUncheckedCreateWithoutCitaInput>
    where?: doctorWhereInput
  }

  export type doctorUpdateToOneWithWhereWithoutCitaInput = {
    where?: doctorWhereInput
    data: XOR<doctorUpdateWithoutCitaInput, doctorUncheckedUpdateWithoutCitaInput>
  }

  export type doctorUpdateWithoutCitaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: especialidadUpdateOneWithoutDoctorNestedInput
    usuario?: usuarioUpdateOneWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateWithoutCitaInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type pacienteUpsertWithoutCitaInput = {
    update: XOR<pacienteUpdateWithoutCitaInput, pacienteUncheckedUpdateWithoutCitaInput>
    create: XOR<pacienteCreateWithoutCitaInput, pacienteUncheckedCreateWithoutCitaInput>
    where?: pacienteWhereInput
  }

  export type pacienteUpdateToOneWithWhereWithoutCitaInput = {
    where?: pacienteWhereInput
    data: XOR<pacienteUpdateWithoutCitaInput, pacienteUncheckedUpdateWithoutCitaInput>
  }

  export type pacienteUpdateWithoutCitaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    examen?: examenUpdateManyWithoutPacienteNestedInput
    usuario?: usuarioUpdateOneWithoutPacienteNestedInput
    pago?: pagoUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateWithoutCitaInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    examen?: examenUncheckedUpdateManyWithoutPacienteNestedInput
    pago?: pagoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type consultaUpsertWithWhereUniqueWithoutCitaInput = {
    where: consultaWhereUniqueInput
    update: XOR<consultaUpdateWithoutCitaInput, consultaUncheckedUpdateWithoutCitaInput>
    create: XOR<consultaCreateWithoutCitaInput, consultaUncheckedCreateWithoutCitaInput>
  }

  export type consultaUpdateWithWhereUniqueWithoutCitaInput = {
    where: consultaWhereUniqueInput
    data: XOR<consultaUpdateWithoutCitaInput, consultaUncheckedUpdateWithoutCitaInput>
  }

  export type consultaUpdateManyWithWhereWithoutCitaInput = {
    where: consultaScalarWhereInput
    data: XOR<consultaUpdateManyMutationInput, consultaUncheckedUpdateManyWithoutCitaInput>
  }

  export type consultaScalarWhereInput = {
    AND?: consultaScalarWhereInput | consultaScalarWhereInput[]
    OR?: consultaScalarWhereInput[]
    NOT?: consultaScalarWhereInput | consultaScalarWhereInput[]
    id_consulta?: IntFilter<"consulta"> | number
    fecha?: DateTimeNullableFilter<"consulta"> | Date | string | null
    motivo?: StringNullableFilter<"consulta"> | string | null
    id_cita?: IntNullableFilter<"consulta"> | number | null
  }

  export type citaCreateWithoutConsultaInput = {
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    hora_llegada?: Date | string | null
    doctor?: doctorCreateNestedOneWithoutCitaInput
    paciente?: pacienteCreateNestedOneWithoutCitaInput
  }

  export type citaUncheckedCreateWithoutConsultaInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_doctor?: number | null
    id_paciente?: number | null
    hora_llegada?: Date | string | null
  }

  export type citaCreateOrConnectWithoutConsultaInput = {
    where: citaWhereUniqueInput
    create: XOR<citaCreateWithoutConsultaInput, citaUncheckedCreateWithoutConsultaInput>
  }

  export type diagnosticoCreateWithoutConsultaInput = {
    nombrediagnostico?: string | null
    descripcion?: string | null
    tratamiento?: tratamientoCreateNestedManyWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutConsultaInput = {
    id_diagnostico?: number
    nombrediagnostico?: string | null
    descripcion?: string | null
    tratamiento?: tratamientoUncheckedCreateNestedManyWithoutDiagnosticoInput
  }

  export type diagnosticoCreateOrConnectWithoutConsultaInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput>
  }

  export type diagnosticoCreateManyConsultaInputEnvelope = {
    data: diagnosticoCreateManyConsultaInput | diagnosticoCreateManyConsultaInput[]
    skipDuplicates?: boolean
  }

  export type citaUpsertWithoutConsultaInput = {
    update: XOR<citaUpdateWithoutConsultaInput, citaUncheckedUpdateWithoutConsultaInput>
    create: XOR<citaCreateWithoutConsultaInput, citaUncheckedCreateWithoutConsultaInput>
    where?: citaWhereInput
  }

  export type citaUpdateToOneWithWhereWithoutConsultaInput = {
    where?: citaWhereInput
    data: XOR<citaUpdateWithoutConsultaInput, citaUncheckedUpdateWithoutConsultaInput>
  }

  export type citaUpdateWithoutConsultaInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: doctorUpdateOneWithoutCitaNestedInput
    paciente?: pacienteUpdateOneWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateWithoutConsultaInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type diagnosticoUpsertWithWhereUniqueWithoutConsultaInput = {
    where: diagnosticoWhereUniqueInput
    update: XOR<diagnosticoUpdateWithoutConsultaInput, diagnosticoUncheckedUpdateWithoutConsultaInput>
    create: XOR<diagnosticoCreateWithoutConsultaInput, diagnosticoUncheckedCreateWithoutConsultaInput>
  }

  export type diagnosticoUpdateWithWhereUniqueWithoutConsultaInput = {
    where: diagnosticoWhereUniqueInput
    data: XOR<diagnosticoUpdateWithoutConsultaInput, diagnosticoUncheckedUpdateWithoutConsultaInput>
  }

  export type diagnosticoUpdateManyWithWhereWithoutConsultaInput = {
    where: diagnosticoScalarWhereInput
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyWithoutConsultaInput>
  }

  export type diagnosticoScalarWhereInput = {
    AND?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
    OR?: diagnosticoScalarWhereInput[]
    NOT?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
    id_diagnostico?: IntFilter<"diagnostico"> | number
    nombrediagnostico?: StringNullableFilter<"diagnostico"> | string | null
    descripcion?: StringNullableFilter<"diagnostico"> | string | null
    id_consulta?: IntNullableFilter<"diagnostico"> | number | null
  }

  export type consultaCreateWithoutDiagnosticoInput = {
    fecha?: Date | string | null
    motivo?: string | null
    cita?: citaCreateNestedOneWithoutConsultaInput
  }

  export type consultaUncheckedCreateWithoutDiagnosticoInput = {
    id_consulta?: number
    fecha?: Date | string | null
    motivo?: string | null
    id_cita?: number | null
  }

  export type consultaCreateOrConnectWithoutDiagnosticoInput = {
    where: consultaWhereUniqueInput
    create: XOR<consultaCreateWithoutDiagnosticoInput, consultaUncheckedCreateWithoutDiagnosticoInput>
  }

  export type tratamientoCreateWithoutDiagnosticoInput = {
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    receta?: recetaCreateNestedManyWithoutTratamientoInput
  }

  export type tratamientoUncheckedCreateWithoutDiagnosticoInput = {
    id_tratamiento?: number
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    receta?: recetaUncheckedCreateNestedManyWithoutTratamientoInput
  }

  export type tratamientoCreateOrConnectWithoutDiagnosticoInput = {
    where: tratamientoWhereUniqueInput
    create: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type tratamientoCreateManyDiagnosticoInputEnvelope = {
    data: tratamientoCreateManyDiagnosticoInput | tratamientoCreateManyDiagnosticoInput[]
    skipDuplicates?: boolean
  }

  export type consultaUpsertWithoutDiagnosticoInput = {
    update: XOR<consultaUpdateWithoutDiagnosticoInput, consultaUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<consultaCreateWithoutDiagnosticoInput, consultaUncheckedCreateWithoutDiagnosticoInput>
    where?: consultaWhereInput
  }

  export type consultaUpdateToOneWithWhereWithoutDiagnosticoInput = {
    where?: consultaWhereInput
    data: XOR<consultaUpdateWithoutDiagnosticoInput, consultaUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type consultaUpdateWithoutDiagnosticoInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateOneWithoutConsultaNestedInput
  }

  export type consultaUncheckedUpdateWithoutDiagnosticoInput = {
    id_consulta?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_cita?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tratamientoUpsertWithWhereUniqueWithoutDiagnosticoInput = {
    where: tratamientoWhereUniqueInput
    update: XOR<tratamientoUpdateWithoutDiagnosticoInput, tratamientoUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<tratamientoCreateWithoutDiagnosticoInput, tratamientoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type tratamientoUpdateWithWhereUniqueWithoutDiagnosticoInput = {
    where: tratamientoWhereUniqueInput
    data: XOR<tratamientoUpdateWithoutDiagnosticoInput, tratamientoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type tratamientoUpdateManyWithWhereWithoutDiagnosticoInput = {
    where: tratamientoScalarWhereInput
    data: XOR<tratamientoUpdateManyMutationInput, tratamientoUncheckedUpdateManyWithoutDiagnosticoInput>
  }

  export type tratamientoScalarWhereInput = {
    AND?: tratamientoScalarWhereInput | tratamientoScalarWhereInput[]
    OR?: tratamientoScalarWhereInput[]
    NOT?: tratamientoScalarWhereInput | tratamientoScalarWhereInput[]
    id_tratamiento?: IntFilter<"tratamiento"> | number
    tipotratamiento?: StringNullableFilter<"tratamiento"> | string | null
    descripcion?: StringNullableFilter<"tratamiento"> | string | null
    duracion?: StringNullableFilter<"tratamiento"> | string | null
    frecuencia?: StringNullableFilter<"tratamiento"> | string | null
    id_diagnostico?: IntNullableFilter<"tratamiento"> | number | null
  }

  export type citaCreateWithoutDoctorInput = {
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    hora_llegada?: Date | string | null
    paciente?: pacienteCreateNestedOneWithoutCitaInput
    consulta?: consultaCreateNestedManyWithoutCitaInput
  }

  export type citaUncheckedCreateWithoutDoctorInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_paciente?: number | null
    hora_llegada?: Date | string | null
    consulta?: consultaUncheckedCreateNestedManyWithoutCitaInput
  }

  export type citaCreateOrConnectWithoutDoctorInput = {
    where: citaWhereUniqueInput
    create: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput>
  }

  export type citaCreateManyDoctorInputEnvelope = {
    data: citaCreateManyDoctorInput | citaCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type especialidadCreateWithoutDoctorInput = {
    nombreespecialidad?: string | null
    descripcion?: string | null
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUncheckedCreateWithoutDoctorInput = {
    id_especialidad?: number
    nombreespecialidad?: string | null
    descripcion?: string | null
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadCreateOrConnectWithoutDoctorInput = {
    where: especialidadWhereUniqueInput
    create: XOR<especialidadCreateWithoutDoctorInput, especialidadUncheckedCreateWithoutDoctorInput>
  }

  export type usuarioCreateWithoutDoctorInput = {
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutDoctorInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorUncheckedCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteUncheckedCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutDoctorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutDoctorInput, usuarioUncheckedCreateWithoutDoctorInput>
  }

  export type especialidad_doctorCreateWithoutDoctorInput = {
    especialidad?: especialidadCreateNestedOneWithoutEspecialidad_doctorInput
  }

  export type especialidad_doctorUncheckedCreateWithoutDoctorInput = {
    id_especialidad_doctor?: number
    id_especialidad?: number | null
  }

  export type especialidad_doctorCreateOrConnectWithoutDoctorInput = {
    where: especialidad_doctorWhereUniqueInput
    create: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput>
  }

  export type especialidad_doctorCreateManyDoctorInputEnvelope = {
    data: especialidad_doctorCreateManyDoctorInput | especialidad_doctorCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type citaUpsertWithWhereUniqueWithoutDoctorInput = {
    where: citaWhereUniqueInput
    update: XOR<citaUpdateWithoutDoctorInput, citaUncheckedUpdateWithoutDoctorInput>
    create: XOR<citaCreateWithoutDoctorInput, citaUncheckedCreateWithoutDoctorInput>
  }

  export type citaUpdateWithWhereUniqueWithoutDoctorInput = {
    where: citaWhereUniqueInput
    data: XOR<citaUpdateWithoutDoctorInput, citaUncheckedUpdateWithoutDoctorInput>
  }

  export type citaUpdateManyWithWhereWithoutDoctorInput = {
    where: citaScalarWhereInput
    data: XOR<citaUpdateManyMutationInput, citaUncheckedUpdateManyWithoutDoctorInput>
  }

  export type citaScalarWhereInput = {
    AND?: citaScalarWhereInput | citaScalarWhereInput[]
    OR?: citaScalarWhereInput[]
    NOT?: citaScalarWhereInput | citaScalarWhereInput[]
    id_cita?: IntFilter<"cita"> | number
    fecha?: DateTimeFilter<"cita"> | Date | string
    horainicio?: DateTimeNullableFilter<"cita"> | Date | string | null
    horafin?: DateTimeNullableFilter<"cita"> | Date | string | null
    estado?: StringNullableFilter<"cita"> | string | null
    motivo?: StringNullableFilter<"cita"> | string | null
    id_doctor?: IntNullableFilter<"cita"> | number | null
    id_paciente?: IntNullableFilter<"cita"> | number | null
    hora_llegada?: DateTimeNullableFilter<"cita"> | Date | string | null
  }

  export type especialidadUpsertWithoutDoctorInput = {
    update: XOR<especialidadUpdateWithoutDoctorInput, especialidadUncheckedUpdateWithoutDoctorInput>
    create: XOR<especialidadCreateWithoutDoctorInput, especialidadUncheckedCreateWithoutDoctorInput>
    where?: especialidadWhereInput
  }

  export type especialidadUpdateToOneWithWhereWithoutDoctorInput = {
    where?: especialidadWhereInput
    data: XOR<especialidadUpdateWithoutDoctorInput, especialidadUncheckedUpdateWithoutDoctorInput>
  }

  export type especialidadUpdateWithoutDoctorInput = {
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadUncheckedUpdateWithoutDoctorInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutEspecialidadNestedInput
  }

  export type usuarioUpsertWithoutDoctorInput = {
    update: XOR<usuarioUpdateWithoutDoctorInput, usuarioUncheckedUpdateWithoutDoctorInput>
    create: XOR<usuarioCreateWithoutDoctorInput, usuarioUncheckedCreateWithoutDoctorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutDoctorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutDoctorInput, usuarioUncheckedUpdateWithoutDoctorInput>
  }

  export type usuarioUpdateWithoutDoctorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutDoctorInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUncheckedUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUncheckedUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type especialidad_doctorUpsertWithWhereUniqueWithoutDoctorInput = {
    where: especialidad_doctorWhereUniqueInput
    update: XOR<especialidad_doctorUpdateWithoutDoctorInput, especialidad_doctorUncheckedUpdateWithoutDoctorInput>
    create: XOR<especialidad_doctorCreateWithoutDoctorInput, especialidad_doctorUncheckedCreateWithoutDoctorInput>
  }

  export type especialidad_doctorUpdateWithWhereUniqueWithoutDoctorInput = {
    where: especialidad_doctorWhereUniqueInput
    data: XOR<especialidad_doctorUpdateWithoutDoctorInput, especialidad_doctorUncheckedUpdateWithoutDoctorInput>
  }

  export type especialidad_doctorUpdateManyWithWhereWithoutDoctorInput = {
    where: especialidad_doctorScalarWhereInput
    data: XOR<especialidad_doctorUpdateManyMutationInput, especialidad_doctorUncheckedUpdateManyWithoutDoctorInput>
  }

  export type especialidad_doctorScalarWhereInput = {
    AND?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
    OR?: especialidad_doctorScalarWhereInput[]
    NOT?: especialidad_doctorScalarWhereInput | especialidad_doctorScalarWhereInput[]
    id_especialidad_doctor?: IntFilter<"especialidad_doctor"> | number
    id_doctor?: IntNullableFilter<"especialidad_doctor"> | number | null
    id_especialidad?: IntNullableFilter<"especialidad_doctor"> | number | null
  }

  export type doctorCreateWithoutEspecialidadInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutDoctorInput
    usuario?: usuarioCreateNestedOneWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutDoctorInput
  }

  export type doctorUncheckedCreateWithoutEspecialidadInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    cita?: citaUncheckedCreateNestedManyWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type doctorCreateOrConnectWithoutEspecialidadInput = {
    where: doctorWhereUniqueInput
    create: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput>
  }

  export type doctorCreateManyEspecialidadInputEnvelope = {
    data: doctorCreateManyEspecialidadInput | doctorCreateManyEspecialidadInput[]
    skipDuplicates?: boolean
  }

  export type especialidad_doctorCreateWithoutEspecialidadInput = {
    doctor?: doctorCreateNestedOneWithoutEspecialidad_doctorInput
  }

  export type especialidad_doctorUncheckedCreateWithoutEspecialidadInput = {
    id_especialidad_doctor?: number
    id_doctor?: number | null
  }

  export type especialidad_doctorCreateOrConnectWithoutEspecialidadInput = {
    where: especialidad_doctorWhereUniqueInput
    create: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput>
  }

  export type especialidad_doctorCreateManyEspecialidadInputEnvelope = {
    data: especialidad_doctorCreateManyEspecialidadInput | especialidad_doctorCreateManyEspecialidadInput[]
    skipDuplicates?: boolean
  }

  export type doctorUpsertWithWhereUniqueWithoutEspecialidadInput = {
    where: doctorWhereUniqueInput
    update: XOR<doctorUpdateWithoutEspecialidadInput, doctorUncheckedUpdateWithoutEspecialidadInput>
    create: XOR<doctorCreateWithoutEspecialidadInput, doctorUncheckedCreateWithoutEspecialidadInput>
  }

  export type doctorUpdateWithWhereUniqueWithoutEspecialidadInput = {
    where: doctorWhereUniqueInput
    data: XOR<doctorUpdateWithoutEspecialidadInput, doctorUncheckedUpdateWithoutEspecialidadInput>
  }

  export type doctorUpdateManyWithWhereWithoutEspecialidadInput = {
    where: doctorScalarWhereInput
    data: XOR<doctorUpdateManyMutationInput, doctorUncheckedUpdateManyWithoutEspecialidadInput>
  }

  export type doctorScalarWhereInput = {
    AND?: doctorScalarWhereInput | doctorScalarWhereInput[]
    OR?: doctorScalarWhereInput[]
    NOT?: doctorScalarWhereInput | doctorScalarWhereInput[]
    id_doctor?: IntFilter<"doctor"> | number
    nombre?: StringFilter<"doctor"> | string
    segundonombre?: StringNullableFilter<"doctor"> | string | null
    primerapellido?: StringFilter<"doctor"> | string
    segundoapellido?: StringNullableFilter<"doctor"> | string | null
    nacimiento?: DateTimeNullableFilter<"doctor"> | Date | string | null
    id_usuario?: IntNullableFilter<"doctor"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"doctor"> | Date | string | null
    salario?: FloatNullableFilter<"doctor"> | number | null
    telefono?: StringNullableFilter<"doctor"> | string | null
    correo?: StringNullableFilter<"doctor"> | string | null
    id_especialidad?: IntNullableFilter<"doctor"> | number | null
  }

  export type especialidad_doctorUpsertWithWhereUniqueWithoutEspecialidadInput = {
    where: especialidad_doctorWhereUniqueInput
    update: XOR<especialidad_doctorUpdateWithoutEspecialidadInput, especialidad_doctorUncheckedUpdateWithoutEspecialidadInput>
    create: XOR<especialidad_doctorCreateWithoutEspecialidadInput, especialidad_doctorUncheckedCreateWithoutEspecialidadInput>
  }

  export type especialidad_doctorUpdateWithWhereUniqueWithoutEspecialidadInput = {
    where: especialidad_doctorWhereUniqueInput
    data: XOR<especialidad_doctorUpdateWithoutEspecialidadInput, especialidad_doctorUncheckedUpdateWithoutEspecialidadInput>
  }

  export type especialidad_doctorUpdateManyWithWhereWithoutEspecialidadInput = {
    where: especialidad_doctorScalarWhereInput
    data: XOR<especialidad_doctorUpdateManyMutationInput, especialidad_doctorUncheckedUpdateManyWithoutEspecialidadInput>
  }

  export type doctorCreateWithoutEspecialidad_doctorInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutDoctorInput
    especialidad?: especialidadCreateNestedOneWithoutDoctorInput
    usuario?: usuarioCreateNestedOneWithoutDoctorInput
  }

  export type doctorUncheckedCreateWithoutEspecialidad_doctorInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
    cita?: citaUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type doctorCreateOrConnectWithoutEspecialidad_doctorInput = {
    where: doctorWhereUniqueInput
    create: XOR<doctorCreateWithoutEspecialidad_doctorInput, doctorUncheckedCreateWithoutEspecialidad_doctorInput>
  }

  export type especialidadCreateWithoutEspecialidad_doctorInput = {
    nombreespecialidad?: string | null
    descripcion?: string | null
    doctor?: doctorCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUncheckedCreateWithoutEspecialidad_doctorInput = {
    id_especialidad?: number
    nombreespecialidad?: string | null
    descripcion?: string | null
    doctor?: doctorUncheckedCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadCreateOrConnectWithoutEspecialidad_doctorInput = {
    where: especialidadWhereUniqueInput
    create: XOR<especialidadCreateWithoutEspecialidad_doctorInput, especialidadUncheckedCreateWithoutEspecialidad_doctorInput>
  }

  export type doctorUpsertWithoutEspecialidad_doctorInput = {
    update: XOR<doctorUpdateWithoutEspecialidad_doctorInput, doctorUncheckedUpdateWithoutEspecialidad_doctorInput>
    create: XOR<doctorCreateWithoutEspecialidad_doctorInput, doctorUncheckedCreateWithoutEspecialidad_doctorInput>
    where?: doctorWhereInput
  }

  export type doctorUpdateToOneWithWhereWithoutEspecialidad_doctorInput = {
    where?: doctorWhereInput
    data: XOR<doctorUpdateWithoutEspecialidad_doctorInput, doctorUncheckedUpdateWithoutEspecialidad_doctorInput>
  }

  export type doctorUpdateWithoutEspecialidad_doctorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutDoctorNestedInput
    especialidad?: especialidadUpdateOneWithoutDoctorNestedInput
    usuario?: usuarioUpdateOneWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateWithoutEspecialidad_doctorInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
    cita?: citaUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type especialidadUpsertWithoutEspecialidad_doctorInput = {
    update: XOR<especialidadUpdateWithoutEspecialidad_doctorInput, especialidadUncheckedUpdateWithoutEspecialidad_doctorInput>
    create: XOR<especialidadCreateWithoutEspecialidad_doctorInput, especialidadUncheckedCreateWithoutEspecialidad_doctorInput>
    where?: especialidadWhereInput
  }

  export type especialidadUpdateToOneWithWhereWithoutEspecialidad_doctorInput = {
    where?: especialidadWhereInput
    data: XOR<especialidadUpdateWithoutEspecialidad_doctorInput, especialidadUncheckedUpdateWithoutEspecialidad_doctorInput>
  }

  export type especialidadUpdateWithoutEspecialidad_doctorInput = {
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: doctorUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadUncheckedUpdateWithoutEspecialidad_doctorInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombreespecialidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: doctorUncheckedUpdateManyWithoutEspecialidadNestedInput
  }

  export type pacienteCreateWithoutExamenInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutPacienteInput
    usuario?: usuarioCreateNestedOneWithoutPacienteInput
    pago?: pagoCreateNestedManyWithoutPacienteInput
  }

  export type pacienteUncheckedCreateWithoutExamenInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaUncheckedCreateNestedManyWithoutPacienteInput
    pago?: pagoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type pacienteCreateOrConnectWithoutExamenInput = {
    where: pacienteWhereUniqueInput
    create: XOR<pacienteCreateWithoutExamenInput, pacienteUncheckedCreateWithoutExamenInput>
  }

  export type pacienteUpsertWithoutExamenInput = {
    update: XOR<pacienteUpdateWithoutExamenInput, pacienteUncheckedUpdateWithoutExamenInput>
    create: XOR<pacienteCreateWithoutExamenInput, pacienteUncheckedCreateWithoutExamenInput>
    where?: pacienteWhereInput
  }

  export type pacienteUpdateToOneWithWhereWithoutExamenInput = {
    where?: pacienteWhereInput
    data: XOR<pacienteUpdateWithoutExamenInput, pacienteUncheckedUpdateWithoutExamenInput>
  }

  export type pacienteUpdateWithoutExamenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutPacienteNestedInput
    usuario?: usuarioUpdateOneWithoutPacienteNestedInput
    pago?: pagoUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateWithoutExamenInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUncheckedUpdateManyWithoutPacienteNestedInput
    pago?: pagoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type proveedorCreateWithoutMedicamentoInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
    usuario?: usuarioCreateNestedOneWithoutProveedorInput
  }

  export type proveedorUncheckedCreateWithoutMedicamentoInput = {
    id_proveedor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    id_usuario?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
  }

  export type proveedorCreateOrConnectWithoutMedicamentoInput = {
    where: proveedorWhereUniqueInput
    create: XOR<proveedorCreateWithoutMedicamentoInput, proveedorUncheckedCreateWithoutMedicamentoInput>
  }

  export type proveedorUpsertWithoutMedicamentoInput = {
    update: XOR<proveedorUpdateWithoutMedicamentoInput, proveedorUncheckedUpdateWithoutMedicamentoInput>
    create: XOR<proveedorCreateWithoutMedicamentoInput, proveedorUncheckedCreateWithoutMedicamentoInput>
    where?: proveedorWhereInput
  }

  export type proveedorUpdateToOneWithWhereWithoutMedicamentoInput = {
    where?: proveedorWhereInput
    data: XOR<proveedorUpdateWithoutMedicamentoInput, proveedorUncheckedUpdateWithoutMedicamentoInput>
  }

  export type proveedorUpdateWithoutMedicamentoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usuario?: usuarioUpdateOneWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateWithoutMedicamentoInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type citaCreateWithoutPacienteInput = {
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    hora_llegada?: Date | string | null
    doctor?: doctorCreateNestedOneWithoutCitaInput
    consulta?: consultaCreateNestedManyWithoutCitaInput
  }

  export type citaUncheckedCreateWithoutPacienteInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_doctor?: number | null
    hora_llegada?: Date | string | null
    consulta?: consultaUncheckedCreateNestedManyWithoutCitaInput
  }

  export type citaCreateOrConnectWithoutPacienteInput = {
    where: citaWhereUniqueInput
    create: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput>
  }

  export type citaCreateManyPacienteInputEnvelope = {
    data: citaCreateManyPacienteInput | citaCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type examenCreateWithoutPacienteInput = {
    tipoexamen?: string | null
    rutaExamen?: string | null
  }

  export type examenUncheckedCreateWithoutPacienteInput = {
    id_examen?: number
    tipoexamen?: string | null
    rutaExamen?: string | null
  }

  export type examenCreateOrConnectWithoutPacienteInput = {
    where: examenWhereUniqueInput
    create: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput>
  }

  export type examenCreateManyPacienteInputEnvelope = {
    data: examenCreateManyPacienteInput | examenCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutPacienteInput = {
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorCreateNestedManyWithoutUsuarioInput
    doctor?: doctorCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPacienteInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorUncheckedCreateNestedManyWithoutUsuarioInput
    doctor?: doctorUncheckedCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPacienteInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPacienteInput, usuarioUncheckedCreateWithoutPacienteInput>
  }

  export type pagoCreateWithoutPacienteInput = {
    tipopago: string
    monto: number
    fechapago?: Date | string | null
  }

  export type pagoUncheckedCreateWithoutPacienteInput = {
    id_pago?: number
    tipopago: string
    monto: number
    fechapago?: Date | string | null
  }

  export type pagoCreateOrConnectWithoutPacienteInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput>
  }

  export type pagoCreateManyPacienteInputEnvelope = {
    data: pagoCreateManyPacienteInput | pagoCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type citaUpsertWithWhereUniqueWithoutPacienteInput = {
    where: citaWhereUniqueInput
    update: XOR<citaUpdateWithoutPacienteInput, citaUncheckedUpdateWithoutPacienteInput>
    create: XOR<citaCreateWithoutPacienteInput, citaUncheckedCreateWithoutPacienteInput>
  }

  export type citaUpdateWithWhereUniqueWithoutPacienteInput = {
    where: citaWhereUniqueInput
    data: XOR<citaUpdateWithoutPacienteInput, citaUncheckedUpdateWithoutPacienteInput>
  }

  export type citaUpdateManyWithWhereWithoutPacienteInput = {
    where: citaScalarWhereInput
    data: XOR<citaUpdateManyMutationInput, citaUncheckedUpdateManyWithoutPacienteInput>
  }

  export type examenUpsertWithWhereUniqueWithoutPacienteInput = {
    where: examenWhereUniqueInput
    update: XOR<examenUpdateWithoutPacienteInput, examenUncheckedUpdateWithoutPacienteInput>
    create: XOR<examenCreateWithoutPacienteInput, examenUncheckedCreateWithoutPacienteInput>
  }

  export type examenUpdateWithWhereUniqueWithoutPacienteInput = {
    where: examenWhereUniqueInput
    data: XOR<examenUpdateWithoutPacienteInput, examenUncheckedUpdateWithoutPacienteInput>
  }

  export type examenUpdateManyWithWhereWithoutPacienteInput = {
    where: examenScalarWhereInput
    data: XOR<examenUpdateManyMutationInput, examenUncheckedUpdateManyWithoutPacienteInput>
  }

  export type examenScalarWhereInput = {
    AND?: examenScalarWhereInput | examenScalarWhereInput[]
    OR?: examenScalarWhereInput[]
    NOT?: examenScalarWhereInput | examenScalarWhereInput[]
    id_examen?: IntFilter<"examen"> | number
    tipoexamen?: StringNullableFilter<"examen"> | string | null
    rutaExamen?: StringNullableFilter<"examen"> | string | null
    id_paciente?: IntNullableFilter<"examen"> | number | null
  }

  export type usuarioUpsertWithoutPacienteInput = {
    update: XOR<usuarioUpdateWithoutPacienteInput, usuarioUncheckedUpdateWithoutPacienteInput>
    create: XOR<usuarioCreateWithoutPacienteInput, usuarioUncheckedCreateWithoutPacienteInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutPacienteInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutPacienteInput, usuarioUncheckedUpdateWithoutPacienteInput>
  }

  export type usuarioUpdateWithoutPacienteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPacienteInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUncheckedUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUncheckedUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type pagoUpsertWithWhereUniqueWithoutPacienteInput = {
    where: pagoWhereUniqueInput
    update: XOR<pagoUpdateWithoutPacienteInput, pagoUncheckedUpdateWithoutPacienteInput>
    create: XOR<pagoCreateWithoutPacienteInput, pagoUncheckedCreateWithoutPacienteInput>
  }

  export type pagoUpdateWithWhereUniqueWithoutPacienteInput = {
    where: pagoWhereUniqueInput
    data: XOR<pagoUpdateWithoutPacienteInput, pagoUncheckedUpdateWithoutPacienteInput>
  }

  export type pagoUpdateManyWithWhereWithoutPacienteInput = {
    where: pagoScalarWhereInput
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyWithoutPacienteInput>
  }

  export type pagoScalarWhereInput = {
    AND?: pagoScalarWhereInput | pagoScalarWhereInput[]
    OR?: pagoScalarWhereInput[]
    NOT?: pagoScalarWhereInput | pagoScalarWhereInput[]
    id_pago?: IntFilter<"pago"> | number
    id_paciente?: IntFilter<"pago"> | number
    tipopago?: StringFilter<"pago"> | string
    monto?: FloatFilter<"pago"> | number
    fechapago?: DateTimeNullableFilter<"pago"> | Date | string | null
  }

  export type pacienteCreateWithoutPagoInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutPacienteInput
    examen?: examenCreateNestedManyWithoutPacienteInput
    usuario?: usuarioCreateNestedOneWithoutPacienteInput
  }

  export type pacienteUncheckedCreateWithoutPagoInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaUncheckedCreateNestedManyWithoutPacienteInput
    examen?: examenUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type pacienteCreateOrConnectWithoutPagoInput = {
    where: pacienteWhereUniqueInput
    create: XOR<pacienteCreateWithoutPagoInput, pacienteUncheckedCreateWithoutPagoInput>
  }

  export type pacienteUpsertWithoutPagoInput = {
    update: XOR<pacienteUpdateWithoutPagoInput, pacienteUncheckedUpdateWithoutPagoInput>
    create: XOR<pacienteCreateWithoutPagoInput, pacienteUncheckedCreateWithoutPagoInput>
    where?: pacienteWhereInput
  }

  export type pacienteUpdateToOneWithWhereWithoutPagoInput = {
    where?: pacienteWhereInput
    data: XOR<pacienteUpdateWithoutPagoInput, pacienteUncheckedUpdateWithoutPagoInput>
  }

  export type pacienteUpdateWithoutPagoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutPacienteNestedInput
    examen?: examenUpdateManyWithoutPacienteNestedInput
    usuario?: usuarioUpdateOneWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateWithoutPagoInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUncheckedUpdateManyWithoutPacienteNestedInput
    examen?: examenUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type recetaCreateWithoutPrescripcionInput = {
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    tratamiento?: tratamientoCreateNestedOneWithoutRecetaInput
  }

  export type recetaUncheckedCreateWithoutPrescripcionInput = {
    id_receta?: number
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    id_tratamiento?: number | null
  }

  export type recetaCreateOrConnectWithoutPrescripcionInput = {
    where: recetaWhereUniqueInput
    create: XOR<recetaCreateWithoutPrescripcionInput, recetaUncheckedCreateWithoutPrescripcionInput>
  }

  export type recetaUpsertWithoutPrescripcionInput = {
    update: XOR<recetaUpdateWithoutPrescripcionInput, recetaUncheckedUpdateWithoutPrescripcionInput>
    create: XOR<recetaCreateWithoutPrescripcionInput, recetaUncheckedCreateWithoutPrescripcionInput>
    where?: recetaWhereInput
  }

  export type recetaUpdateToOneWithWhereWithoutPrescripcionInput = {
    where?: recetaWhereInput
    data: XOR<recetaUpdateWithoutPrescripcionInput, recetaUncheckedUpdateWithoutPrescripcionInput>
  }

  export type recetaUpdateWithoutPrescripcionInput = {
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tratamiento?: tratamientoUpdateOneWithoutRecetaNestedInput
  }

  export type recetaUncheckedUpdateWithoutPrescripcionInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    id_tratamiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type medicamentoCreateWithoutProveedorInput = {
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type medicamentoUncheckedCreateWithoutProveedorInput = {
    id_medicamento?: number
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type medicamentoCreateOrConnectWithoutProveedorInput = {
    where: medicamentoWhereUniqueInput
    create: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput>
  }

  export type medicamentoCreateManyProveedorInputEnvelope = {
    data: medicamentoCreateManyProveedorInput | medicamentoCreateManyProveedorInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutProveedorInput = {
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorCreateNestedManyWithoutUsuarioInput
    doctor?: doctorCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutProveedorInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorUncheckedCreateNestedManyWithoutUsuarioInput
    doctor?: doctorUncheckedCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteUncheckedCreateNestedManyWithoutUsuarioInput
    secretaria?: secretariaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutProveedorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutProveedorInput, usuarioUncheckedCreateWithoutProveedorInput>
  }

  export type medicamentoUpsertWithWhereUniqueWithoutProveedorInput = {
    where: medicamentoWhereUniqueInput
    update: XOR<medicamentoUpdateWithoutProveedorInput, medicamentoUncheckedUpdateWithoutProveedorInput>
    create: XOR<medicamentoCreateWithoutProveedorInput, medicamentoUncheckedCreateWithoutProveedorInput>
  }

  export type medicamentoUpdateWithWhereUniqueWithoutProveedorInput = {
    where: medicamentoWhereUniqueInput
    data: XOR<medicamentoUpdateWithoutProveedorInput, medicamentoUncheckedUpdateWithoutProveedorInput>
  }

  export type medicamentoUpdateManyWithWhereWithoutProveedorInput = {
    where: medicamentoScalarWhereInput
    data: XOR<medicamentoUpdateManyMutationInput, medicamentoUncheckedUpdateManyWithoutProveedorInput>
  }

  export type medicamentoScalarWhereInput = {
    AND?: medicamentoScalarWhereInput | medicamentoScalarWhereInput[]
    OR?: medicamentoScalarWhereInput[]
    NOT?: medicamentoScalarWhereInput | medicamentoScalarWhereInput[]
    id_medicamento?: IntFilter<"medicamento"> | number
    nombre?: StringNullableFilter<"medicamento"> | string | null
    tipo?: StringNullableFilter<"medicamento"> | string | null
    descripcion?: StringNullableFilter<"medicamento"> | string | null
    id_proveedor?: IntNullableFilter<"medicamento"> | number | null
  }

  export type usuarioUpsertWithoutProveedorInput = {
    update: XOR<usuarioUpdateWithoutProveedorInput, usuarioUncheckedUpdateWithoutProveedorInput>
    create: XOR<usuarioCreateWithoutProveedorInput, usuarioUncheckedCreateWithoutProveedorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutProveedorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutProveedorInput, usuarioUncheckedUpdateWithoutProveedorInput>
  }

  export type usuarioUpdateWithoutProveedorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutProveedorInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUncheckedUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUncheckedUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUncheckedUpdateManyWithoutUsuarioNestedInput
    secretaria?: secretariaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type prescripcionCreateWithoutRecetaInput = {
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
  }

  export type prescripcionUncheckedCreateWithoutRecetaInput = {
    id_prescripcion?: number
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
  }

  export type prescripcionCreateOrConnectWithoutRecetaInput = {
    where: prescripcionWhereUniqueInput
    create: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput>
  }

  export type prescripcionCreateManyRecetaInputEnvelope = {
    data: prescripcionCreateManyRecetaInput | prescripcionCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type tratamientoCreateWithoutRecetaInput = {
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    diagnostico?: diagnosticoCreateNestedOneWithoutTratamientoInput
  }

  export type tratamientoUncheckedCreateWithoutRecetaInput = {
    id_tratamiento?: number
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
    id_diagnostico?: number | null
  }

  export type tratamientoCreateOrConnectWithoutRecetaInput = {
    where: tratamientoWhereUniqueInput
    create: XOR<tratamientoCreateWithoutRecetaInput, tratamientoUncheckedCreateWithoutRecetaInput>
  }

  export type prescripcionUpsertWithWhereUniqueWithoutRecetaInput = {
    where: prescripcionWhereUniqueInput
    update: XOR<prescripcionUpdateWithoutRecetaInput, prescripcionUncheckedUpdateWithoutRecetaInput>
    create: XOR<prescripcionCreateWithoutRecetaInput, prescripcionUncheckedCreateWithoutRecetaInput>
  }

  export type prescripcionUpdateWithWhereUniqueWithoutRecetaInput = {
    where: prescripcionWhereUniqueInput
    data: XOR<prescripcionUpdateWithoutRecetaInput, prescripcionUncheckedUpdateWithoutRecetaInput>
  }

  export type prescripcionUpdateManyWithWhereWithoutRecetaInput = {
    where: prescripcionScalarWhereInput
    data: XOR<prescripcionUpdateManyMutationInput, prescripcionUncheckedUpdateManyWithoutRecetaInput>
  }

  export type prescripcionScalarWhereInput = {
    AND?: prescripcionScalarWhereInput | prescripcionScalarWhereInput[]
    OR?: prescripcionScalarWhereInput[]
    NOT?: prescripcionScalarWhereInput | prescripcionScalarWhereInput[]
    id_prescripcion?: IntFilter<"prescripcion"> | number
    dosisrecomendada?: StringNullableFilter<"prescripcion"> | string | null
    tipo?: StringNullableFilter<"prescripcion"> | string | null
    frecuencia?: StringNullableFilter<"prescripcion"> | string | null
    id_medicamento?: IntNullableFilter<"prescripcion"> | number | null
    id_receta?: IntNullableFilter<"prescripcion"> | number | null
  }

  export type tratamientoUpsertWithoutRecetaInput = {
    update: XOR<tratamientoUpdateWithoutRecetaInput, tratamientoUncheckedUpdateWithoutRecetaInput>
    create: XOR<tratamientoCreateWithoutRecetaInput, tratamientoUncheckedCreateWithoutRecetaInput>
    where?: tratamientoWhereInput
  }

  export type tratamientoUpdateToOneWithWhereWithoutRecetaInput = {
    where?: tratamientoWhereInput
    data: XOR<tratamientoUpdateWithoutRecetaInput, tratamientoUncheckedUpdateWithoutRecetaInput>
  }

  export type tratamientoUpdateWithoutRecetaInput = {
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUpdateOneWithoutTratamientoNestedInput
  }

  export type tratamientoUncheckedUpdateWithoutRecetaInput = {
    id_tratamiento?: IntFieldUpdateOperationsInput | number
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_diagnostico?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuarioCreateWithoutSecretariaInput = {
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorCreateNestedManyWithoutUsuarioInput
    doctor?: doctorCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutSecretariaInput = {
    id_usuario?: number
    nombre: string
    contrasena: string
    rol: string
    administrador?: administradorUncheckedCreateNestedManyWithoutUsuarioInput
    doctor?: doctorUncheckedCreateNestedManyWithoutUsuarioInput
    paciente?: pacienteUncheckedCreateNestedManyWithoutUsuarioInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutSecretariaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutSecretariaInput, usuarioUncheckedCreateWithoutSecretariaInput>
  }

  export type usuarioUpsertWithoutSecretariaInput = {
    update: XOR<usuarioUpdateWithoutSecretariaInput, usuarioUncheckedUpdateWithoutSecretariaInput>
    create: XOR<usuarioCreateWithoutSecretariaInput, usuarioUncheckedCreateWithoutSecretariaInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutSecretariaInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutSecretariaInput, usuarioUncheckedUpdateWithoutSecretariaInput>
  }

  export type usuarioUpdateWithoutSecretariaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutSecretariaInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    administrador?: administradorUncheckedUpdateManyWithoutUsuarioNestedInput
    doctor?: doctorUncheckedUpdateManyWithoutUsuarioNestedInput
    paciente?: pacienteUncheckedUpdateManyWithoutUsuarioNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type recetaCreateWithoutTratamientoInput = {
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    prescripcion?: prescripcionCreateNestedManyWithoutRecetaInput
  }

  export type recetaUncheckedCreateWithoutTratamientoInput = {
    id_receta?: number
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
    prescripcion?: prescripcionUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type recetaCreateOrConnectWithoutTratamientoInput = {
    where: recetaWhereUniqueInput
    create: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput>
  }

  export type recetaCreateManyTratamientoInputEnvelope = {
    data: recetaCreateManyTratamientoInput | recetaCreateManyTratamientoInput[]
    skipDuplicates?: boolean
  }

  export type diagnosticoCreateWithoutTratamientoInput = {
    nombrediagnostico?: string | null
    descripcion?: string | null
    consulta?: consultaCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutTratamientoInput = {
    id_diagnostico?: number
    nombrediagnostico?: string | null
    descripcion?: string | null
    id_consulta?: number | null
  }

  export type diagnosticoCreateOrConnectWithoutTratamientoInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutTratamientoInput, diagnosticoUncheckedCreateWithoutTratamientoInput>
  }

  export type recetaUpsertWithWhereUniqueWithoutTratamientoInput = {
    where: recetaWhereUniqueInput
    update: XOR<recetaUpdateWithoutTratamientoInput, recetaUncheckedUpdateWithoutTratamientoInput>
    create: XOR<recetaCreateWithoutTratamientoInput, recetaUncheckedCreateWithoutTratamientoInput>
  }

  export type recetaUpdateWithWhereUniqueWithoutTratamientoInput = {
    where: recetaWhereUniqueInput
    data: XOR<recetaUpdateWithoutTratamientoInput, recetaUncheckedUpdateWithoutTratamientoInput>
  }

  export type recetaUpdateManyWithWhereWithoutTratamientoInput = {
    where: recetaScalarWhereInput
    data: XOR<recetaUpdateManyMutationInput, recetaUncheckedUpdateManyWithoutTratamientoInput>
  }

  export type recetaScalarWhereInput = {
    AND?: recetaScalarWhereInput | recetaScalarWhereInput[]
    OR?: recetaScalarWhereInput[]
    NOT?: recetaScalarWhereInput | recetaScalarWhereInput[]
    id_receta?: IntFilter<"receta"> | number
    fechaemision?: DateTimeNullableFilter<"receta"> | Date | string | null
    dosisrecomendada?: StringNullableFilter<"receta"> | string | null
    id_tratamiento?: IntNullableFilter<"receta"> | number | null
  }

  export type diagnosticoUpsertWithoutTratamientoInput = {
    update: XOR<diagnosticoUpdateWithoutTratamientoInput, diagnosticoUncheckedUpdateWithoutTratamientoInput>
    create: XOR<diagnosticoCreateWithoutTratamientoInput, diagnosticoUncheckedCreateWithoutTratamientoInput>
    where?: diagnosticoWhereInput
  }

  export type diagnosticoUpdateToOneWithWhereWithoutTratamientoInput = {
    where?: diagnosticoWhereInput
    data: XOR<diagnosticoUpdateWithoutTratamientoInput, diagnosticoUncheckedUpdateWithoutTratamientoInput>
  }

  export type diagnosticoUpdateWithoutTratamientoInput = {
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    consulta?: consultaUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutTratamientoInput = {
    id_diagnostico?: IntFieldUpdateOperationsInput | number
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    id_consulta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type administradorCreateWithoutUsuarioInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    fechaingreso?: Date | string | null
  }

  export type administradorUncheckedCreateWithoutUsuarioInput = {
    id_admin?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    fechaingreso?: Date | string | null
  }

  export type administradorCreateOrConnectWithoutUsuarioInput = {
    where: administradorWhereUniqueInput
    create: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
  }

  export type administradorCreateManyUsuarioInputEnvelope = {
    data: administradorCreateManyUsuarioInput | administradorCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type doctorCreateWithoutUsuarioInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutDoctorInput
    especialidad?: especialidadCreateNestedOneWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorCreateNestedManyWithoutDoctorInput
  }

  export type doctorUncheckedCreateWithoutUsuarioInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
    cita?: citaUncheckedCreateNestedManyWithoutDoctorInput
    especialidad_doctor?: especialidad_doctorUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type doctorCreateOrConnectWithoutUsuarioInput = {
    where: doctorWhereUniqueInput
    create: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput>
  }

  export type doctorCreateManyUsuarioInputEnvelope = {
    data: doctorCreateManyUsuarioInput | doctorCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type pacienteCreateWithoutUsuarioInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaCreateNestedManyWithoutPacienteInput
    examen?: examenCreateNestedManyWithoutPacienteInput
    pago?: pagoCreateNestedManyWithoutPacienteInput
  }

  export type pacienteUncheckedCreateWithoutUsuarioInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
    cita?: citaUncheckedCreateNestedManyWithoutPacienteInput
    examen?: examenUncheckedCreateNestedManyWithoutPacienteInput
    pago?: pagoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type pacienteCreateOrConnectWithoutUsuarioInput = {
    where: pacienteWhereUniqueInput
    create: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput>
  }

  export type pacienteCreateManyUsuarioInputEnvelope = {
    data: pacienteCreateManyUsuarioInput | pacienteCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type proveedorCreateWithoutUsuarioInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
    medicamento?: medicamentoCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUncheckedCreateWithoutUsuarioInput = {
    id_proveedor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
    medicamento?: medicamentoUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type proveedorCreateOrConnectWithoutUsuarioInput = {
    where: proveedorWhereUniqueInput
    create: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput>
  }

  export type proveedorCreateManyUsuarioInputEnvelope = {
    data: proveedorCreateManyUsuarioInput | proveedorCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type secretariaCreateWithoutUsuarioInput = {
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
  }

  export type secretariaUncheckedCreateWithoutUsuarioInput = {
    id_secretaria?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
  }

  export type secretariaCreateOrConnectWithoutUsuarioInput = {
    where: secretariaWhereUniqueInput
    create: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput>
  }

  export type secretariaCreateManyUsuarioInputEnvelope = {
    data: secretariaCreateManyUsuarioInput | secretariaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type administradorUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: administradorWhereUniqueInput
    update: XOR<administradorUpdateWithoutUsuarioInput, administradorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
  }

  export type administradorUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: administradorWhereUniqueInput
    data: XOR<administradorUpdateWithoutUsuarioInput, administradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type administradorUpdateManyWithWhereWithoutUsuarioInput = {
    where: administradorScalarWhereInput
    data: XOR<administradorUpdateManyMutationInput, administradorUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type administradorScalarWhereInput = {
    AND?: administradorScalarWhereInput | administradorScalarWhereInput[]
    OR?: administradorScalarWhereInput[]
    NOT?: administradorScalarWhereInput | administradorScalarWhereInput[]
    id_admin?: IntFilter<"administrador"> | number
    nombre?: StringFilter<"administrador"> | string
    segundonombre?: StringNullableFilter<"administrador"> | string | null
    primerapellido?: StringFilter<"administrador"> | string
    segundoapellido?: StringNullableFilter<"administrador"> | string | null
    nacimiento?: DateTimeNullableFilter<"administrador"> | Date | string | null
    celular?: StringNullableFilter<"administrador"> | string | null
    telefono?: StringNullableFilter<"administrador"> | string | null
    id_usuario?: IntNullableFilter<"administrador"> | number | null
    fechaingreso?: DateTimeNullableFilter<"administrador"> | Date | string | null
  }

  export type doctorUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: doctorWhereUniqueInput
    update: XOR<doctorUpdateWithoutUsuarioInput, doctorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<doctorCreateWithoutUsuarioInput, doctorUncheckedCreateWithoutUsuarioInput>
  }

  export type doctorUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: doctorWhereUniqueInput
    data: XOR<doctorUpdateWithoutUsuarioInput, doctorUncheckedUpdateWithoutUsuarioInput>
  }

  export type doctorUpdateManyWithWhereWithoutUsuarioInput = {
    where: doctorScalarWhereInput
    data: XOR<doctorUpdateManyMutationInput, doctorUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type pacienteUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: pacienteWhereUniqueInput
    update: XOR<pacienteUpdateWithoutUsuarioInput, pacienteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<pacienteCreateWithoutUsuarioInput, pacienteUncheckedCreateWithoutUsuarioInput>
  }

  export type pacienteUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: pacienteWhereUniqueInput
    data: XOR<pacienteUpdateWithoutUsuarioInput, pacienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type pacienteUpdateManyWithWhereWithoutUsuarioInput = {
    where: pacienteScalarWhereInput
    data: XOR<pacienteUpdateManyMutationInput, pacienteUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type pacienteScalarWhereInput = {
    AND?: pacienteScalarWhereInput | pacienteScalarWhereInput[]
    OR?: pacienteScalarWhereInput[]
    NOT?: pacienteScalarWhereInput | pacienteScalarWhereInput[]
    id_paciente?: IntFilter<"paciente"> | number
    nombre?: StringFilter<"paciente"> | string
    segundonombre?: StringNullableFilter<"paciente"> | string | null
    primerapellido?: StringFilter<"paciente"> | string
    segundoapellido?: StringNullableFilter<"paciente"> | string | null
    nacimiento?: DateTimeNullableFilter<"paciente"> | Date | string | null
    id_usuario?: IntNullableFilter<"paciente"> | number | null
    altura?: FloatNullableFilter<"paciente"> | number | null
    peso?: FloatNullableFilter<"paciente"> | number | null
    sexo?: StringNullableFilter<"paciente"> | string | null
    tiposangre?: StringNullableFilter<"paciente"> | string | null
    telefono?: StringNullableFilter<"paciente"> | string | null
    correo?: StringNullableFilter<"paciente"> | string | null
  }

  export type proveedorUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: proveedorWhereUniqueInput
    update: XOR<proveedorUpdateWithoutUsuarioInput, proveedorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<proveedorCreateWithoutUsuarioInput, proveedorUncheckedCreateWithoutUsuarioInput>
  }

  export type proveedorUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: proveedorWhereUniqueInput
    data: XOR<proveedorUpdateWithoutUsuarioInput, proveedorUncheckedUpdateWithoutUsuarioInput>
  }

  export type proveedorUpdateManyWithWhereWithoutUsuarioInput = {
    where: proveedorScalarWhereInput
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type proveedorScalarWhereInput = {
    AND?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
    OR?: proveedorScalarWhereInput[]
    NOT?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
    id_proveedor?: IntFilter<"proveedor"> | number
    nombre?: StringFilter<"proveedor"> | string
    segundonombre?: StringNullableFilter<"proveedor"> | string | null
    primerapellido?: StringNullableFilter<"proveedor"> | string | null
    segundoapellido?: StringNullableFilter<"proveedor"> | string | null
    nacimiento?: DateTimeNullableFilter<"proveedor"> | Date | string | null
    celular?: StringNullableFilter<"proveedor"> | string | null
    telefono?: StringNullableFilter<"proveedor"> | string | null
    id_direccion?: IntNullableFilter<"proveedor"> | number | null
    id_usuario?: IntNullableFilter<"proveedor"> | number | null
    tipoproveedor?: StringNullableFilter<"proveedor"> | string | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
  }

  export type secretariaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: secretariaWhereUniqueInput
    update: XOR<secretariaUpdateWithoutUsuarioInput, secretariaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<secretariaCreateWithoutUsuarioInput, secretariaUncheckedCreateWithoutUsuarioInput>
  }

  export type secretariaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: secretariaWhereUniqueInput
    data: XOR<secretariaUpdateWithoutUsuarioInput, secretariaUncheckedUpdateWithoutUsuarioInput>
  }

  export type secretariaUpdateManyWithWhereWithoutUsuarioInput = {
    where: secretariaScalarWhereInput
    data: XOR<secretariaUpdateManyMutationInput, secretariaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type secretariaScalarWhereInput = {
    AND?: secretariaScalarWhereInput | secretariaScalarWhereInput[]
    OR?: secretariaScalarWhereInput[]
    NOT?: secretariaScalarWhereInput | secretariaScalarWhereInput[]
    id_secretaria?: IntFilter<"secretaria"> | number
    nombre?: StringFilter<"secretaria"> | string
    segundonombre?: StringNullableFilter<"secretaria"> | string | null
    primerapellido?: StringFilter<"secretaria"> | string
    segundoapellido?: StringNullableFilter<"secretaria"> | string | null
    nacimiento?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    telefono?: StringNullableFilter<"secretaria"> | string | null
    id_usuario?: IntNullableFilter<"secretaria"> | number | null
    fechacontratacion?: DateTimeNullableFilter<"secretaria"> | Date | string | null
    salario?: FloatNullableFilter<"secretaria"> | number | null
    correo?: StringNullableFilter<"secretaria"> | string | null
  }

  export type consultaCreateManyCitaInput = {
    id_consulta?: number
    fecha?: Date | string | null
    motivo?: string | null
  }

  export type consultaUpdateWithoutCitaInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUpdateManyWithoutConsultaNestedInput
  }

  export type consultaUncheckedUpdateWithoutCitaInput = {
    id_consulta?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutConsultaNestedInput
  }

  export type consultaUncheckedUpdateManyWithoutCitaInput = {
    id_consulta?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosticoCreateManyConsultaInput = {
    id_diagnostico?: number
    nombrediagnostico?: string | null
    descripcion?: string | null
  }

  export type diagnosticoUpdateWithoutConsultaInput = {
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tratamiento?: tratamientoUpdateManyWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutConsultaInput = {
    id_diagnostico?: IntFieldUpdateOperationsInput | number
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tratamiento?: tratamientoUncheckedUpdateManyWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateManyWithoutConsultaInput = {
    id_diagnostico?: IntFieldUpdateOperationsInput | number
    nombrediagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tratamientoCreateManyDiagnosticoInput = {
    id_tratamiento?: number
    tipotratamiento?: string | null
    descripcion?: string | null
    duracion?: string | null
    frecuencia?: string | null
  }

  export type tratamientoUpdateWithoutDiagnosticoInput = {
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    receta?: recetaUpdateManyWithoutTratamientoNestedInput
  }

  export type tratamientoUncheckedUpdateWithoutDiagnosticoInput = {
    id_tratamiento?: IntFieldUpdateOperationsInput | number
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    receta?: recetaUncheckedUpdateManyWithoutTratamientoNestedInput
  }

  export type tratamientoUncheckedUpdateManyWithoutDiagnosticoInput = {
    id_tratamiento?: IntFieldUpdateOperationsInput | number
    tipotratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type citaCreateManyDoctorInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_paciente?: number | null
    hora_llegada?: Date | string | null
  }

  export type especialidad_doctorCreateManyDoctorInput = {
    id_especialidad_doctor?: number
    id_especialidad?: number | null
  }

  export type citaUpdateWithoutDoctorInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paciente?: pacienteUpdateOneWithoutCitaNestedInput
    consulta?: consultaUpdateManyWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateWithoutDoctorInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consulta?: consultaUncheckedUpdateManyWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateManyWithoutDoctorInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_paciente?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type especialidad_doctorUpdateWithoutDoctorInput = {
    especialidad?: especialidadUpdateOneWithoutEspecialidad_doctorNestedInput
  }

  export type especialidad_doctorUncheckedUpdateWithoutDoctorInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidad_doctorUncheckedUpdateManyWithoutDoctorInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctorCreateManyEspecialidadInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    id_usuario?: number | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
  }

  export type especialidad_doctorCreateManyEspecialidadInput = {
    id_especialidad_doctor?: number
    id_doctor?: number | null
  }

  export type doctorUpdateWithoutEspecialidadInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutDoctorNestedInput
    usuario?: usuarioUpdateOneWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateWithoutEspecialidadInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUncheckedUpdateManyWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateManyWithoutEspecialidadInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type especialidad_doctorUpdateWithoutEspecialidadInput = {
    doctor?: doctorUpdateOneWithoutEspecialidad_doctorNestedInput
  }

  export type especialidad_doctorUncheckedUpdateWithoutEspecialidadInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidad_doctorUncheckedUpdateManyWithoutEspecialidadInput = {
    id_especialidad_doctor?: IntFieldUpdateOperationsInput | number
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type citaCreateManyPacienteInput = {
    id_cita?: number
    fecha: Date | string
    horainicio?: Date | string | null
    horafin?: Date | string | null
    estado?: string | null
    motivo?: string | null
    id_doctor?: number | null
    hora_llegada?: Date | string | null
  }

  export type examenCreateManyPacienteInput = {
    id_examen?: number
    tipoexamen?: string | null
    rutaExamen?: string | null
  }

  export type pagoCreateManyPacienteInput = {
    id_pago?: number
    tipopago: string
    monto: number
    fechapago?: Date | string | null
  }

  export type citaUpdateWithoutPacienteInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: doctorUpdateOneWithoutCitaNestedInput
    consulta?: consultaUpdateManyWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateWithoutPacienteInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consulta?: consultaUncheckedUpdateManyWithoutCitaNestedInput
  }

  export type citaUncheckedUpdateManyWithoutPacienteInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    id_doctor?: NullableIntFieldUpdateOperationsInput | number | null
    hora_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examenUpdateWithoutPacienteInput = {
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type examenUncheckedUpdateWithoutPacienteInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type examenUncheckedUpdateManyWithoutPacienteInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    tipoexamen?: NullableStringFieldUpdateOperationsInput | string | null
    rutaExamen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagoUpdateWithoutPacienteInput = {
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pagoUncheckedUpdateWithoutPacienteInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pagoUncheckedUpdateManyWithoutPacienteInput = {
    id_pago?: IntFieldUpdateOperationsInput | number
    tipopago?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechapago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicamentoCreateManyProveedorInput = {
    id_medicamento?: number
    nombre?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type medicamentoUpdateWithoutProveedorInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicamentoUncheckedUpdateWithoutProveedorInput = {
    id_medicamento?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicamentoUncheckedUpdateManyWithoutProveedorInput = {
    id_medicamento?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prescripcionCreateManyRecetaInput = {
    id_prescripcion?: number
    dosisrecomendada?: string | null
    tipo?: string | null
    frecuencia?: string | null
    id_medicamento?: number | null
  }

  export type prescripcionUpdateWithoutRecetaInput = {
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescripcionUncheckedUpdateWithoutRecetaInput = {
    id_prescripcion?: IntFieldUpdateOperationsInput | number
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescripcionUncheckedUpdateManyWithoutRecetaInput = {
    id_prescripcion?: IntFieldUpdateOperationsInput | number
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    frecuencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_medicamento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type recetaCreateManyTratamientoInput = {
    id_receta?: number
    fechaemision?: Date | string | null
    dosisrecomendada?: string | null
  }

  export type recetaUpdateWithoutTratamientoInput = {
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    prescripcion?: prescripcionUpdateManyWithoutRecetaNestedInput
  }

  export type recetaUncheckedUpdateWithoutTratamientoInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
    prescripcion?: prescripcionUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type recetaUncheckedUpdateManyWithoutTratamientoInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    fechaemision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dosisrecomendada?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type administradorCreateManyUsuarioInput = {
    id_admin?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    fechaingreso?: Date | string | null
  }

  export type doctorCreateManyUsuarioInput = {
    id_doctor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    telefono?: string | null
    correo?: string | null
    id_especialidad?: number | null
  }

  export type pacienteCreateManyUsuarioInput = {
    id_paciente?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    altura?: number | null
    peso?: number | null
    sexo?: string | null
    tiposangre?: string | null
    telefono?: string | null
    correo?: string | null
  }

  export type proveedorCreateManyUsuarioInput = {
    id_proveedor?: number
    nombre: string
    segundonombre?: string | null
    primerapellido?: string | null
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    celular?: string | null
    telefono?: string | null
    id_direccion?: number | null
    tipoproveedor?: string | null
    estado?: boolean | null
  }

  export type secretariaCreateManyUsuarioInput = {
    id_secretaria?: number
    nombre: string
    segundonombre?: string | null
    primerapellido: string
    segundoapellido?: string | null
    nacimiento?: Date | string | null
    telefono?: string | null
    fechacontratacion?: Date | string | null
    salario?: number | null
    correo?: string | null
  }

  export type administradorUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administradorUncheckedUpdateWithoutUsuarioInput = {
    id_admin?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administradorUncheckedUpdateManyWithoutUsuarioInput = {
    id_admin?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaingreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type doctorUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutDoctorNestedInput
    especialidad?: especialidadUpdateOneWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateWithoutUsuarioInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
    cita?: citaUncheckedUpdateManyWithoutDoctorNestedInput
    especialidad_doctor?: especialidad_doctorUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type doctorUncheckedUpdateManyWithoutUsuarioInput = {
    id_doctor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pacienteUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUpdateManyWithoutPacienteNestedInput
    examen?: examenUpdateManyWithoutPacienteNestedInput
    pago?: pagoUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateWithoutUsuarioInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    cita?: citaUncheckedUpdateManyWithoutPacienteNestedInput
    examen?: examenUncheckedUpdateManyWithoutPacienteNestedInput
    pago?: pagoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type pacienteUncheckedUpdateManyWithoutUsuarioInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    tiposangre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedorUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamento?: medicamentoUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateWithoutUsuarioInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamento?: medicamentoUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateManyWithoutUsuarioInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: NullableStringFieldUpdateOperationsInput | string | null
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    id_direccion?: NullableIntFieldUpdateOperationsInput | number | null
    tipoproveedor?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type secretariaUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type secretariaUncheckedUpdateWithoutUsuarioInput = {
    id_secretaria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type secretariaUncheckedUpdateManyWithoutUsuarioInput = {
    id_secretaria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    segundonombre?: NullableStringFieldUpdateOperationsInput | string | null
    primerapellido?: StringFieldUpdateOperationsInput | string
    segundoapellido?: NullableStringFieldUpdateOperationsInput | string | null
    nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechacontratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}